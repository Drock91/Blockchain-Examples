using System;
using System.Globalization;
using System.Linq;
using System.IO;
using System.Security.Cryptography;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using Mirror;
using PlayFab;
#if UNITY_SERVER //|| UNITY_EDITOR
using PlayFab.MultiplayerAgent.Model;
using PlayFab.DataModels;
#endif
using UnityEngine.Events;
#if UNITY_SERVER //|| UNITY_EDITOR
using PlayFab.ServerModels;
using WebSocketSharp;
using WebSocketSharp.Server;
#endif
using UnityEngine.SceneManagement;
using UnityEngine.Networking;
using UnityEngine.Tilemaps;
using System.Net.Http;
using System.Text;
using Newtonsoft.Json;
using System.Collections.Concurrent;
using System.Threading;
using System.Threading.Tasks;
using SimpleJSON;
using NavMeshPlus.Components;
using UnityEngine.AI;
namespace dragon.mirror
{
    public class ConsumableEffects
{
    public enum Consumable
    {
        ArudinePie,
        SnakePie,
        RatSkewer,
        Sauerkraut,
        LobsterJerky,
        Shishkabob,
        StickyRatSkewer,
        HealingPotion,
        MagicPotion,
        HastePotion,
        GreaterHastePotion,
        Antidote,
        DefensePotion,
        GreaterDefensePotion,
        EnergyPotion,
        LifestealPotion,
        RejuvenationPotion
    }

    public struct ConsumableEffect
    {
        public string ConsumableName;
        public int hpHeal;
        public int mpHeal;
        public int arcanaBuff;
        public int agilityBuff;
        public int strengthBuff;
        public int fortitudeBuff;
        public int poisonResistBuff;
        public int diseaseResistBuff;
        public int armorBuff;
        public int energyRestore;
        public int lifesteal;

        public ConsumableEffect(
            string consumableName, int hp, int mp, int arcana, int agility, int strength, int fortitude, int poisonResist, int diseaseResist, int armor, int energy, int _lifesteal)
            {
                ConsumableName = consumableName;
                hpHeal = hp;
                mpHeal = mp;
                arcanaBuff = arcana;
                agilityBuff = agility;
                strengthBuff = strength;
                fortitudeBuff = fortitude;
                poisonResistBuff = poisonResist;
                diseaseResistBuff = diseaseResist;
                armorBuff = armor;
                energyRestore = energy;
                lifesteal = _lifesteal;
            }
        }

    public ConsumableEffect GetConsumableEffect(Consumable consumableUsed)
    {
        switch (consumableUsed)
        {
            case Consumable.ArudinePie:
                return new ConsumableEffect("Arudine Pie", 0, 1, 30, 0, 0, 15, 0, 0, 0, 0, 0);
            case Consumable.SnakePie:
                return new ConsumableEffect("Snake Pie", 5, 0, 0, 25, 0, 0, 20, 0, 0, 0, 0);
            case Consumable.RatSkewer:
                return new ConsumableEffect("Rat Skewer", 5, 0, 0, 0, 30, 0, 0, 0, 0, 0, 0);
            case Consumable.Sauerkraut:
                return new ConsumableEffect("Sauerkraut", 10, 0, 10, 0, 0, 10, 0, 20, 0, 0, 0);
            case Consumable.LobsterJerky:
                return new ConsumableEffect("Lobster Jerky", 5, 0, 0, 20, 20, 0, 0, 0, 0, 0, 0);
            case Consumable.Shishkabob:
                return new ConsumableEffect("Shishkabob", 10, 0, 0, 30, 30, 0, 0, 0, 0, 0, 0);
            case Consumable.StickyRatSkewer:
                return new ConsumableEffect("Sticky Rat Skewer", 10, 0, 0, 0, 50, 0, 0, 0, 0, 0, 0);
            case Consumable.HealingPotion:
                return new ConsumableEffect("Healing Potion", 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            case Consumable.MagicPotion:
                return new ConsumableEffect("Magic Potion", 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            case Consumable.HastePotion:
                return new ConsumableEffect("Haste Potion", 0, 0, 0, 15, 0, 0, 0, 0, 0, 0, 0);
            case Consumable.GreaterHastePotion:
                return new ConsumableEffect("Greater Haste Potion", 0, 0, 0, 25, 0, 0, 0, 0, 0, 0, 0);
            case Consumable.Antidote:
                return new ConsumableEffect("Antidote", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            case Consumable.DefensePotion:
                return new ConsumableEffect("Defense Potion", 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0);
            case Consumable.GreaterDefensePotion:
                return new ConsumableEffect("Greater Defense Potion", 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0);
            case Consumable.EnergyPotion:
                return new ConsumableEffect("Energy Potion", 0, 0, 0, 0, 0, 0, 0, 0, 0, 200, 0);
            case Consumable.LifestealPotion:
                return new ConsumableEffect("Lifesteal Potion", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1);
            case Consumable.RejuvenationPotion:
                return new ConsumableEffect("Rejuvenation Potion", 20, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0);
            default:
                return new ConsumableEffect("None", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        }
    }
}
public class IngredientDistributionCancel
{
    public string quality;
    public int quantity;
    public string itemID;
    public string itemName;

}
    [Serializable]
public class CurrencyBase
{
    public string currency;
    public string value;
}

// Define a derived class for objects with the 'counterparty' field
[Serializable]
public class DetailedCurrency : CurrencyBase
{
    public string counterparty;
}
    public class TacticianExtractor
{
    public string BirthDate { get; set; }
    public string ZodiacSign { get; set; } // New field
    public string EyeColor { get; set; }
    public string BodyStyle { get; set; }
    public string BonusStatStrength { get; set; }
    public string BonusStatAgility { get; set; }
    public string BonusStatFortitude { get; set; }
    public string BonusStatArcana { get; set; }
    public string BonusStatArmor { get; set; }
    public string GiantRep { get; set; } // New field
    public string DragonRep { get; set; } // New field
    public string LizardRep { get; set; } // New field
    public string OrcRep { get; set; } // New field
    public string FaerieRep { get; set; } // New field
    public string ElvesRep { get; set; } // New field
    public string DwarvesRep { get; set; } // New field
    public string GnomesRep { get; set; } // New field
    public string DKPCooldown { get; set; } // New field

}

[System.Serializable]
public class Details
{
    public string userId;
    public string goldAmount;
    public string walletAddress;
}

[System.Serializable]
public class ResponseObj
{
    public Details details;
    public string success;
    public string message;
}
[System.Serializable]
public class RemoveResponseObj
{
    public string success;
}
[System.Serializable]

public class Message{
        public string registerBuild { get; set; }
        public string buildID { get; set; }
        public string sessionID  { get; set; }
        public string serverPlayers { get; set; }
        public string version { get; set; }
        public string apiKey { get; set; }
        public string ipAddress { get; set; }
        public string port { get; set; }
    }
[System.Serializable]
public class XrplAccountInfoResponse
{
    public Result result { get; set; }

    public class Result
    {
        public string status { get; set; }
        public AccountData account_data { get; set; }
    }
    

    public class AccountData
    {
        public long Sequence { get; set; }

        // ... other fields
    }
}

    [System.Serializable]

    public class Amount
{
    public string currency { get; set; }
    public string issuer { get; set; }
    public string value { get; set; }
}
[System.Serializable]
public class TxJson
{
    public string TransactionType { get; set; }
    public string Destination { get; set; }
    public Amount Amount { get; set; }
    //public LimitAmount LimitAmount { get; set; }
    //public TakerPays TakerPays { get; set; }
    //public TakerGets TakerGets { get; set; }
}
[System.Serializable]
public class TrustSet
{
    public string TransactionType { get; set; }
    public string Account  { get; set; }
    public Amount Amount { get; set; }
    public LimitAmount LimitAmount { get; set; }
}
[System.Serializable]
public class MarketOrderXRPL
{
    public string TransactionType { get; set; }
    public TakerPays TakerPays { get; set; }
    public TakerGets TakerGets { get; set; }
}
public class TakerPays{
    public Amount Amount { get; set; }

}
public class TakerGets{
    public Amount Amount { get; set; }

}
[System.Serializable]
public class TransactionPayload
{
    public TxJson txjson { get; set; }
    public CustomMeta custom_meta { get; set; }
    public Options options { get; set; }
}
[System.Serializable]
public class TransactionPayloadTrust
{
    public TrustSet txjson { get; set; }
    public CustomMeta custom_meta { get; set; }
    public Options options { get; set; }
}
[System.Serializable]
public class TransactionPayloadMarketOrder
{
    public MarketOrderXRPL txjson { get; set; }
    public CustomMeta custom_meta { get; set; }
    public Options options { get; set; }
}
public class Tx
{
    public string Account { get; set; }
    public string Destination { get; set; }
    // ... Other fields
}
public class Transaction
{
    public Tx tx { get; set; }
    public bool validated { get; set; }
}
public class LimitAmount
{
    public string currency  { get; set; }
    public string issuer { get; set; }
    public string value { get; set; }


}

public class TransactionsResponse
{
    public Result result { get; set; }
}
public class Result
{
    public List<Transaction> transactions { get; set; }
}
[System.Serializable]
public class CustomMeta
{
    public string identifier { get; set; }
    public string blob { get; set; }
    public string instruction { get; set; }

}
[System.Serializable]
public class Options
{
    public bool submit { get; set; }
    public bool multisign { get; set; }
    public int expire { get; set; }
    public string force_network { get; set; }

}
[System.Serializable]

public class XummStatusResponse
{
    public string status { get; set; }
}
[System.Serializable]
    public class Meta
    {
        public Amount delivered_amount { get; set; }

        public string TransactionResult { get; set; }
        public int TransactionIndex { get; set; }
    }
//[System.Serializable]
//    public class TakerPays
//    {
//        public string currency { get; set; }
//        public string issuer { get; set; }
//        public string value { get; set; }
//    }
    public class Request {
            public string command { get; set; }
            public string id { get; set; }
            public string tx_blob { get; set; }
        }
    [System.Serializable]
public class XrplErrorResponse
{
    public Result result { get; set; }

    public class Result
    {
        public string error { get; set; }
        public string error_exception { get; set; }
        public string id { get; set; }
        public Request request { get; set; }
        public string status { get; set; }
        public string type { get; set; }

        // Add more fields as needed
    }
}
[System.Serializable]
public class XrplTransactionResponse
{
    public Result result { get; set; }

    public class Result
    {

        public string status { get; set; }
        public string Account { get; set; }
        public string Fee { get; set; }
        public long LastLedgerSequence { get; set; }
        public long OfferSequence { get; set; }
        public long Sequence { get; set; }
        public string SigningPubKey { get; set; }
        public string TakerGets { get; set; }
        public TakerPays TakerPays { get; set; }
        public string TransactionType { get; set; }
        public string TxnSignature { get; set; }
        public long date { get; set; }
        public string hash { get; set; }
        public long inLedger { get; set; }
        public long ledger_index { get; set; }
        public Meta meta { get; set; }
        public bool validated { get; set; }
        public string error { get; set; }
        public int? error_code { get; set; }
        public string error_message { get; set; }
        public LimitAmount LimitAmount { get; set; }

    }
}
[System.Serializable]
public class XummResponse
{
    public string uuid { get; set; }
    public string transactionId { get; set; } // Replace with actual property name if different
    public Refs refs { get; set; }
    public Next next { get; set; }
    public bool pushed { get; set; }

    public class Next
    {
        public string always { get; set; }
    }

    public class Refs
    {
        
        public string qr_png { get; set; }
        public string qr_matrix { get; set; }
        public string[] qr_uri_quality_opts { get; set; }
        public string websocket_status { get; set; }
    }
}
[System.Serializable]
public class XummDetailedResponse
{
    public Meta meta { get; set; }
    public CustomMeta custom_meta { get; set; }
    public Response response { get; set; }

    [System.Serializable]
    public class Meta
    {
        public string bestMarketPrice;
        public bool TrustLineNotSet;
        public bool NoAddressSendBackToMain;
        public bool NotEnoughLiquidityButHasTrustLine;
        
        public string RequiredAmount;
        public bool wrongSigner;
        public bool exists;
        public string uuid;
        public bool signed; // assuming this field exists in your actual API response
        public bool submit; // assuming this field exists in your actual API response
        public bool resolved; // assuming this field exists in your actual API response
        public bool expired; // assuming this field exists in your actual API response
    }
    [System.Serializable]
    public class Response
    {
        public string hex;
        public string txid;
        public string account; // Add this to capture the sender's XRP public address
    }
}
[System.Serializable]
    public class CurrencyBalance
    {
        public string currency;
        public string value;
    }

public static class JsonHelper
{
    public static T[] FromJson<T>(string json)
    {
        // Add a wrapper to handle an array at the top level
        string newJson = "{ \"array\": " + json + "}";
        Wrapper<T> wrapper = JsonUtility.FromJson<Wrapper<T>>(newJson);
        return wrapper.array;
    }

    [System.Serializable]
    private class Wrapper<T>
    {
        public T[] array;
    }
}
    public class PlayFabServer : NetworkManager
    {
        [SerializeField] public string Version;
        [SerializeField] public bool Local;
        [System.Serializable]
        public class NFTMetadata
        {
            public string name;
            public string description;
            public string external_url;
            public string category;
            public string md5hash;
            public bool is_explicit;
            public string content_type;
            public string image_url;
            public string animation_url;
        }
        [System.Serializable]
        public class NFTData
        {
            public int Flags;
            public string Issuer;
            public string NFTokenID;
            public int NFTokenTaxon;
            public int TransferFee;
            public string URI;
            public int nft_serial;
        }
        public static PlayFabServer instance;
        #if UNITY_SERVER //|| UNITY_EDITOR
        private string CONVO_KEY = ""; 
        private string _Heroku_URL = ""; 
        private string _REGISTRATION_WALLET_ADDRESS = "rhB7i1DDJAmw1A3sVi6nR89GWcUkNPo6KJ"; 
        private string _GAME_WALLET_ADDRESS = ""; 
        private string _DKP_REGISTRAR_ADDRESS = ""; 
        private string _TransmuteDKPKey = ""; 
        private string _DKP_ISSUER = "rM7zpZQBfz9y2jEkDrKcXiYPitJx9YTS1J";
        private string _DKP_NFT_ISSUER = "rhB7i1DDJAmw1A3sVi6nR89GWcUkNPo6KJ";
        private string _DKP_XAPP_FIRST =  ""; 
        private string _DKP_XAPP_SECOND = ""; 
        private string xrpscanAPI = "https://api.xrpscan.com/api/v1/account/";
        private static string sharedSecret = "";
        private static string salt = "";
        #endif
        private List<PlayerConnection> playerConnections = new List<PlayerConnection>();
        #if UNITY_SERVER //|| UNITY_EDITOR
        private List<ConnectedPlayer> connectedPlayers = new List<ConnectedPlayer>();
        #endif
        public static UnityEvent<CombatLogNet, Match> AwardEXPCPChat = new UnityEvent<CombatLogNet, Match>();
        public static UnityEvent<Match> ENDMATCHFULLY = new UnityEvent<Match>();
        public static UnityEvent<Match, float , float> SendEXPCP = new UnityEvent<Match, float , float>();
        public static UnityEvent<Match> ENDMATCHMAKER = new UnityEvent<Match>();
        public static UnityEvent<Match, TurnManager, float> SendingGoldAmount = new UnityEvent<Match, TurnManager, float>();
        public static UnityEvent<Match, TurnManager, string> SendingItem = new UnityEvent<Match, TurnManager, string>();
        public static UnityEvent<ScenePlayer> charFreeze = new UnityEvent<ScenePlayer>();
        public static UnityEvent<ChangedGearMessage> charGearChangeMatch = new UnityEvent<ChangedGearMessage>();
        public static UnityEvent<ChangedGearMessage, ScenePlayer> tactGearChangeMatch = new UnityEvent<ChangedGearMessage, ScenePlayer>();
        public static UnityEvent<string, ScenePlayer, Match, CharacterBuffListItem> ConsumedItemInMatch = new UnityEvent<string, ScenePlayer, Match, CharacterBuffListItem>();
        [SerializeField] GameObject turnManagerPrefab;
        private const string TOWNOFARUDINE = "TOWNOFARUDINE";
        private const string TACTICIAN = "Tactician";
        private const string ELFCITY = "TOWNOFARUDINE";
        private const string OUTPOST = "TOWNOFARUDINE";
        //Prefabs
        [SerializeField] GameObject Player18PrefabModel;
        [SerializeField] GameObject Player37PrefabModel;
        [SerializeField] GameObject Player7PrefabModel;
        [SerializeField] GameObject Player23PrefabModel;
        [SerializeField] GameObject Player17PrefabModel;
        [SerializeField] GameObject Player36PrefabModel;
        [SerializeField] GameObject Player33PrefabModel;
        [SerializeField] GameObject Player43PrefabModel;
        [SerializeField] GameObject Player26PrefabModel;
        [SerializeField] GameObject Player45PrefabModel;
        [SerializeField] GameObject Player6PrefabModel;
        [SerializeField] GameObject Player22PrefabModel;
        [SerializeField] GameObject Player35PrefabModel;
        [SerializeField] GameObject WyvernBabyPrefabModel;
        [SerializeField] GameObject WyvernAdultPrefabModel;
        // Mobs
        List<GameObject> prefabs = new List<GameObject>();
        Dictionary<string, List<string>> prefabGroups = new Dictionary<string, List<string>>
{
    // caves
    { "RandomCaveTier1", new List<string> { "Bat", "Rat", "Snake", "Ghoul", "Spider", "Crocodile" } },
    { "RandomCaveTier2", new List<string> { "DragonWhelp", "SkeletonKnight", "GiantRat", "FireGhoul", "Mummy", "Ghost", "DiseasedGhoul", "PoisonGhoul", "Wolf", "MatureSpider" } },
    { "RandomCaveTier3", new List<string> { "Cyclops", "Ghast", "FireElemental", "GiantWolf", "GhoulNoble", "GhoulWarlock", "Spectre", "GhoulTreasurer", "GreaterMummy", "GiantSpider" } },
    { "RandomCaveTier4", new List<string> { "MummyLord", "ZombieKing", "GreaterSpectre", "DemonElite", "GreaterGhast" } },
    { "RandomCaveTier5", new List<string> { "BlackDragon", "Vampire", "Draco" } },

    // forests
    { "RandomForestTier1", new List<string> { "Bat", "Rat", "Snake", "Spider", "Crocodile", "OreGolem", "StoneGolem", "Deer", "PossessedPlant", "PossessedTree" } },
    { "RandomForestTier2", new List<string> { "DragonWhelp", "GiantRat", "Wolf", "MatureSpider" } },
    { "RandomForestTier3", new List<string> { "Cyclops", "FireElemental", "GiantWolf", "GiantSpider", "LizardGladiator", "LizardWarlock" } },
    { "RandomForestTier4", new List<string> { "Sphinx" } },
    { "RandomForestTier5", new List<string> { "BlackDragon", "Draco" } },

    // swamps
    { "RandomSwampTier1", new List<string> { "Bat", "Rat", "Snake", "Ghoul", "Spider", "Crocodile" } },
    { "RandomSwampTier2", new List<string> { "DragonWhelp", "SkeletonKnight", "GiantRat", "FireGhoul", "Mummy", "Ghost", "DiseasedGhoul", "PoisonGhoul", "Wolf", "MatureSpider" } },
    { "RandomSwampTier3", new List<string> { "Cyclops", "Ghast", "FireElemental", "GiantWolf", "GhoulWarlock", "GhoulNoble", "Spectre", "GhoulTreasurer", "GreaterMummy", "GiantSpider" } },
    { "RandomSwampTier4", new List<string> { "MummyLord", "ZombieKing", "GreaterSpectre", "DemonElite", "GreaterGhast", "SeaSerpent" } },
    { "RandomSwampTier5", new List<string> { "BlackDragon", "Vampire", "Draco" } },

    // deserts
    { "RandomDesertTier1", new List<string> { "Bat", "Rat", "Snake" } },
    { "RandomDesertTier2", new List<string> { "DragonWhelp", "GiantRat", "Wolf", "MatureSpider" } },
    { "RandomDesertTier3", new List<string> { "Cyclops", "FireElemental", "GiantWolf", "GiantSpider", "LizardGladiator", "LizardWarlock", "Sphinx" } },
    { "RandomDesertTier4", new List<string> { "MummyLord", "ZombieKing", "GreaterSpectre", "DemonElite", "Sphinx" } },
    { "RandomDesertTier5", new List<string> { "BlackDragon", "Draco" } },

    // water
    { "RandomWaterTier1", new List<string> { "Jellyfish", "LizardChild", "Lobster" } },
    { "RandomWaterTier2", new List<string> { "LizardArcher", "LizardKnight", "LizardMage", "LizardPriest", "MatureSpider" } },
    { "RandomWaterTier3", new List<string> { "GiantWolf", "SeaSerpent", "LizardGladiator", "LizardWarlock" } },
    { "RandomWaterTier4", new List<string> { "SeaSerpent", "Sphinx", "Octopus" } },
    { "RandomWaterTier5", new List<string> { "Whale" } },

    // tundra
    { "RandomTundraTier1", new List<string> { "Bat", "Rat", "Snake", "Spider" } },
    { "RandomTundraTier2", new List<string> { "DragonWhelp", "SkeletonKnight", "GiantRat", "Wolf", "MatureSpider" } },
    { "RandomTundraTier3", new List<string> { "Cyclops", "FireElemental", "GiantWolf", "GiantSpider" } },
    { "RandomTundraTier4", new List<string> { "MummyLord", "ZombieKing", "GreaterSpectre", "DemonElite", "GreaterGhast", "Sphinx" } },
    { "RandomTundraTier5", new List<string> { "BlackDragon", "Vampire", "Draco" } }
};
        #if UNITY_SERVER //|| UNITY_EDITOR
    public async Task<bool> VerifyPlayerPayment(string playerWalletAddress)
    {
        // Step 1: Fetch registration wallet transaction history
        var (success, transactionsJson) = await GetTransactionHistory();
        if (!success)
        {
            Debug.LogError("Failed to retrieve transaction history");
            return false;
        }
        // Step 2: Parse the transactions from JSON into a list
        var transactionsList = ParseTransactionHistory(transactionsJson);
        // Step 3: Loop through the transactions to look for the player's wallet as sender
        foreach (var transaction in transactionsList)
        {
            if(transaction.tx.Account != null){
                if (transaction.tx.Account == playerWalletAddress)
                {
                    print($"Found players wallet they are trying to double sign a wallet no go");
                    // Player's wallet found as sender in one of the transactions
                    return true;
                }
            }
        }
        // Player's wallet was not found as a sender in any transactions
        return false;
    }

    private async Task<(bool, string)> GetTransactionHistory()
    {
        using (var httpClient = new HttpClient())
        {
            var postData = new
            {
                method = "account_tx",
                @params = new object[]
                {
                    new
                    {
                        account = _REGISTRATION_WALLET_ADDRESS,
                        ledger_index_max = -1
                    }
                }
            };
            var jsonString = JsonConvert.SerializeObject(postData);
            var httpContent = new StringContent(jsonString, Encoding.UTF8, "application/json");
            var response = await httpClient.PostAsync("https://s1.ripple.com:51234/", httpContent); // Adjust the endpoint URL accordingly
            if (response.IsSuccessStatusCode)
            {
                var responseContent = await response.Content.ReadAsStringAsync();
                return (true, responseContent); // Return the JSON response which contains transaction history
            }
            else
            {
                Debug.LogError("Error fetching transaction history from XRPL: " + response.StatusCode);
                return (false, "Failed to retrieve transaction history");
            }
        }
    }

    private List<Transaction> ParseTransactionHistory(string transactionsJson)
    {
        var parsedJson = JsonConvert.DeserializeObject<TransactionsResponse>(transactionsJson);
        return parsedJson.result.transactions;
    }
    public static string EncryptString(string plainText)
{
    byte[] encryptedByteArray;  // Declare this variable at a scope where you can access it later

    using (Aes aesAlg = Aes.Create())
    {
        Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(sharedSecret, Encoding.ASCII.GetBytes(salt));
        aesAlg.Key = key.GetBytes(16);  // AES key size is 16 bytes
        aesAlg.IV = key.GetBytes(16);   // AES IV size is 16 bytes

        ICryptoTransform encryptor = aesAlg.CreateEncryptor(aesAlg.Key, aesAlg.IV);

        using (MemoryStream msEncrypt = new MemoryStream())
        {
            using (CryptoStream csEncrypt = new CryptoStream(msEncrypt, encryptor, CryptoStreamMode.Write))
            {
                using (StreamWriter swEncrypt = new StreamWriter(csEncrypt))
                {
                    swEncrypt.Write(plainText);
                }
            }
            encryptedByteArray = msEncrypt.ToArray();  // Populate the byte array here
        }
    }

    return Convert.ToBase64String(encryptedByteArray); // Return or use the byte array as needed
}

    public static string DecryptString(string cipherText)
    {
        using (Aes aesAlg = Aes.Create())
        {
            Rfc2898DeriveBytes key = new Rfc2898DeriveBytes(sharedSecret, Encoding.ASCII.GetBytes(salt));

            aesAlg.Key = key.GetBytes(16);
            aesAlg.IV = key.GetBytes(16);

            ICryptoTransform decryptor = aesAlg.CreateDecryptor(aesAlg.Key, aesAlg.IV);

            using (MemoryStream msDecrypt = new MemoryStream(Convert.FromBase64String(cipherText)))
            {
                using (CryptoStream csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (StreamReader srDecrypt = new StreamReader(csDecrypt))
                    {
                        return srDecrypt.ReadToEnd();
                    }
                }
            }
        }
    }
        async void RegisterTrustSet(NetworkConnectionToClient conn, string playfabID, int tries, string address){
            Debug.LogError($"calling registertrust set the address is {address} playfab is {playfabID} ");
            print($"RegisterTrustSet!!!!!!!!! *********************************!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
            PlayerInfo playerinfo = (PlayerInfo)conn.authenticationData;

            print($"Tries: {tries} are how many times we have tried to register");
            if(conn == null){
                print("No connection found when trying to register account");
                return;
            }
            //if(tries > 2){
            //    var msg = new XummMessage { code = "Too many attempts to register a wallet to this account, please try again later, for now we need to rest", error = true, quit = true };
            //    conn.Send(msg);
            //    return;
            //}
            tries++;
            if(string.IsNullOrEmpty(playfabID)){
                playfabID = playerinfo.PlayFabId;
            }
            string id = EncryptString(playfabID);
            string xummIdentifier = Guid.NewGuid().ToString();
            // Prepare your payload object here.
            if(address == null || address == "Undefined"){
                var _msg = new XummMessage { code = "The registration QR code has expired, trying again in a few seconds." , error = true };
                conn.Send(_msg);
                await Task.Delay(10000);
                print("we cannot go any further because we will bug out, we need to go back to get an account number");
                RegisterAccount(conn, playfabID, tries --, address);
                return;
            }
            using (var httpClient = new HttpClient())
            {
                httpClient.DefaultRequestHeaders.Add("x-api-key", CONVO_KEY);
                var response = await httpClient.PostAsync($"{_Heroku_URL}/xummqueue?id={id}", null);  // No payload
                if (response.IsSuccessStatusCode)
                {
                    // Successfully joined the queue
                    print("queue is ready lets go!");
                }
                else
                {
                    // Log the failure or take other actions
                    Debug.LogError("Failed to join the queue, retrying...");
                    
                    RegisterTrustSet(conn, playfabID, tries --, address);
                    return;
                    // Wait before the next retry
                }
            }
            string jsonPayload = @"{
    ""txjson"": {
        ""TransactionType"": ""TrustSet"",
        ""Account"": """ + address + @""",
        ""LimitAmount"": {
            ""currency"": ""DKP"",
            ""issuer"": """ + _DKP_ISSUER + @""",
            ""value"": ""500000000000""
        },
        ""Flags"": 131072
    },
    ""options"": {
        ""submit"": false,
        ""multisign"": false,
        ""expire"": 5,
        ""force_network"": ""MAINNET""
    },
    ""custom_meta"": {
        ""identifier"": """ + xummIdentifier + @""",
        ""blob"": """ + id + @""",
        ""instruction"": ""Please proceed to authenticate the trust set request, this is required for a DragonKill account 🔒.""
    }
}";
            /*
            string jsonPayload = @"{
    ""txjson"": {
        ""TransactionType"": ""TrustSet"",
        ""Account"": """ + address + @""",
        ""LimitAmount"": {
            ""currency"": ""DKP"",
            ""issuer"": """ + _DKP_ISSUER + @""",
            ""value"": ""500000000000""
        }
    },
    ""options"": {
        ""submit"": false,
        ""multisign"": false,
        ""expire"": 5,
        ""force_network"": ""MAINNET""
    },
    ""custom_meta"": {
        ""identifier"": """ + xummIdentifier + @""",
        ""blob"": """ + id + @""",
        ""instruction"": ""Please proceed to authenticate the trust set request, this is required for a DragonKill account 🔒.""
    }
}";*/
/*
            //send these over to heroku
            var payload = new TransactionPayloadTrust
            {
                txjson = new TrustSet
                {
                    TransactionType = "TrustSet",
                    Account = address,
                    LimitAmount = new LimitAmount
                    {
                        currency = "DKP",
                        issuer = _DKP_ISSUER,
                        value = "500000000000" // New limit of 10 billion dkp
                    }
                },
                options = new Options
                {
                    submit = false,
                    multisign = false,
                    expire = 5,
                    force_network = "MAINNET"
                },
                custom_meta = new CustomMeta
                {
                    identifier = xummIdentifier,
                    blob = id,
                    instruction = "Please proceed to authenticate the trust set request, this is required for a DragonKill account 🔒."
                }
            };
            */
            //string jsonPayload = JsonConvert.SerializeObject(payload);
            // Use the HttpClient to make a POST request
            using (var httpClient = new HttpClient())
            {
                httpClient.DefaultRequestHeaders.Add("x-api-key", _DKP_XAPP_FIRST);
                httpClient.DefaultRequestHeaders.Add("x-api-secret", _DKP_XAPP_SECOND);
                var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");
                var response = await httpClient.PostAsync("https://xumm.app/api/v1/platform/payload", content);
                // Check if the request was successful
                if (response.IsSuccessStatusCode)
                {
                    var responseContent = await response.Content.ReadAsStringAsync();
                    Debug.Log("Response Content: " + responseContent);
                    var xummResponse = JsonConvert.DeserializeObject<XummResponse>(responseContent);
                    string qrUrl = xummResponse.refs.qr_png; // Access the qr_png field under refs
                    print($"{qrUrl} was the provided qrURL!");
                    var msg = new SendQRCodeUrlMessage { qrCodeUrl = qrUrl };
                    conn.Send(msg);
                    Debug.LogError($"Sending payload from XUMM to {msg.qrCodeUrl} playfabAccount");
                    string payloadId = xummResponse.uuid; // Retrieve the payload ID from the xummResponse
                    print(payloadId + " is payload id!");
                    int pollingInterval = 10000; // Poll every 10 seconds
                    await MonitorTrustlineRegister(payloadId, pollingInterval, conn, tries, address, "100");
                    //Stop here we need to reconfigure this so that it can get the proper stuff it needs for xrpl
                }
                else
                {
                    var errorContent = await response.Content.ReadAsStringAsync();
                    Debug.LogError("Error sending payload to XUMM: " + response.StatusCode);
                    Debug.LogError("Error Details: " + errorContent);
                    var msg = new XummMessage { code = "Error on payload, we will generate you a new QR code in just a few moments.", error = true };
                    conn.Send(msg);
                    await Task.Delay(5000);
                    print($"{tries} is our trust set tries");
                    RegisterTrustSet(conn, playfabID, tries --, address);

                }

            }
        }
        private async Task MonitorTrustlineRegister(string payloadId, int pollingInterval, NetworkConnectionToClient conn, int registerTries, string address, string requiredAmount){
            bool validatorNodeVerified = false;
            XummDetailedResponse savedResponse = null;
            string decodedID = string.Empty;
            PlayerInfo playerinfo = (PlayerInfo)conn.authenticationData;

            while (true){
                if(!activeConnectionIds.Contains(conn.connectionId)){
                    print("connection was disconnected");
                    return;
                }
                print("Polling MonitorTrustlineRegister");
                print(payloadId + " is payload id!");
                if(string.IsNullOrEmpty(address)){
                    address = "Undefined";
                }
                var xummstatus = await CheckXummStatusAPP(payloadId, address);
                if(xummstatus != null){
                    savedResponse = xummstatus;
                    if (xummstatus.meta.signed && !xummstatus.meta.submit && xummstatus.meta.resolved){
                        print("right before decodeID");
                        if(!string.IsNullOrEmpty(xummstatus.custom_meta.blob)){
                            decodedID = DecryptString(xummstatus.custom_meta.blob);
                        } else {
                            decodedID = playerinfo.PlayFabId;
                        }
                        if(string.IsNullOrEmpty(decodedID)){
                            print("no decode for some reason, we changed it out to make sure we are good to go");
                            decodedID = playerinfo.PlayFabId;
                        }
                        //decodedID = DecryptString(xummstatus.custom_meta.blob);
                        print($"the player who requested to MonitorTrustlineRegister had a playfab of {decodedID} and their public xrp wallet was {xummstatus.response.account}, {xummstatus.response.txid} was our txid");
                        //lets check xrpl now 
                        print($"Polling rippleD here is the hex {xummstatus.response.hex}");
                        var msg = new XummMessage { code = "Trust set was sent to XRPL from Xumm", error = false };
                        conn.Send(msg);
                        var (xrplStatus, status) = await SubmitBlobToXRPL(xummstatus.response.hex);
                        if(xrplStatus){
                            break; // Exit the loop
                        }
                    } else {
                        if(!xummstatus.meta.signed){

                            var msg = new XummMessage { code = "The trust set QR code was cancelled, trying again in a few moments." , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            print($"{registerTries} is our register tries amount, running register on cancel payload");
                            RegisterTrustSet(conn, decodedID, registerTries, address);
                            return;
                        }
                        if(xummstatus.meta.expired){
                            var msg = new XummMessage { code = "The trust set QR code has expired, trying again in a few seconds." , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            print($"{registerTries} is our register tries amount, running register on expired payload payload");
                            RegisterTrustSet(conn, decodedID, registerTries, address);
                            return;
                        }
                    }
                } else {
                    var msg = new XummMessage { code = "Checking status trust set status one moment please" , error = true, pending = true };
                    conn.Send(msg);
                }
                await Task.Delay(pollingInterval);
            }
            print("Transaction was signed lets move on to looking for the validated payload");
            await Task.Delay(10000);
            int tries = 0;
            while(!validatorNodeVerified && savedResponse != null && tries < 3){
                tries ++;
                print($"Polling rippleD try # {tries}");
                var msg = new XummMessage { code = "Asking the XRP ledger to verify your trust set for DKP", error = false };
                conn.Send(msg);
                var validated = await ValidateTrustlineTransaction(savedResponse.response.txid);
                if (validated){
                    PurchaseDKPMarketPriceRegistration(conn, decodedID, registerTries, savedResponse.response.account, requiredAmount);
                    return; // Exit the loop
                }
                await Task.Delay(pollingInterval);
            }
            RegisterTrustSet(conn, decodedID, registerTries, address);

        }
    async void ReassignTrustSet(NetworkConnectionToClient conn, string playfabID, int tries, string amount){
        tries ++;
        string id = EncryptString(playfabID);
            string xummIdentifier = Guid.NewGuid().ToString();
            // Prepare your payload object here.
            using (var httpClient = new HttpClient())
            {
                httpClient.DefaultRequestHeaders.Add("x-api-key", CONVO_KEY);

                var response = await httpClient.PostAsync($"{_Heroku_URL}/xummqueue?id={id}", null);  // No payload
                if (response.IsSuccessStatusCode)
                {
                    // Successfully joined the queue
                    print("queue is ready lets go!");
                }
                else
                {
                    // Log the failure or take other actions
                    Debug.LogError("Failed to join the queue, retrying...");
                    ReassignTrustSet(conn, playfabID, tries --, amount);
                    return;
                    // Wait before the next retry
                }
            }
            ScenePlayer stash = conn.identity.gameObject.GetComponent<ScenePlayer>();

            //send these over to heroku
            var payload = new TransactionPayloadTrust
            {
                txjson = new TrustSet
                {
                    TransactionType = "TrustSet",
                    Account = stash.GetTacticianSheet().Address,
                    LimitAmount = new LimitAmount
                    {
                        currency = "DKP",
                        issuer = _DKP_ISSUER,
                        value = "500000000000" // New limit of 10 billion dkp
                    }
                },
                options = new Options
                {
                    submit = false,
                    multisign = false,
                    expire = 5,
                    force_network = "MAINNET"
                },
                custom_meta = new CustomMeta
                {
                    identifier = xummIdentifier,
                    blob = id,
                    instruction = "Please proceed to authenticate the trust set request, this is required for a DragonKill account 🔒."
                }
            };
            string jsonPayload = JsonConvert.SerializeObject(payload);
            // Use the HttpClient to make a POST request
            using (var httpClient = new HttpClient())
            {
                httpClient.DefaultRequestHeaders.Add("x-api-key", _DKP_XAPP_FIRST);
                httpClient.DefaultRequestHeaders.Add("x-api-secret", _DKP_XAPP_SECOND);
                var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");
                var response = await httpClient.PostAsync("https://xumm.app/api/v1/platform/payload", content);
                // Check if the request was successful
                if (response.IsSuccessStatusCode)
                {
                    var responseContent = await response.Content.ReadAsStringAsync();
                    Debug.Log("Response Content: " + responseContent);
                    var xummResponse = JsonConvert.DeserializeObject<XummResponse>(responseContent);
                    string qrUrl = xummResponse.refs.qr_png; // Access the qr_png field under refs
                    print($"{qrUrl} was the provided qrURL!");
                    var msg = new XummTransmute { qrCodeUrl = qrUrl, error = false};
                    conn.Send(msg);
                    Debug.LogError($"Sending payload from XUMM to {msg.qrCodeUrl} playfabAccount");
                    string payloadId = xummResponse.uuid; // Retrieve the payload ID from the xummResponse
                    int pollingInterval = 10000; // Poll every 10 seconds
                    await MonitorTrustlineReassigned(payloadId, pollingInterval, conn, tries, amount);
                    //Stop here we need to reconfigure this so that it can get the proper stuff it needs for xrpl
                }
                else
                {
                    var errorContent = await response.Content.ReadAsStringAsync();
                    Debug.LogError("Error sending payload to XUMM: " + response.StatusCode);
                    Debug.LogError("Error Details: " + errorContent);
                    var msg = new XummTransmute { code = "Error on payload, we will generate you a new QR code in just a few moments.", error = true };
                    conn.Send(msg);
                    await Task.Delay(5000);
                    print($"{tries} is our register tries amount, we had issue on making payload for xumm trying again");
                    ReassignTrustSet(conn, playfabID, tries --, amount);

                }

            }
    }
    private async Task MonitorTrustlineReassigned(string payloadId, int pollingInterval, NetworkConnectionToClient conn, int registerTries, string amount){
            bool validatorNodeVerified = false;
            XummDetailedResponse savedResponse = null;
            string decodedID = string.Empty;
            while (true){
                if(!activeConnectionIds.Contains(conn.connectionId)){
                    print("connection was disconnected");
                    return;
                }
                print("Polling XUMM 1");
                print(payloadId + " is payload id!");
                var xummstatus = await CheckXummStatusAPP(payloadId, "Undefined");
                if(xummstatus != null){
                    savedResponse = xummstatus;
                    if (xummstatus.meta.signed && !xummstatus.meta.submit && xummstatus.meta.resolved){
                        print("right before decodeID");
                        decodedID = DecryptString(xummstatus.custom_meta.blob);
                        print($"the player who requested to register had a playfab of {decodedID} and their public xrp wallet was {xummstatus.response.account}, {xummstatus.response.txid} was our txid");
                        //lets check xrpl now 
                        print($"Polling rippleD here is the hex {xummstatus.response.hex}");
                        var msg = new XummTransmute { code = "Trust set was sent to XRPL from Xumm", error = false };
                        conn.Send(msg);
                        var (xrplStatus, status) = await SubmitBlobToXRPL(xummstatus.response.hex);
                        if(xrplStatus){
                            break; // Exit the loop
                        }
                    } else {
                        if(!xummstatus.meta.signed && xummstatus.meta.resolved){

                            var msg = new XummTransmute { code = "The trust set QR code was cancelled, trying again in a few moments." , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            print($"{registerTries} is our register tries amount, running register on cancel payload");
                            ReassignTrustSet(conn, decodedID, registerTries, amount);
                            return;
                        }
                        if(xummstatus.meta.expired){
                            var msg = new XummTransmute { code = "The trust set QR code has expired, trying again in a few seconds." , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            print($"{registerTries} is our register tries amount, running register on expired payload payload");
                            ReassignTrustSet(conn, decodedID, registerTries, amount);
                            return;
                        }
                    }
                } else {
                    var msg = new XummTransmute { code = "Checking status one moment please" , error = true };
                    conn.Send(msg);
                }
                await Task.Delay(pollingInterval);
            }
            print("Transaction was signed lets move on to looking for the validated payload");
            await Task.Delay(10000);
            int tries = 0;
            while(!validatorNodeVerified && savedResponse != null && tries < 3){
                tries ++;
                print($"Polling rippleD try # {tries}");
                var msg = new XummTransmute { code = "Asking the XRP ledger to verify your trust set for DKP", error = false };
                conn.Send(msg);
                var validated = await ValidateTrustlineTransaction(savedResponse.response.txid);
                if (validated){
                    // Success, credit the account
                    DKPTOGOLDTRANSMUTE(conn, decodedID, amount);
                    return; // Exit the loop
                }
                await Task.Delay(pollingInterval);
            }
            ReassignTrustSet(conn, decodedID, registerTries, amount);
        }
        async void PurchaseDKPMarketPriceRegistration(NetworkConnectionToClient conn, string playfabID, int tries, string addressPUB, string amountRequired){
            if(conn == null){
                print("connection was disconnected");
                return;
            }
            if(!activeConnectionIds.Contains(conn.connectionId)){
                    print("connection was disconnected");
                    return;
                }
                
            var marketPrice = await GetFairMarketValueRegisterPrice(amountRequired);
            print($"market price is {marketPrice.meta.bestMarketPrice}");
            //float xrpDrops = float.Parse(marketPrice.meta.bestMarketPrice) * 1000000f;
            string id = EncryptString(playfabID);
            string xummIdentifier = Guid.NewGuid().ToString();

            /*
            string jsonPayload = @"{
    ""txjson"": {
        ""TransactionType"": ""OfferCreate"",
        ""TakerPays"": {
            ""currency"": ""DKP"",
            ""issuer"": """ + _DKP_ISSUER + @""",
            ""value"": ""50000""
        },
        ""TakerGets"": {
            ""currency"": ""XRP"",
            ""value"": """ + xrpDrops.ToString() + @"""
        }
    },
    ""options"": {
        ""submit"": false,
        ""multisign"": false,
        ""expire"": 5,
        ""force_network"": ""MAINNET""
    },
    ""custom_meta"": {
        ""identifier"": """ + xummIdentifier + @""",
        ""blob"": """ + id + @""",
        ""instruction"": ""Please proceed to authenticate the market order request.""
    }
}";
*/
double calculatedMarketPrice = double.Parse(marketPrice.meta.bestMarketPrice);
long xrpDrops = (long) Math.Round(calculatedMarketPrice * 1000000); // Convert to drops and round to nearest integer

string jsonPayload = @"{
    ""txjson"": {
        ""TransactionType"": ""OfferCreate"",
        ""Account"": """ + addressPUB + @""",
        ""TakerPays"": {
            ""currency"": ""DKP"",
            ""issuer"": """ + _DKP_ISSUER + @""",
            ""value"": ""100""
        },
        ""TakerGets"": """ + xrpDrops.ToString() + @"""
    },
    ""options"": {
        ""submit"": false,
        ""multisign"": false,
        ""expire"": 5,
        ""force_network"": ""MAINNET""
    },
    ""custom_meta"": {
        ""identifier"": """ + xummIdentifier + @""",
        ""blob"": """ + id + @""",
        ""instruction"": ""Please proceed to authenticate the market order request.""
    }
}";
            // Use the HttpClient to make a POST request
            using (var httpClient = new HttpClient())
            {
                httpClient.DefaultRequestHeaders.Add("x-api-key", _DKP_XAPP_FIRST);
                httpClient.DefaultRequestHeaders.Add("x-api-secret", _DKP_XAPP_SECOND);
                var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");
                var response = await httpClient.PostAsync("https://xumm.app/api/v1/platform/payload", content);
                // Check if the request was successful
                if (response.IsSuccessStatusCode)
                {
                    var responseContent = await response.Content.ReadAsStringAsync();
                    Debug.Log("Response Content: " + responseContent);
                    var xummResponse = JsonConvert.DeserializeObject<XummResponse>(responseContent);
                    string qrUrl = xummResponse.refs.qr_png; // Access the qr_png field under refs
                    print($"{qrUrl} was the provided qrURL!");
                    var msg = new SendQRCodeUrlMessage { qrCodeUrl = qrUrl };
                    conn.Send(msg);
                    Debug.LogError($"Sending payload from XUMM to {msg.qrCodeUrl} playfabAccount");
                    string payloadId = xummResponse.uuid; // Retrieve the payload ID from the xummResponse
                    print(payloadId + " is payload id!");
                    string expectedAmount = "100"; // The expected amount in your token
                    int pollingInterval = 10000; // Poll every 10 seconds
                    await MonitorTransactionStatusMARKET(payloadId, expectedAmount, pollingInterval, conn, tries, addressPUB, amountRequired);
                    //Stop here we need to reconfigure this so that it can get the proper stuff it needs for xrpl
                }
                else
                {
                    var errorContent = await response.Content.ReadAsStringAsync();
                    Debug.LogError("Error sending payload to XUMM: " + response.StatusCode);
                    Debug.LogError("Error Details: " + errorContent);
                    var msg = new XummMessage { code = "Error on payload, we will generate you a new QR code in just a few moments.", error = true };
                    conn.Send(msg);
                    await Task.Delay(5000);
                    print($"{tries} is our register tries amount, we had issue on making payload for xumm trying again");
                    PurchaseDKPMarketPriceRegistration(conn, playfabID, tries, addressPUB, amountRequired);
                }

            }
        }
         private async Task<XummDetailedResponse> GetFairMarketValueRegisterPrice(string amountRequired){
        using (var httpClient = new HttpClient())
    {
        // Replace with your Heroku app's check endpoint
        //var response = await httpClient.GetAsync($"{_Heroku_URL}/check-payload/{payloadId}");
        httpClient.DefaultRequestHeaders.Add("x-api-key", CONVO_KEY);
        var payload = new { amount = amountRequired };
        var json = JsonConvert.SerializeObject(payload);
        var data = new StringContent(json, Encoding.UTF8, "application/json");
        // Replace with your Heroku app's check endpoint
        var response = await httpClient.PostAsync($"{_Heroku_URL}/GetMarketPrice", data);
        //var response = await httpClient.GetAsync($"{_Heroku_URL}/GetMarketPrice");
        if (response.IsSuccessStatusCode)
        {
            print("Success on getting Heroku status code");
            var responseContent = await response.Content.ReadAsStringAsync();
            
            // Deserialize the response to XummDetailedResponse.
            // Make sure your Heroku app sends the response in this format.
            var xummDetailedResponse = JsonConvert.DeserializeObject<XummDetailedResponse>(responseContent);
            
            return xummDetailedResponse;
        }
        else
        {
            Debug.LogError("Error checking Heroku status: " + response.StatusCode);
            return null;
        }
    }
    }
        private async Task MonitorTransactionStatusMARKET(string payloadId, string expectedAmount, int pollingInterval, NetworkConnectionToClient conn, int registerTries, string addressPUB, string amountRequired){
            bool validatorNodeVerified = false;
            XummDetailedResponse savedResponse = null;
            string decodedID = string.Empty;
            while (true){
                if(!activeConnectionIds.Contains(conn.connectionId)){
                    print("connection was disconnected");
                    return;
                }
                print("Polling MonitorTransactionStatusMARKET");
                print(payloadId + " is payload id!");
                var xummstatus = await CheckXummStatusAPP(payloadId, addressPUB);
                if(xummstatus != null){
                    savedResponse = xummstatus;
                    if (xummstatus.meta.signed && !xummstatus.meta.submit && xummstatus.meta.resolved && !xummstatus.meta.TrustLineNotSet){
                        print("right before decodeID");
                        decodedID = DecryptString(xummstatus.custom_meta.blob);
                        print($"the player who requested to register had a playfab of {decodedID} and their public xrp wallet was {xummstatus.response.account}, {xummstatus.response.txid} was our txid");
                        //lets check xrpl now 
                        //so previously we were just sending after it was signed properly, but we need to verify this signing account has never been used before so how can we look through a wallets transactions to see if there are any from {xummstatus.response.account}?
                        print($"Polling rippleD here is the hex {xummstatus.response.hex}");
                        print("True paying customer lets get the the product!");
                        var msg = new XummMessage { code = "Trading XRP for DKP via the XRP Ledger's decentralized exchange one moment please", error = false };
                        conn.Send(msg);
                        var (xrplStatus, status) = await SubmitBlobToXRPL(xummstatus.response.hex);
                        if(xrplStatus){
                            break; // Exit the loop
                        }
                    } else {
                        if(!xummstatus.meta.signed && !xummstatus.meta.TrustLineNotSet){
                            var msg = new XummMessage { code = "The market purchase QR code was cancelled, trying again in a few moments." , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            PurchaseDKPMarketPriceRegistration(conn, decodedID, registerTries, addressPUB, amountRequired);
                            return;
                        }
                        if(!xummstatus.meta.signed && xummstatus.meta.TrustLineNotSet){
                            var msg = new XummMessage { code = "No trust line detected, sending a trust set QR code in a few moments" , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            RegisterTrustSet(conn, decodedID, registerTries, xummstatus.response.account);
                            //create trustline setter now
                            return;
                        }
                        if(xummstatus.meta.signed && xummstatus.meta.TrustLineNotSet){
                            var msg = new XummMessage { code = "No trust line detected, sending a trust set QR code in a few moments" , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            RegisterTrustSet(conn, decodedID, registerTries, xummstatus.response.account);
                            //create trustline setter now
                            return;
                        }
                        if(!xummstatus.meta.TrustLineNotSet && xummstatus.meta.expired){
                            var msg = new XummMessage { code = "The registration QR code has expired, trying again in a few seconds." , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            PurchaseDKPMarketPriceRegistration(conn, decodedID, registerTries, addressPUB, amountRequired);
                            return;
                        }
                         if(xummstatus.meta.TrustLineNotSet && xummstatus.meta.expired){
                            var msg = new XummMessage { code = "No trust line detected, sending a trust set QR code in a few moments" , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            RegisterTrustSet(conn, decodedID, registerTries, xummstatus.response.account);
                            //create trustline setter now
                            return;
                        }
                    }
                } else {
                    var msg = new XummMessage { code = "Checking status of our market buy for DKP" , error = true, pending = true };
                    conn.Send(msg);
                }
                await Task.Delay(pollingInterval);
            }
            print("Transaction was signed lets move on to looking for the validated payload");
            await Task.Delay(10000);
            int tries = 0;
            while(!validatorNodeVerified && savedResponse != null && tries < 3){
                tries ++;
                print($"Polling rippleD try # {tries}");
                var msg = new XummMessage { code = "Asking the XRP ledger to verify your registration", error = false };
                conn.Send(msg);
                var validated = await ValidateMARKETORDER(savedResponse.response.txid);
                if (validated){
                    // Success, credit the account
                    RegisterAccount(conn, decodedID, registerTries, addressPUB);
                    return;
                }
                await Task.Delay(pollingInterval);
            }
            PurchaseDKPMarketPriceRegistration(conn, decodedID, registerTries, addressPUB, amountRequired);
        }
        private ConcurrentDictionary<NetworkConnectionToClient, CancellationTokenSource> operations = new ConcurrentDictionary<NetworkConnectionToClient, CancellationTokenSource>();

        public void StartOperation(NetworkConnectionToClient connection, Func<CancellationTokenSource, Task> operation)
        {
            var cancellationTokenSource = new CancellationTokenSource();
            if (operations.TryAdd(connection, cancellationTokenSource))
            {
                Task.Run(() => operation(cancellationTokenSource));
            }
        }

        private async Task RunOperation(Func<CancellationToken, Task> operation, CancellationToken token)
        {
            try
            {
                await operation(token);
            }
            catch (TaskCanceledException)
            {
                // Handle cancellation
                Console.WriteLine("Operation was cancelled.");
            }
        }
        async void RegisterAccount(NetworkConnectionToClient conn, string playfabID, int tries, string pubAddress){
            print($"Tries: {tries} are how many times we have tried to register");
            if(conn == null){
                print("No connection found when trying to register account");
                return;
            }
            tries++;
            string id = EncryptString(playfabID);
            string xummIdentifier = Guid.NewGuid().ToString();
            // Prepare your payload object here.
            using (var httpClient = new HttpClient())
            {
                httpClient.DefaultRequestHeaders.Add("x-api-key", CONVO_KEY);

                var response = await httpClient.PostAsync($"{_Heroku_URL}/xummqueue?id={id}", null);  // No payload
                if (response.IsSuccessStatusCode)
                {
                    // Successfully joined the queue
                    print("queue is ready lets go!");
                }
                else
                {
                    // Log the failure or take other actions
                    Debug.LogError("Failed to join the queue, retrying...");
                    RegisterAccount(conn, playfabID, tries --, pubAddress);
                    return;
                    // Wait before the next retry
                }
            }

            //send these over to heroku
            var payload = new TransactionPayload
            {
                txjson = new TxJson
                {
                    TransactionType = "Payment",
                    Destination = _DKP_REGISTRAR_ADDRESS,
                    Amount = new Amount
                    {
                        currency = "DKP",
                        issuer = _DKP_ISSUER,
                        value = "100" // 50,000 DKP
                    }
                },
                options = new Options
                {
                    submit = false,
                    multisign = false,
                    expire = 5,
                    force_network = "MAINNET"
                },
                custom_meta = new CustomMeta
                {
                    identifier = xummIdentifier,
                    blob = id,
                    instruction = "Please proceed to authenticate the payment request to link your Xaman wallet with your DragonKill account 🐉. Warning, once you link this wallet it cannot be linked to another DragonKill account 🔒."
                }
            };
            string jsonPayload = JsonConvert.SerializeObject(payload);
            // Use the HttpClient to make a POST requestd
            using (var httpClient = new HttpClient())
            {
                httpClient.DefaultRequestHeaders.Add("x-api-key", _DKP_XAPP_FIRST);
                httpClient.DefaultRequestHeaders.Add("x-api-secret", _DKP_XAPP_SECOND);
                var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");
                var response = await httpClient.PostAsync("https://xumm.app/api/v1/platform/payload", content);
                // Check if the request was successful
                if (response.IsSuccessStatusCode)
                {
                    var responseContent = await response.Content.ReadAsStringAsync();
                    Debug.Log("Response Content: " + responseContent);
                    var xummResponse = JsonConvert.DeserializeObject<XummResponse>(responseContent);
                    string qrUrl = xummResponse.refs.qr_png; // Access the qr_png field under refs
                    print($"{qrUrl} was the provided qrURL!");
                    var msg = new SendQRCodeUrlMessage { qrCodeUrl = qrUrl };
                    conn.Send(msg);
                    Debug.LogError($"Sending payload from Xaman to {msg.qrCodeUrl} playfabAccount");
                    string payloadId = xummResponse.uuid; // Retrieve the payload ID from the xummResponse
                    print(payloadId + " is payload id!");
                    string expectedAmount = "100"; // The expected amount in your token
                    int pollingInterval = 10000; // Poll every 10 seconds
                        StartOperation(conn, token => MonitorTransactionStatus(payloadId, expectedAmount, pollingInterval, conn, tries, pubAddress, token));

                    //await MonitorTransactionStatus(payloadId, expectedAmount, pollingInterval, conn, tries, pubAddress);
                    //Stop here we need to reconfigure this so that it can get the proper stuff it needs for xrpl
                }
                else
                {
                    var errorContent = await response.Content.ReadAsStringAsync();
                    Debug.LogError("Error sending payload to Xaman: " + response.StatusCode);
                    Debug.LogError("Error Details: " + errorContent);
                    var msg = new XummMessage { code = "Error on payload, we will generate you a new QR code in just a few moments.", error = true };
                    conn.Send(msg);
                    await Task.Delay(5000);
                    print($"{tries} is our register tries amount, we had issue on making payload for Xaman trying again");
                    RegisterAccount(conn, playfabID, tries ++, pubAddress);
                }

            }
        }
        private async Task MonitorTransactionStatus(string payloadId, string expectedAmount, int pollingInterval, NetworkConnectionToClient conn, int registerTries, string pubAddress, CancellationTokenSource cancellationToken){
            bool validatorNodeVerified = false;
            XummDetailedResponse savedResponse = null;
            string decodedID = string.Empty;
            PlayerInfo playerinfo = (PlayerInfo)conn.authenticationData;
            try
            {
            while (true){

                if(!activeConnectionIds.Contains(conn.connectionId)){
                    print("connection was disconnected");
                    cancellationToken.Cancel();
                    return;
                }
                print("Polling MonitorTransactionStatus");
                print(payloadId + " is payload id!");
                if(pubAddress == null){
                    pubAddress = "Undefined";
                }
                var xummstatus = await CheckXummStatusAPP(payloadId, pubAddress);
                if(xummstatus != null){
                    savedResponse = xummstatus;
                    if(!string.IsNullOrEmpty(xummstatus.custom_meta.blob)){
                        decodedID = DecryptString(xummstatus.custom_meta.blob);
                    } else {
                        decodedID = playerinfo.PlayFabId;
                    }
                    if(string.IsNullOrEmpty(decodedID)){
                        print("no decode for some reason, we changed it out to make sure we are good to go");
                        decodedID = playerinfo.PlayFabId;
                    }
                    if (xummstatus.meta.signed && !xummstatus.meta.submit && xummstatus.meta.resolved && !xummstatus.meta.TrustLineNotSet && !xummstatus.meta.NotEnoughLiquidityButHasTrustLine){
                        print("right before decodeID");
                        decodedID = DecryptString(xummstatus.custom_meta.blob);
                        if(string.IsNullOrEmpty(decodedID)){
                            print("no decode for some reason, we changed it out to make sure we are good to go");
                            decodedID = playerinfo.PlayFabId;
                        }
                        print($"the player who requested to register had a playfab of {decodedID} and their public xrp wallet was {xummstatus.response.account}, {xummstatus.response.txid} was our txid");
                        //lets check xrpl now 
                        //so previously we were just sending after it was signed properly, but we need to verify this signing account has never been used before so how can we look through a wallets transactions to see if there are any from {xummstatus.response.account}?
                        print($"Polling rippleD here is the hex {xummstatus.response.hex}");
                        var checkPlayersWallet = await VerifyPlayerPayment(xummstatus.response.account);
                        if(checkPlayersWallet){
                            print("Warning Double registration!!");
                            //first echo warning, lets send them a new QR code? lets make it so there is a counter though they only get one chance after and then lock um out
                            var msg = new XummMessage { code = "The wallet you have tried to sign with has already been registered to another DragonKill account, please try another." , error = true };
                            conn.Send(msg);
                            await Task.Delay(5000);
                            //print($"{registerTries} is our register tries amount, running register on double registration");
                            //RegisterAccount(conn, decodedID, registerTries, pubAddress);
                            //cancellationToken.Cancel();
                            //return;
                        } else {
                            print("True paying customer lets get the the product!");
                            var msg = new XummMessage { code = "Registration request sent from XUMM to XRPL awaiting a validator node reponse", error = false };
                            conn.Send(msg);
                        }
                        var (xrplStatus, status) = await SubmitBlobToXRPL(xummstatus.response.hex);
                        if(xrplStatus){
                            break; // Exit the loop
                        }
                    } else {
                        if(!string.IsNullOrEmpty(xummstatus.response.account)){
                            pubAddress = xummstatus.response.account;
                            print($"{xummstatus.response.account} is our account address we are about to call something that isnt the accept");
                        }
                        if(xummstatus.meta.NotEnoughLiquidityButHasTrustLine){
                             var msg = new XummMessage { code = "Trust line set for DKP but not enough liquidity, fetching the market order to accomplish registration please double check" , error = true };
                            conn.Send(msg);
                            PurchaseDKPMarketPriceRegistration(conn, decodedID, registerTries, pubAddress, xummstatus.meta.RequiredAmount);
                            cancellationToken.Cancel();
                            return;
                        }
                        
                        if(!xummstatus.meta.signed && !xummstatus.meta.TrustLineNotSet && !xummstatus.meta.NoAddressSendBackToMain){
                            var msg = new XummMessage { code = "No trust line detected, sending a trust set QR code in a few moments" , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            RegisterTrustSet(conn, decodedID, registerTries --, pubAddress);
                            print("DETECTED NO TRUSTLINE!! STARTING REGISTER TRUST SET");
                            cancellationToken.Cancel();
                            return;
                        }
                        if(!xummstatus.meta.signed && !xummstatus.meta.TrustLineNotSet && xummstatus.meta.NoAddressSendBackToMain){
                            var msg = new XummMessage { code = "The registration QR code was cancelled, trying again in a few moments." , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            RegisterAccount(conn, decodedID, registerTries, pubAddress);
                            cancellationToken.Cancel();
                            return;
                        }
                        if(xummstatus.meta.signed && xummstatus.meta.TrustLineNotSet){
                            var msg = new XummMessage { code = "No trust line detected, sending a trust set QR code in a few moments" , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            RegisterTrustSet(conn, decodedID, registerTries --, pubAddress);
                            print("DETECTED NO TRUSTLINE!! STARTING REGISTER TRUST SET");
                            cancellationToken.Cancel();
                            return;
                        }
                        if(!xummstatus.meta.signed && xummstatus.meta.TrustLineNotSet){
                            var msg = new XummMessage { code = "No trust line detected, sending a trust set QR code in a few moments" , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            RegisterTrustSet(conn, decodedID, registerTries --, pubAddress);
                            print("DETECTED NO TRUSTLINE!! STARTING REGISTER TRUST SET");
                            //create trustline setter now
                            cancellationToken.Cancel();
                            return;
                        }
                        if(xummstatus.meta.expired && !xummstatus.meta.TrustLineNotSet){
                            var msg = new XummMessage { code = "The registration QR code has expired, trying again in a few seconds." , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            RegisterAccount(conn, decodedID, registerTries, pubAddress);
                            cancellationToken.Cancel();
                            return;
                        }
                        if(xummstatus.meta.expired && xummstatus.meta.TrustLineNotSet){
                            var msg = new XummMessage { code = "The registration QR code has expired, trying again in a few seconds." , error = true };
                            conn.Send(msg);
                            await Task.Delay(10000);
                            RegisterTrustSet(conn, decodedID, registerTries --, pubAddress);
                            print("DETECTED NO TRUSTLINE!! STARTING REGISTER TRUST SET");
                            cancellationToken.Cancel();
                            return;
                        }
                        
                    }
                } else {
                    var msg = new XummMessage { code = "Checking status one moment please" , error = true, pending = true };
                    conn.Send(msg);
                }
                await Task.Delay(pollingInterval, cancellationToken.Token);
            }
            print("Transaction was signed lets move on to looking for the validated payload");
            //await Task.Delay(10000);
            await Task.Delay(5000);
            int tries = 0;
            print("validatorNodeVerified && savedResponse != null && tries");
            while(!validatorNodeVerified && savedResponse != null && tries < 3){
                tries ++;
                print($"Polling rippleD try # {tries}");
                var msg = new XummMessage { code = "Asking the XRP ledger to verify your registration", error = false };
                conn.Send(msg);
                    print("RIGHT BEFORE VALIDATE");
            
                var (validated, validatedAmount) = await ValidateXrplTransaction(savedResponse.response.txid);
                if (validated && validatedAmount == expectedAmount){
                    // Success, credit the account
                    print($"paid {validatedAmount} amount");
                    Dictionary<string, string> newPlayerData = new Dictionary<string, string>();
                    print("marker 1");
                    if(pubAddress == "Undefined"){
                        newPlayerData.Add("PUBLICADDRESS", savedResponse.response.account);
                    print("marker 2");

                    } else {
                        newPlayerData.Add("PUBLICADDRESS", pubAddress);
                    print("marker 2.5");

                    }
                    print("marker 3");

                    PlayFabServerAPI.UpdateUserData(new UpdateUserDataRequest
                    {
                        PlayFabId = decodedID,
                        Data = newPlayerData
                    }, result =>
                    {
                    print("marker 4");

                    print("marker 5");

                        if(pubAddress == "Undefined"){
                            playerinfo.XRPLPUBLIC = savedResponse.response.account;
                    print("marker 6");
                        } else {
                            playerinfo.XRPLPUBLIC = pubAddress;
                    print("marker 6.5");
                        }
                        conn.authenticationData = playerinfo;
                        //print($"Successfully registered XUMM account {savedResponse.response.account} to playfab account {decodedID}");
                    print("marker 7");
                        var msg = new XummMessage { code = "Registration tx successfully validated on the XRP Ledger. Welcome to DragonKill!", error = false };
                        ScenePlayer p = conn.identity.gameObject.GetComponent<ScenePlayer>();
                        StartCoroutine(WalletCheckCoroutine(savedResponse.response.account, (DKP, XRP) =>
                        {
                            print($"DKP: {DKP}, XRP: {XRP}");
                            // Use DKP and XRP here as needed
                            // Continue processing
                            p.ServerUpdateWallet(savedResponse.response.account, DKP, XRP);
                            cancellationToken.Cancel();

                        }));
                        //if(pubAddress == "Undefined"){
                        //    print("marker 8");
                        //    conn.Send(msg);
                        //    conn.Send<Noob>(new Noob {
                        //    finished = false,
                        //    Address = savedResponse.response.account
                        //});
                        //} else {
                        //    print("marker 8.5");
                        //    conn.Send(msg);
                        //    conn.Send<Noob>(new Noob {
                        //    finished = false,
                        //    Address = pubAddress
                        //});
                        //}
                        //conn.Send(msg);
                        //conn.Send<Noob>(new Noob {
                        //    finished = false,
                        //    Address = savedResponse.response.account
                        //});
                    }, error => {
                    
                    });
                    return; // Exit the loop
                }
                else
                {
                    // Handle partial payment
                    print($"unpaid because {validatedAmount} was amount");
                     print($"{registerTries} is our register tries amount, running register on cancel payload");
                }
                 CancellationToken token = cancellationToken.Token;

                // Check for cancellation before proceeding
                token.ThrowIfCancellationRequested();
                //await Task.Delay(pollingInterval);

                await Task.Delay(pollingInterval, token);
            }
            }
            catch (OperationCanceledException)
            {
                print("Monitoring operation was canceled."); // Handle the cancellation
                // Any cleanup if necessary
            }
            catch (Exception ex)
            {
                print($"An error occurred: {ex.Message}"); // Handle other exceptions
            }
            //print("RegisterAccount final road was casted not looking good!!!!!!!!!!!!!!!!!!!!!!!!!");

            //RegisterAccount(conn, decodedID, registerTries, pubAddress);

        }
        IEnumerator WalletCheckCoroutine(string ledgerAddress, Action<string, string> onCompleted)
{
    string DKP = "Not Available";
    string XRP = "Not Available";
    UnityWebRequest www = UnityWebRequest.Get(xrpscanAPI + ledgerAddress + "/balances");
    yield return www.SendWebRequest();
    if (www.result != UnityWebRequest.Result.Success)
    {
        Debug.Log(www.error);
    }
    else
    {
        string jsonResponse = www.downloadHandler.text;
        CurrencyBase[] currencies = JsonHelper.FromJson<CurrencyBase>(jsonResponse);
        foreach (var currency in currencies)
        {
            if (currency.currency == "DKP")
            {
                DKP = currency.value;
                Debug.Log($"Currency: {currency.currency}, Value: {currency.value}");
            }
            if (currency.currency == "XRP")
            {
                XRP = currency.value;
                Debug.Log($"Currency: {currency.currency}, Value: {currency.value}");
            }
        }
    }
    onCompleted(DKP, XRP); // Callback with the results
}
        private async Task<(bool, string)> SubmitBlobToXRPL(string transactionBlob){
        using (var httpClient = new HttpClient())
        {
            var postData = new
            {
                method = "submit",
                @params = new object[]
                {
                    new
                    {
                        tx_blob = transactionBlob
                    }
                }
            };
            var jsonString = JsonConvert.SerializeObject(postData);
            var httpContent = new StringContent(jsonString, Encoding.UTF8, "application/json");
            var response = await httpClient.PostAsync("https://s1.ripple.com:51234/", httpContent); // Adjust the endpoint URL accordingly
            if (response.IsSuccessStatusCode){
                // Successfully submitted to XRPL
                var responseContent = await response.Content.ReadAsStringAsync();
                print("Success on submitting to xrpl!");
                // Further logic
                return (true, "PASS");;
            } else {
                // Handle error
                Debug.LogError("Error submitting transaction blob to XRPL: " + response.StatusCode);
                return (false, "Xrpl error");
            }
        }
    }
    private async Task<bool> ValidateTrustlineTransaction(string transactionId)
{
    using (var httpClient = new HttpClient())
    {
        var requestPayload = new
        {
            method = "tx",
            @params = new[]
            {
                new
                {
                    transaction = transactionId,
                    binary = false
                }
            }
        };

        var jsonRequest = Newtonsoft.Json.JsonConvert.SerializeObject(requestPayload);
        var content = new StringContent(jsonRequest, Encoding.UTF8, "application/json");
        var response = await httpClient.PostAsync("https://s1.ripple.com:51234/", content);
        if (response.IsSuccessStatusCode)
        {
            var responseContent = await response.Content.ReadAsStringAsync();
            var xrplTransactionResponse = JsonConvert.DeserializeObject<XrplTransactionResponse>(responseContent);

            if (xrplTransactionResponse.result.status == "success" &&
                xrplTransactionResponse.result.validated &&
                xrplTransactionResponse.result.TransactionType == "TrustSet" &&
                xrplTransactionResponse.result.LimitAmount != null && // Additional check for LimitAmount or other trustline specific fields
                xrplTransactionResponse.result.LimitAmount.currency == "DKP" && // Ensure the currency is as expected
                xrplTransactionResponse.result.LimitAmount.issuer == _DKP_ISSUER) // Ensure the issuer is as expected
            {
                return true;
            }
            else
            {
                Debug.LogError("Trustline is not validated or was not successful.");
            }
        }
        else
        {
            Debug.LogError("Error validating XRPL Trustline: " + response.StatusCode);
        }
    }

    return false;
}
    private async Task<(bool, string)> ValidateXrplTransaction(string transactionId){
        using (var httpClient = new HttpClient()){
            var requestPayload = new
            {
                method = "tx",
                @params = new[]
                {
                    new
                    {
                        transaction = transactionId,
                        binary = false
                    }
                }
            };

            var jsonRequest = Newtonsoft.Json.JsonConvert.SerializeObject(requestPayload);
            var content = new StringContent(jsonRequest, Encoding.UTF8, "application/json");
            var response = await httpClient.PostAsync("https://s1.ripple.com:51234/", content);
            if (response.IsSuccessStatusCode){
                var responseContent = await response.Content.ReadAsStringAsync();
                print($"GOT OUR VALIDATED XRPL TRANSACTION!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                var xrplTransactionResponse = JsonConvert.DeserializeObject<XrplTransactionResponse>(responseContent);
                print($"CONVERTED JSON TO XRPL TRANSACTION");

                if (xrplTransactionResponse.result.status == "success" && xrplTransactionResponse.result.validated && xrplTransactionResponse.result.meta.TransactionResult == "tesSUCCESS")            {
                    print($"CONVERTED JSON TO XRPL TRANSACTION");
                    return (true, xrplTransactionResponse.result.meta.delivered_amount.value);
                } else {
                    Debug.LogError("Transaction is not validated or was not successful.");
                }
            } else {
                Debug.LogError("Error validating XRPL transaction: " + response.StatusCode);
            }
        }
        return (false, "Transaction failed or could not be validated.");
    }
    private async Task <bool> ValidateMARKETORDER(string transactionId){
        using (var httpClient = new HttpClient()){
            var requestPayload = new
            {
                method = "tx",
                @params = new[]
                {
                    new
                    {
                        transaction = transactionId,
                        binary = false
                    }
                }
            };

            var jsonRequest = Newtonsoft.Json.JsonConvert.SerializeObject(requestPayload);
            var content = new StringContent(jsonRequest, Encoding.UTF8, "application/json");
            var response = await httpClient.PostAsync("https://s1.ripple.com:51234/", content);
            if (response.IsSuccessStatusCode){
                var responseContent = await response.Content.ReadAsStringAsync();
                print($"GOT OUR VALIDATED XRPL TRANSACTION!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
                var xrplTransactionResponse = JsonConvert.DeserializeObject<XrplTransactionResponse>(responseContent);
                print($"CONVERTED JSON TO XRPL TRANSACTION");

                if (xrplTransactionResponse.result.status == "success" && xrplTransactionResponse.result.validated && xrplTransactionResponse.result.meta.TransactionResult == "tesSUCCESS")            {
                    print($"CONVERTED JSON TO XRPL TRANSACTION");
                    return true;
                } else {
                    Debug.LogError("Transaction is not validated or was not successful.");
                }
            } else {
                Debug.LogError("Error validating XRPL transaction: " + response.StatusCode);
            }
        }
        return false;
    }
    private async Task<string> CheckXummStatus(string payloadId){
        using (var httpClient = new HttpClient()){
            // Adding headers
            httpClient.DefaultRequestHeaders.Add("x-api-key", _DKP_XAPP_FIRST);
            httpClient.DefaultRequestHeaders.Add("x-api-secret", _DKP_XAPP_SECOND);
            var response = await httpClient.GetAsync($"https://xumm.app/api/v1/platform/payload/{payloadId}");
            if (response.IsSuccessStatusCode){
                var responseContent = await response.Content.ReadAsStringAsync();
                var xummStatusResponse = JsonConvert.DeserializeObject<XummStatusResponse>(responseContent);
                return xummStatusResponse.status;
            } else {
                Debug.LogError("Error checking XUMM status: " + response.StatusCode);
                return null;
            }
        }
    }
    private async Task<XummDetailedResponse> CheckXummStatusFull(string payloadId){
        using (var httpClient = new HttpClient()){
            // Add headers here as before...
            httpClient.DefaultRequestHeaders.Add("x-api-key", _DKP_XAPP_FIRST);
            httpClient.DefaultRequestHeaders.Add("x-api-secret", _DKP_XAPP_SECOND);
            var response = await httpClient.GetAsync($"https://xumm.app/api/v1/platform/payload/{payloadId}");
            if (response.IsSuccessStatusCode){
                // Read rate limit headers
                if (response.Headers.TryGetValues("X-RateLimit-Limit", out var rateLimitLimit)){
                    print($"Rate Limit (Max allowed): {string.Join(", ", rateLimitLimit)}");
                }
                if (response.Headers.TryGetValues("X-RateLimit-Remaining", out var rateLimitRemaining)){
                    print($"Rate Limit (Remaining): {string.Join(", ", rateLimitRemaining)}");
                }
                if (response.Headers.TryGetValues("X-RateLimit-Reset", out var rateLimitReset)){
                    print($"Rate Limit (Reset time): {string.Join(", ", rateLimitReset)}");
                }
                print("Success on getting Xumm statuscode");
                var responseContent = await response.Content.ReadAsStringAsync();
                var xummDetailedResponse = JsonConvert.DeserializeObject<XummDetailedResponse>(responseContent);
                return xummDetailedResponse;
            } else {
                Debug.LogError("Error checking XUMM status: " + response.StatusCode);
                return null;
            }
        }
    }
    private async Task<XummDetailedResponse> CheckXummStatusAPP(string payloadId, string address){
        using (var httpClient = new HttpClient())
    {
        // Replace with your Heroku app's check endpoint
        //var response = await httpClient.GetAsync($"{_Heroku_URL}/check-payload/{payloadId}");
        httpClient.DefaultRequestHeaders.Add("x-api-key", CONVO_KEY);
        var response = await httpClient.GetAsync($"{_Heroku_URL}/check-payload/{payloadId}/{address}");
        if (response.IsSuccessStatusCode)
        {
            print("Success on getting Heroku status code");
            var responseContent = await response.Content.ReadAsStringAsync();
            
            // Deserialize the response to XummDetailedResponse.
            // Make sure your Heroku app sends the response in this format.
            var xummDetailedResponse = JsonConvert.DeserializeObject<XummDetailedResponse>(responseContent);
            
            return xummDetailedResponse;
        }
        else
        {
            Debug.LogError("Error checking Heroku status: " + response.StatusCode);
            return null;
        }
    }
    }
    async void DKPTOGOLDTRANSMUTE(NetworkConnectionToClient conn, string playfabID, string amount){
            if(conn == null){
                print("No connection found when trying to transmute");
                return;
            }
            ScenePlayer p = conn.identity.gameObject.GetComponent<ScenePlayer>();

            string publicAddress = p.GetTacticianSheet().Address;
            if(float.Parse(p.GetTacticianSheet().DKPBalance) < float.Parse(amount)){
                var _message = new XummTransmute { code = "20", error = true };
                conn.Send(_message);
                return;
            }
            //string url = $"https://data.ripple.com/v2/accounts/{publicAddress}/trustlines";
            //using (var httpClient = new HttpClient())
            //{
            //    var trustlineResponse = await httpClient.GetAsync(url);
            //    if (trustlineResponse.IsSuccessStatusCode)
            //    {
            //        var jsonResponse = await trustlineResponse.Content.ReadAsStringAsync();
            //        Debug.Log("Received JSON: " + jsonResponse);
                    //XRPLTrustlineResponse trustlineData = JsonUtility.FromJson<XRPLTrustlineResponse>(jsonResponse);
//
                    //bool hasDKPTrustline = false;
                    //foreach (Trustline t in trustlineData.trustlines)
                    //{
                    //    if (t.currency == "DKP" && t.issuer == _DKP_ISSUER)
                    //    {
                    //        hasDKPTrustline = true;
                    //        break;
                    //    }
                    //}

                    //if (!hasDKPTrustline)
                    //{
                    //    Debug.LogError("No DKP trustline found for this account.");
                    //    // Send error message to client or take other actions
                    //    return;
                    //}
         //       }
         //       else
         //       {
         //           Debug.LogError("Failed to fetch trustlines.");
         //           // Handle error
         //           return;
         //       }
         //   }
            string id = EncryptString(playfabID);
            string xummIdentifier = Guid.NewGuid().ToString();
            // Prepare your payload object here.
            int httpTries = 0;

            while(true && httpTries < 5){
                httpTries ++;
                using (var httpClient = new HttpClient())
                {
                    httpClient.DefaultRequestHeaders.Add("x-api-key", CONVO_KEY);

                    var response = await httpClient.PostAsync($"{_Heroku_URL}/xummqueue?id={id}", null);  // No payload

                    if (response.IsSuccessStatusCode)
                    {
                        // Successfully joined the queue
                        print("queue is ready lets go!");
                        break;
                    }
                    else
                    {
                        // Log the failure or take other actions
                        Debug.LogError("Failed to join the queue, retrying...");
                        await Task.Delay(10000);
                    }
                }
            }
            if(httpTries == 5){
                DKPTOGOLDTRANSMUTE(conn, playfabID, amount);
                return;
            }
            var payload = new TransactionPayload
            {
                txjson = new TxJson
                {
                    TransactionType = "Payment",
                    Destination = _TransmuteDKPKey,
                    Amount = new Amount
                    {
                        currency = "DKP",
                        issuer = _DKP_ISSUER,
                        value = amount
                    }
                },
                options = new Options
                {
                    submit = false,
                    multisign = false,
                    expire = 5,
                    force_network = "MAINNET"
                },
                custom_meta = new CustomMeta
                {
                    identifier = xummIdentifier,
                    blob = id,
                    instruction = $"Transmuting {amount} DKP to Gold. Gold will appear in your DragonKill account 🐉."
                }
            };
            string jsonPayload = JsonConvert.SerializeObject(payload);
            // Use the HttpClient to make a POST request
            using (var httpClient = new HttpClient())
            {
                httpClient.DefaultRequestHeaders.Add("x-api-key", _DKP_XAPP_FIRST);
                httpClient.DefaultRequestHeaders.Add("x-api-secret", _DKP_XAPP_SECOND);
                var content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");
                var response = await httpClient.PostAsync("https://xumm.app/api/v1/platform/payload", content);
                // Check if the request was successful
                if (response.IsSuccessStatusCode)
                {
                    var responseContent = await response.Content.ReadAsStringAsync();
                    Debug.Log("Response Content: " + responseContent);
                    var xummResponse = JsonConvert.DeserializeObject<XummResponse>(responseContent);
                    string qrUrl = xummResponse.refs.qr_png; // Access the qr_png field under refs
                    print($"{qrUrl} was the provided qrURL!");
                    var msg = new XummTransmute { qrCodeUrl = qrUrl, error = false };
                    conn.Send(msg);
                    Debug.LogError($"Sending payload from XUMM to {msg.qrCodeUrl} playfabAccount");
                    string payloadId = xummResponse.uuid; // Retrieve the payload ID from the xummResponse
                    int pollingInterval = 10000; // Poll every 10 seconds
                    await MonitorXUMMTRANSMUTEStatus(payloadId, amount, pollingInterval, conn);
                    //Stop here we need to reconfigure this so that it can get the proper stuff it needs for xrpl
                }
                else
                {
                    var errorContent = await response.Content.ReadAsStringAsync();
                    Debug.LogError("Error sending payload to XUMM: " + response.StatusCode);
                    Debug.LogError("Error Details: " + errorContent);
                    //var msg = new XummMessage { code = "Error on payload, we will generate you a new QR code in just a few moments.", error = true };
                    //conn.Send(msg);
                    await Task.Delay(10000);
                }

            }
        }
        private async Task MonitorXUMMTRANSMUTEStatus(string payloadId, string expectedAmount, int pollingInterval, NetworkConnectionToClient conn){
            ScenePlayer p = conn.identity.gameObject.GetComponent<ScenePlayer>();
            bool validatorNodeVerified = false;
            XummDetailedResponse savedResponse = null;
            string decodedID = string.Empty;
            while (true){
                if(!activeConnectionIds.Contains(conn.connectionId)){
                    print("connection was disconnected");
                    return;
                }
                print("Polling XUMM");
                var xummstatus = await CheckXummStatusAPP(payloadId, p.GetTacticianSheet().Address);
                if(xummstatus != null){
                    savedResponse = xummstatus;
                    if (xummstatus.meta.signed && !xummstatus.meta.submit && xummstatus.meta.resolved){
                        print("right before decodeID");
                        decodedID = DecryptString(xummstatus.custom_meta.blob);
                        print($"the player who requested to register had a playfab of {decodedID} and their public xrp wallet was {xummstatus.response.account}, {xummstatus.response.txid} was our txid");
                        //lets check xrpl now 
                        //so previously we were just sending after it was signed properly, but we need to verify this signing account has never been used before so how can we look through a wallets transactions to see if there are any from {xummstatus.response.account}?
                        print($"Polling rippleD here is the hex {xummstatus.response.hex}");
                        var (xrplStatus, status) = await SubmitBlobToXRPL(xummstatus.response.hex);
                        if(xrplStatus){
                            break; // Exit the loop
                        }
                    }
                    if(xummstatus.meta.wrongSigner){
                        var _message = new XummTransmute { code = "15", error = true };
                        conn.Send(_message);
                        if (!(conn.authenticationData is PlayerInfo playerData)) {
                            Debug.LogWarning("Authentication data is missing or not of type PlayerInfo.");
                            return;
                        }
                        DKPTOGOLDTRANSMUTE(conn, playerData.PlayFabId, expectedAmount);
                        return;
                    }
                    if(xummstatus.meta.TrustLineNotSet){
                        var _message = new XummTransmute { code = "25", error = true };
                        conn.Send(_message);
                        if (!(conn.authenticationData is PlayerInfo playerData)) {
                            Debug.LogWarning("Authentication data is missing or not of type PlayerInfo.");
                            return;
                        }
                        ReassignTrustSet(conn, playerData.PlayFabId, 0, expectedAmount);
                        return;
                    } 
                }
                await Task.Delay(pollingInterval);
            }
            print("Transaction was signed lets move on to looking for the validated payload");
            await Task.Delay(10000);
            int tries = 0;
            while(!validatorNodeVerified && savedResponse != null && tries < 3){
                tries ++;
                print($"Polling rippleD try # {tries}");
                var msg = new XummTransmute { code = "4", error = false };
                conn.Send(msg);
                var (validated, validatedAmount) = await ValidateXrplTransaction(savedResponse.response.txid);
                if (validated && validatedAmount == expectedAmount){
                    // Success, credit the account
                    print($"Successfully paid with XUMM account {savedResponse.response.account} to playfab account {decodedID}");
                    var _msg = new XummTransmute { code = "5", error = false };
                    conn.Send(_msg);
                    p.Gold += long.Parse(validatedAmount);
                    //long dkpBalance = long.Parse(p.GetTacticianSheet().DKPBalance);
                    //dkpBalance -= long.Parse(validatedAmount);
                    float dkpBalanceFloat = float.Parse(p.GetTacticianSheet().DKPBalance) - float.Parse(validatedAmount);
                    //p.ServerSendDKPCD(p.GetTacticianSheet().DKPCooldown, p.GetTacticianSheet().XRPBalance, dkpBalance.ToString());
                    //p.TargetWalletAwake();
                    StartCoroutine(NewGoldAmountTRANSMUTE(p, dkpBalanceFloat));
                    return; // Exit the loop
                }
                else
                {
                    // Handle partial payment
                    print($"unpaid because {validatedAmount} was amount");
                }
                await Task.Delay(pollingInterval);
            }
            var _Msg = new XummTransmute { code = "6", error = true };
            conn.Send(_Msg);
        }
        IEnumerator NewGoldAmountTRANSMUTE(ScenePlayer p, float dkpBalance){
            yield return new WaitForSeconds(.5f);
            p.ServerSendDKPCD(p.GetTacticianSheet().DKPCooldown, p.GetTacticianSheet().XRPBalance, dkpBalance.ToString("F2"));
            //p.TargetWalletAwake();
        }
    private async Task<bool> SignedXRPLBlobSubmission(string transactionBlob){
        using (var httpClient = new HttpClient())
        {
            var postData = new
            {
                method = "submit",
                @params = new object[]
                {
                    new
                    {
                        tx_blob = transactionBlob
                    }
                }
            };
            var jsonString = JsonConvert.SerializeObject(postData);
            var httpContent = new StringContent(jsonString, Encoding.UTF8, "application/json");
            var response = await httpClient.PostAsync("https://s1.ripple.com:51234/", httpContent); // Adjust the endpoint URL accordingly
            if (response.IsSuccessStatusCode){
                // Successfully submitted to XRPL
                var responseContent = await response.Content.ReadAsStringAsync();
                print("Success on submitting to xrpl!");
                // Further logic
                return true;
            } else {
                // Handle error
                Debug.LogError("Error submitting transaction blob to XRPL: " + response.StatusCode);
                return false;
            }
        }
    }
        #endif
    public override void Awake(){
        LoadNetworkPrefabs();
        base.Awake();
        instance = this;   
    }
    private void LoadNetworkPrefabs(){
        // Clear the list to not have duplicates
        // Load all prefabs in the 'Resources/Prefabs/Monsters' directory
        //prefabs = Resources.LoadAll<GameObject>("Prefabs/Monsters");
        prefabs.AddRange(Resources.LoadAll<GameObject>("Prefabs/Monsters"));
        prefabs.AddRange(Resources.LoadAll<GameObject>("Prefabs/Droppables"));
        foreach (GameObject prefab in prefabs){
            if (prefab.GetComponent<NetworkIdentity>() != null){
                spawnPrefabs.Add(prefab);
            } else {
                Debug.LogWarning($"{prefab.name} does not have a NetworkIdentity and was not added to the list of spawnable prefabs.");
            }
        }
    }
            ConsumableEffects consumableEffects = new ConsumableEffects();

        #if UNITY_SERVER //|| UNITY_EDITOR

        public override void Start()
        {
            StartPlayFabAPI();
            this.StartServer();
        }
        public override void OnStartServer()
        {
            NetworkServer.RegisterHandler<NoobToPlayer>(CreatePlayerProcess);
            NetworkServer.RegisterHandler<ClientRequestLoadScene>(GetCleanedSceneName);
            NetworkServer.RegisterHandler<Noob>(NoobPlayer);
            NetworkServer.RegisterHandler<PlayerInfo>(OnReceivePlayerInfo);
            NetworkServer.RegisterHandler<XummTransmute>(OnDKPTransmuteRequest);
            NetworkServer.RegisterHandler<XRPLTransmute>(OnGOLDTransmuteRequest);
            AzureLoaded = false;
            FetchPlayFabIngredients();
            StartCoroutine(LoadSubScenes());
            StartCoroutine(WaitFiveSeconds());
            base.OnStartServer();
        }
        public void FetchPlayFabIngredients() {

            var request = new GetTitleDataRequest { Keys = null }; // Fetch all, or specify which keys you want
            PlayFabServerAPI.GetTitleInternalData(request, OnDataReceivedStartTask, OnError);
        }
        public void SetPlayFabTitleData(string key, string value)
        {
            var request = new SetTitleDataRequest
            {
                Key = key,
                Value = value
            };

            PlayFabServerAPI.SetTitleData(request, OnSetTitleDataSuccess, OnError);
        }

        private void OnSetTitleDataSuccess(SetTitleDataResult result)
        {
            Debug.Log("Title data set successfully");
        }
        #endif
        private long counter = 0;
         string BuildID;
        string SessionID;
        string Port;
        string PlayfabURL;
        #if UNITY_SERVER //|| UNITY_EDITOR
        void OnDataReceivedStartTask(GetTitleDataResult result){
            salt = result.Data["salt"];
            sharedSecret = result.Data["sharedSecret"];
           // _DKP_DESTINATION_ADDRESS = result.Data["RegisterCollectionsKey"];
            _DKP_XAPP_FIRST = result.Data["XappPublicKey"];
            _DKP_XAPP_SECOND = result.Data["XappPrivateKey"];
            _GAME_WALLET_ADDRESS = result.Data["GameWalletPublicKey"];
            //_GOLD_WALLET_ADDRESS = result.Data["GoldPublicKey"];
            //_GOLD_WALLET_SIGN = result.Data["GoldPrivateKey"];
            _Heroku_URL = result.Data["HerokuURL"];
            CONVO_KEY = result.Data["CONVO_KEY"];
            _TransmuteDKPKey = result.Data["TransmuteKey"];
            _DKP_REGISTRAR_ADDRESS = result.Data["RegisterCollectionsKey"];
            if(!Local){
                BuildID = System.Environment.GetEnvironmentVariable("PF_BUILD_ID");
                SessionID = System.Guid.NewGuid().ToString();
                System.Environment.SetEnvironmentVariable("PF_SESSION_ID", SessionID);
                //Port = System.Environment.GetEnvironmentVariable("PF_SERVER_PORT"); // Get the server port
                //string ipAddress = System.Environment.GetEnvironmentVariable("PF_SERVER_IP"); // Add this line to get the IP address
                //string _sessionId = System.Environment.GetEnvironmentVariable("PF_SESSION_ID");
                print($"{BuildID} is our servers build ID and the session ID is {SessionID}");
                //PlayfabURL = this.networkAddress; // Get the server URL from response
                print($"its session id is {SessionID}************************************");
                // Additional server details can be processed here
                // Now send these details to your Heroku server
                //HerokuHeartBeat = StartCoroutine(RegisterServerToHeroku());
                WebSocketBuild();

            }
        }
        
        Coroutine HerokuHeartBeat;
        IEnumerator RegisterServerToHeroku(){
            WWWForm form = new WWWForm();
            form.AddField("buildID", BuildID);
            form.AddField("sessionID", SessionID);
            form.AddField("version", Version);
            using (UnityWebRequest www = UnityWebRequest.Post(_Heroku_URL + "/registerServer", form))
            {
                www.SetRequestHeader("x-api-key", CONVO_KEY);
                yield return www.SendWebRequest();
                if (www.result == UnityWebRequest.Result.ConnectionError || www.result == UnityWebRequest.Result.ProtocolError)
                {
                    Debug.LogError($"Error Register game server To Heroku server: {www.error}");
                }
                else
                {
                    print($"Our server on build {BuildID}, version {Version} and session {SessionID} is regsitered!");
                    //ResponseObj response = JsonUtility.FromJson<ResponseObj>(www.downloadHandler.text);
                    //Debug.Log("Received JSON: " + www.downloadHandler.text);
                    ////print($"{response.success} was our success bool, {response.message} was our message and {response.details.userId} was our User ID, {response.details.goldAmount} was amount and {response.details.walletAddress} is our address");
                    //var jsonNode = JSON.Parse(www.downloadHandler.text);
                }
            }
            yield return new WaitForSeconds(10f);
            while(true){
                StartCoroutine(SendPingToHeroku());
                yield return new WaitForSeconds(300f);
            }
        }
        string IPaddress = string.Empty;
        string playfabPort = string.Empty;
        IEnumerator SendPingToHeroku() {
            print("Sending ping to heroku");
            string playerLength = playerConnections.Count.ToString();
            string IPaddress_Transfer = "BlankIPAddress";
            string Port_Transfer = "BlankPort";
            if(!string.IsNullOrEmpty(IPaddress)){
                IPaddress_Transfer = IPaddress;
            }
            if(!string.IsNullOrEmpty(playfabPort)){
                Port_Transfer = playfabPort;
            }
            WWWForm form = new WWWForm();
            form.AddField("buildID", BuildID);
            form.AddField("sessionID", SessionID);
            form.AddField("serverPlayers", playerLength);
            form.AddField("ipAddress", IPaddress_Transfer);
            form.AddField("port", Port_Transfer);
            form.AddField("version", Version);
            using (UnityWebRequest www = UnityWebRequest.Post(_Heroku_URL + "/pingServer", form)) {
                www.SetRequestHeader("x-api-key", CONVO_KEY);

                yield return www.SendWebRequest();
                if (www.result == UnityWebRequest.Result.ConnectionError || www.result == UnityWebRequest.Result.ProtocolError) {
                    Debug.LogError($"Error pinging server: {www.error}");
                } else {
                    Debug.Log("Ping successful");
                    string content = www.downloadHandler.text;
                    LoginRequestResponse loginResponse = JsonConvert.DeserializeObject<LoginRequestResponse>(content);
                    string port = loginResponse.meta.portString;
                    string injectedIPAddress = loginResponse.meta.mirroredIPAddress;
                    if(!string.IsNullOrEmpty(port)){
                        if(port != "Empty"){
                            playfabPort = port;
                        }
                    }
                    if(!string.IsNullOrEmpty(injectedIPAddress)){
                        if(injectedIPAddress != "Empty"){
                            IPaddress = injectedIPAddress;
                        }
                    }
                    // Use the values from the response
                    //buildID = loginResponse.meta.buildConnectID;
                    //SessionID = loginResponse.meta.sessionConnectID;
                    //add the ip if returned with one
                }
            }
        }
        IEnumerator SendKamahlBreakingPoint() {
            print("Sending ping to heroku");
            WWWForm form = new WWWForm();
            form.AddField("sessionID", SessionID);
            using (UnityWebRequest www = UnityWebRequest.Post(_Heroku_URL + "/breakingPoint", form)) {
                www.SetRequestHeader("x-api-key", CONVO_KEY);

                yield return www.SendWebRequest();
                if (www.result == UnityWebRequest.Result.ConnectionError || www.result == UnityWebRequest.Result.ProtocolError) {
                    Debug.LogError($"Error pinging server: {www.error}");
                } else {
                    Debug.Log("Ping successful");
                }
            }
        }
        #endif
        #if UNITY_SERVER //|| UNITY_EDITOR
        private void OnError(PlayFabError error) {
            Debug.LogError("Could not retrieve Title Data: " + error.GenerateErrorReport());
        }
        #endif
        List<int> activeConnectionIds = new List<int>();
        public override void OnServerConnect(NetworkConnectionToClient conn)
        {   
            if(shuttingDown){
                Debug.Log("Cannot connect we are disconnecting server");
                return;
            }
            Debug.Log("Connected client to server, ConnectionId: " + conn.connectionId);
            playerConnections.Add(new PlayerConnection
            {
                ConnectionId = conn.connectionId,
                conn = conn
            });
            conn.Send<PlayerInfo>(new PlayerInfo
            {
                ConnectionId = conn.connectionId
            });
            activeConnectionIds.Add(conn.connectionId);
        }
        IEnumerator WaitFiveSeconds(){
            yield return new WaitForSeconds(5);
            AzureLoaded = true;
        }
        #if UNITY_SERVER //|| UNITY_EDITOR
        IEnumerator CheckIfPlayerIsConnected(string playerId, NetworkConnectionToClient conn, GetUserDataResult result, PlayerInfo netMsg, string tacticianNamePlayFab, string ticket) {
                netMsg.PlayFabId = playerId;
                conn.authenticationData = netMsg;
            List<string> nftIDs = new List<string>();
            
            string xrplPublic = "Empty";
            string tactBuildString = "Empty";
            bool hasXUMM = false;
            bool DKPTrustLineSet = false;
            bool GameMaster = false;
            if(result.Data != null && result.Data.ContainsKey("DEV") && result.Data["DEV"].Value == "KEY"){
                GameMaster = true;
            }
            if (result.Data != null && result.Data.ContainsKey("PUBLICADDRESS")){ 
                if (result.Data.TryGetValue("PUBLICADDRESS", out UserDataRecord userDataRecord)){
                    xrplPublic = userDataRecord.Value;
                    hasXUMM = true;
                } 
            }
            if (result.Data != null && result.Data.ContainsKey("TACTBUILDSTRING")){ 
                if (result.Data.TryGetValue("TACTBUILDSTRING", out UserDataRecord userDataRecord)){
                    tactBuildString = userDataRecord.Value;
                } 
            }
            if(hasXUMM){
                //check for trustline if not make sure they do this same step on register
            }
            var playerConnection = playerConnections.Find(c => c.ConnectedPlayer != null && c.ConnectedPlayer.PlayerId == playerId && c.ConnectionId != netMsg.ConnectionId);
            if (playerConnection != null) {
                Debug.Log($"Player with ID {playerId} is already connected. Disconnecting existing connection. ConnectionId: {playerConnection.ConnectionId}");
                //processing list for disonncet
                conn.Send<WaitingForLogout>(new WaitingForLogout {
                    finished = true
                });
                bool playerLoggingOut = true;
                if(!ProcessingLogoutList.Contains(playerId) && !DisconnectedList.Contains(playerId)){
                    playerLoggingOut = false;
                    //OnServerDisconnect(playerConnection.conn); TargetLogoutClient
                    if(playerConnection.conn != null){
                        if(playerConnection.conn.identity != null){
                            if(playerConnection.conn.identity != null){
                                if(playerConnection.conn.identity.gameObject != null){
                                    ScenePlayer sPlayer = playerConnection.conn.identity.gameObject.GetComponent<ScenePlayer>();
                                    if(sPlayer != null){
                                        sPlayer.TargetLogoutClient();
                                        Debug.Log($"Player with ID {playerId} is being disconnected because they were not in the process of disconnecting");
                                        playerLoggingOut = true;
                                        yield return new WaitForSeconds(5f);
                                    }
                                }
                            }
                        }
                    }
                }
                if(playerLoggingOut){
                    bool onList = true;
                    float timeout = 300f; // 120 seconds
                    float timeElapsed = 0f;
                    Debug.Log($"Player with ID {playerId} is being disconnected waiting");
                    while(timeElapsed < timeout){
                        if(!ProcessingLogoutList.Contains(playerId) && !DisconnectedList.Contains(playerId)){
                            //onList = false;
                            Debug.Log($"Player with ID {playerId} is finally disconnected going to connect this account in 10 seconds");
                            break;
                        }
                        yield return new WaitForSeconds(1f);
                        timeElapsed += 1f;
                        if (timeElapsed >= timeout)
                        {
                            //if(!CheckNullConnection(conn)){
                            //    yield break;
                            //}
                            // Logic to handle timeout scenario, e.g., force remove from lists
                            Debug.Log($"Timeout reached for player with ID {playerId}. Removing from lists.");
                            if(ProcessingLogoutList.Contains(playerId)){
                                ProcessingLogoutList.Remove(playerId);
                            }
                            if(DisconnectedList.Contains(playerId)){
                                DisconnectedList.Remove(playerId);
                            }
                            for(int j = 0; j < connectedPlayers.Count; j++){
                                if(connectedPlayers[j].PlayerId == playerId){
                                    connectedPlayers.Remove(connectedPlayers[j]);
                                }
                            }
                            PlayFabMultiplayerAgentAPI.UpdateConnectedPlayers(connectedPlayers);
                            // Add any additional timeout handling logic here
                        }
                    }
                    yield return new WaitForSeconds(10f);
                    Debug.Log($"Player with ID {playerId} is ready to connect now after waiting for the previous login to disconnect");
                    var _playerConnection = playerConnections.Find(c => c.ConnectionId == netMsg.ConnectionId);
                    if(_playerConnection == null){
                        OnServerDisconnect(conn);
                        yield break;
                    }
                    _playerConnection.ConnectedPlayer = new ConnectedPlayer(playerId);
                    connectedPlayers.Add(_playerConnection.ConnectedPlayer);
                    PlayFabMultiplayerAgentAPI.UpdateConnectedPlayers(connectedPlayers);
                    
                    if (result.Data != null && result.Data.ContainsKey("NewAccount89")){
                        if(GameMaster){
                    foreach(var item in ItemDataStorage.Instance.GetnftIDsReference()){
                        if(!nftIDs.Contains(item)){
                            nftIDs.Add(item);
                            //print($"Adding this item {item}");
                        }
                    }
                    nftIDs.Add("NFT_BowOfPower");
                    nftIDs.Add("NFT_GreatspearOfDragonslaying");
                    nftIDs.Add("NFT_AcidicAxe");
                    nftIDs.Add("NFT_MaceOfHealing");
                    nftIDs.Add("NFT_SpearOfDragonslaying");
                    nftIDs.Add("NFT_StaffOfProtection");
                    nftIDs.Add("NFT_SwordOfFire");
                    nftIDs.Add("NFT_ThunderInfusedGreathammer");
                    nftIDs.Add("NFT_VampiricDagger");
                    nftIDs.Add("NFT_VenomousGreataxe");
                    nftIDs.Add("NFT_FrozenGreatsword");

                } 
                        //Generate the Xumm QRCode
                        bool newPlayer = true;
                        PlayerInfo playerinfo = new PlayerInfo { 
                            newPlayer = newPlayer,
                            PlayFabId = playerId,
                            SessionTicket = ticket,
                           // SavedNode = "TOWNOFARUDINE",
                           NFTIDS = nftIDs,
                            CurrentScene = TOWNOFARUDINE,
                            PlayerName = tacticianNamePlayFab,
                            XRPLPUBLIC = xrplPublic
                        };
                        bool registered = false;
                        if(xrplPublic != "Empty"){
                            registered = true;
                        }
                        conn.authenticationData = playerinfo;
                        base.OnServerConnect(conn);
                        //if(!registered){
                        //    RegisterAccount(conn, playerId, 0, null);
                        //} else {
                            conn.Send<Noob>(new Noob {
                                tactician = tacticianNamePlayFab,
                                finished = false,
                                Address = xrplPublic
                            });
                        //}
                    }
                    if(result.Data != null && !result.Data.ContainsKey("NewAccount89")){
                        StartCoroutine(GetPlayerData(playerId, conn, tacticianNamePlayFab, ticket, netMsg, xrplPublic, tactBuildString));
                    }
                } else {
                    Debug.Log($"Player with ID {playerId} is now waiting for prior login to logout");
                    if( playerConnection != null){
                        OnServerDisconnect(playerConnection.conn);
                        yield return new WaitForSeconds(15);
                        float timeout = 300f; // 120 seconds
                    float timeElapsed = 0f;
                    Debug.Log($"Player with ID {playerId} is being disconnected waiting");
                    while(timeElapsed < timeout){
                        if(!ProcessingLogoutList.Contains(playerId) && !DisconnectedList.Contains(playerId)){
                            //onList = false;
                            Debug.Log($"Player with ID {playerId} is finally disconnected going to connect this account in 10 seconds");
                            break;
                        }
                        yield return new WaitForSeconds(1f);
                        timeElapsed += 1f;
                        if (timeElapsed >= timeout)
                        {
                            //if(!CheckNullConnection(conn)){
                            //    yield break;
                            //}
                            // Logic to handle timeout scenario, e.g., force remove from lists
                            Debug.Log($"Timeout reached for player with ID {playerId}. Removing from lists.");
                            if(ProcessingLogoutList.Contains(playerId)){
                                ProcessingLogoutList.Remove(playerId);
                            }
                            if(DisconnectedList.Contains(playerId)){
                                DisconnectedList.Remove(playerId);
                            }
                            for(int j = 0; j < connectedPlayers.Count; j++){
                                if(connectedPlayers[j].PlayerId == playerId){
                                    connectedPlayers.Remove(connectedPlayers[j]);
                                }
                            }
                            PlayFabMultiplayerAgentAPI.UpdateConnectedPlayers(connectedPlayers);
                            // Add any additional timeout handling logic here
                        }
                    }
                    yield return new WaitForSeconds(10f);

                    }

                    Debug.Log($"Player with ID {playerId} is ready to connect now without any other logins active");
                    var _playerConnection = playerConnections.Find(c => c.ConnectionId == netMsg.ConnectionId);
                    if(_playerConnection == null){
                        OnServerDisconnect(conn);
                        yield break;
                    }
                    _playerConnection.ConnectedPlayer = new ConnectedPlayer(playerId);
                    connectedPlayers.Add(_playerConnection.ConnectedPlayer);
                    PlayFabMultiplayerAgentAPI.UpdateConnectedPlayers(connectedPlayers);
                    
                    if (result.Data != null && result.Data.ContainsKey("NewAccount89")){
                        if(GameMaster){
                    foreach(var item in ItemDataStorage.Instance.GetnftIDsReference()){
                        if(!nftIDs.Contains(item)){
                            nftIDs.Add(item);
                            //print($"Adding this item {item}");
                        }
                    }
                    nftIDs.Add("NFT_BowOfPower");
                    nftIDs.Add("NFT_GreatspearOfDragonslaying");
                    nftIDs.Add("NFT_AcidicAxe");
                    nftIDs.Add("NFT_MaceOfHealing");
                    nftIDs.Add("NFT_SpearOfDragonslaying");
                    nftIDs.Add("NFT_StaffOfProtection");
                    nftIDs.Add("NFT_SwordOfFire");
                    nftIDs.Add("NFT_ThunderInfusedGreathammer");
                    nftIDs.Add("NFT_VampiricDagger");
                    nftIDs.Add("NFT_VenomousGreataxe");
                    nftIDs.Add("NFT_FrozenGreatsword");

                } 
                        //Generate the Xumm QRCode
                        bool newPlayer = true;
                        PlayerInfo playerinfo = new PlayerInfo { 
                            newPlayer = newPlayer,
                            PlayFabId = playerId,
                            SessionTicket = ticket,
                            //SavedNode = "TOWNOFARUDINE",
                            NFTIDS = nftIDs,
                            PlayerName = tacticianNamePlayFab,
                            CurrentScene = TOWNOFARUDINE,
                            XRPLPUBLIC = xrplPublic
                        };
                        bool registered = false;
                        if(xrplPublic != "Empty"){
                            registered = true;
                        }
                        conn.authenticationData = playerinfo;
                        base.OnServerConnect(conn);
                        //if(!registered){
                        //    RegisterAccount(conn, playerId, 0, null);
                        //} else {
                            conn.Send<Noob>(new Noob {
                                tactician = tacticianNamePlayFab,
                                finished = false,
                                Address = xrplPublic
                            });
                        //}
                    }
                    if(result.Data != null && !result.Data.ContainsKey("NewAccount89")){
                        StartCoroutine(GetPlayerData(playerId, conn, tacticianNamePlayFab, ticket, netMsg, xrplPublic, tactBuildString));
                    }
                }
                //begin the reconnect process
            } else {
                if(ProcessingLogoutList.Contains(playerId) || DisconnectedList.Contains(playerId)){
                    bool onList = true;
                    while(onList){
                        if(!ProcessingLogoutList.Contains(playerId) && !DisconnectedList.Contains(playerId)){
                            onList = false;
                        }
                        yield return new WaitForSeconds(1f);
                    }
                    yield return new WaitForSeconds(10f);
                }
                Debug.Log($"Player with ID {playerId} is ready to connect now");
                var _playerConnection = playerConnections.Find(c => c.ConnectionId == netMsg.ConnectionId);
                
                    if(_playerConnection == null){
                        OnServerDisconnect(conn);
                        yield break;
                    }
                _playerConnection.ConnectedPlayer = new ConnectedPlayer(playerId);
                connectedPlayers.Add(_playerConnection.ConnectedPlayer);
                PlayFabMultiplayerAgentAPI.UpdateConnectedPlayers(connectedPlayers);
                
                if (result.Data != null && result.Data.ContainsKey("NewAccount89")){
                    if(GameMaster){
                    foreach(var item in ItemDataStorage.Instance.GetnftIDsReference()){
                        if(!nftIDs.Contains(item)){
                            nftIDs.Add(item);
                            //print($"Adding this item {item}");
                        }
                    }
                    nftIDs.Add("NFT_BowOfPower");
                    nftIDs.Add("NFT_GreatspearOfDragonslaying");
                    nftIDs.Add("NFT_AcidicAxe");
                    nftIDs.Add("NFT_MaceOfHealing");
                    nftIDs.Add("NFT_SpearOfDragonslaying");
                    nftIDs.Add("NFT_StaffOfProtection");
                    nftIDs.Add("NFT_SwordOfFire");
                    nftIDs.Add("NFT_ThunderInfusedGreathammer");
                    nftIDs.Add("NFT_VampiricDagger");
                    nftIDs.Add("NFT_VenomousGreataxe");
                    nftIDs.Add("NFT_FrozenGreatsword");

                } 
                    //Generate the Xumm QRCode
                    bool newPlayer = true;
                    PlayerInfo playerinfo = new PlayerInfo { 
                        newPlayer = newPlayer,
                        PlayFabId = playerId,
                        SessionTicket = ticket,
                        PlayerName = tacticianNamePlayFab,
                        NFTIDS = nftIDs,
                        //SavedNode = "TOWNOFARUDINE",
                        CurrentScene = TOWNOFARUDINE,
                        XRPLPUBLIC = xrplPublic
                    };
                    bool registered = false;
                    if(xrplPublic != "Empty"){
                        registered = true;
                    }
                    conn.authenticationData = playerinfo;
                    base.OnServerConnect(conn);
                    //if(!registered){
                    //    RegisterAccount(conn, playerId, 0, null);
                    //} else {
                        conn.Send<Noob>(new Noob {
                            tactician = tacticianNamePlayFab,
                            finished = false,
                            Address = xrplPublic
                        });
                    //}
                }
                if(result.Data != null && !result.Data.ContainsKey("NewAccount89")){
                    StartCoroutine(GetPlayerData(playerId, conn, tacticianNamePlayFab, ticket, netMsg, xrplPublic, tactBuildString));
                }
            }
            CheckStaticPlayerStatus(conn, netMsg);
        }
        void CheckStaticPlayerStatus(NetworkConnectionToClient conn, PlayerInfo netMsg){
            foreach(var pC in playerConnections){
                if(pC.conn != null){
                    if(pC.conn != conn){
                        if(pC.conn.authenticationData is PlayerInfo playerData){
                            // Now playerData is safely cast to PlayerInfo, and we know it's not null because it's a value type
                            if(playerData.PlayFabId == netMsg.PlayFabId){
                                if(ProcessingLogoutList.Contains(playerData.PlayFabId) || DisconnectedList.Contains(playerData.PlayFabId)){
                                    continue; // Skip this iteration if PlayFabId is in ProcessingLogoutList or DisconnectedList
                                } else {
                                    OnServerDisconnect(pC.conn); // Disconnect the player if they're not in those lists
                                }
                            }
                        }
                        //PlayerInfo playerData = (PlayerInfo)pC.conn.authenticationData;
                        //if(playerData.PlayFabId == netMsg.PlayFabId){
                        //    if(ProcessingLogoutList.Contains(playerData.PlayFabId) || DisconnectedList.Contains(playerData.PlayFabId)){
                        //        continue;
                        //    } else {
                        //        
                        //        OnServerDisconnect(pC.conn);
                        //    }
                        //} 
                    }
                }
            }
        }
        //GameObject idenGO = null;//playerConnection.conn.GetComponent<NetworkIdentity>();
                                    //ScenePlayer removeplayer = null;//playerConnection.conn.identity.gameObject.GetComponent<ScenePlayer>();
                                    //if(iden != null){
                                    //    idenGO = pC.conn.identity.gameObject;
                                    //    if(idenGO != null){
                                    //        removeplayer = pC.conn.identity.gameObject.GetComponent<ScenePlayer>();
                                    //    }
                                    //}
                                    //if(removeplayer != null){
                                    //    removeplayer.Target
                                    //}
#endif
        public override void OnServerAddPlayer(NetworkConnectionToClient conn)
        {   
            StartCoroutine(AddingPlayerToServer(conn));   
        }
        IEnumerator AddingPlayerToServer(NetworkConnectionToClient conn){
            // start energy recharge here for character
            PlayerInfo playerData = (PlayerInfo)conn.authenticationData;
            if (playerData.newPlayer == true){                
                GameObject Playernoob = Instantiate(playerPrefab);
                Playernoob.name = $"{playerPrefab.name} [connId={conn.connectionId}]";
                NetworkServer.AddPlayerForConnection(conn, Playernoob);
                //SceneManager.MoveGameObjectToScene(conn.identity.gameObject, TownScene);
                float newX = 2.5f;
                float newY = 0.0f;
                float newEnergy = 1500f;
                playerData.Energy = newEnergy;
                playerData.CurrentScene = TOWNOFARUDINE;
                Vector3 newPlayerPos = new Vector3 (newX, newY, 0f);
                //StartCoroutine(PausedOVMMovement(Playernoob, newPlayerPos));
                Playernoob.transform.position = newPlayerPos;
                conn.authenticationData = playerData;
                VerifyNewPlayerData(conn, playerData);
                yield break;
            }
            //needed this
            conn.authenticationData = playerData;
            LoginInventoryCheck(conn, playerData);
        }//Assets/Resources/Sprites/Characters/Player0.png
        //inserting NFT code for spawning in the items for demo.
    public bool CheckNullConnection(NetworkConnectionToClient conn){
        if(conn == null){
            Debug.LogWarning("CheckNullConnection");
            return false;
        }
        if(conn?.identity == null){
            Debug.LogWarning("CheckNullConnection");
            return false;
        }
        #if UNITY_SERVER //|| UNITY_EDITOR

        if (conn?.identity?.gameObject == null) {

            var playerConnection = playerConnections.Find(c => c.ConnectionId == conn.connectionId);
            if(playerConnection != null){
                if(connectedPlayers.Contains(playerConnection.ConnectedPlayer)){
                    connectedPlayers.Remove(playerConnection.ConnectedPlayer);
                }
                if(playerConnections.Contains(playerConnection)){
                    playerConnections.Remove(playerConnection);
                }
                PlayFabMultiplayerAgentAPI.UpdateConnectedPlayers(connectedPlayers);
            }
            base.OnServerDisconnect(conn);
            //StartCoroutine(ServerDisconnectPlayerPause(conn, null));
            Debug.LogWarning("CheckNullConnection");
            return false;
        }
        #endif

        return true;

    }
        #if UNITY_SERVER //|| UNITY_EDITOR

    public override void OnServerDisconnect(NetworkConnectionToClient conn){
        CheckNullConnection(conn);
        print($"Starting our DC prep for this account");
        if(activeConnectionIds.Contains(conn.connectionId)){
            activeConnectionIds.Remove(conn.connectionId);
        }
        if (conn?.identity?.gameObject == null) {
            var playerConnection = playerConnections.Find(c => c.ConnectionId == conn.connectionId);
            if(playerConnection != null){
                if(connectedPlayers.Contains(playerConnection.ConnectedPlayer)){
                    connectedPlayers.Remove(playerConnection.ConnectedPlayer);
                }
                if(playerConnections.Contains(playerConnection)){
                    playerConnections.Remove(playerConnection);
                }
                PlayFabMultiplayerAgentAPI.UpdateConnectedPlayers(connectedPlayers);
            }
            base.OnServerDisconnect(conn);
            //StartCoroutine(ServerDisconnectPlayerPause(conn, null));
            Debug.LogWarning("Connection or identity or game object is null.");
            return;
        }
        ScenePlayer p = conn.identity.gameObject.GetComponent<ScenePlayer>();
        // Check if the ScenePlayer component exists
        if (p == null) {
            var playerConnection = playerConnections.Find(c => c.ConnectionId == conn.connectionId);
            if(playerConnection != null){
                if(connectedPlayers.Contains(playerConnection.ConnectedPlayer)){
                    connectedPlayers.Remove(playerConnection.ConnectedPlayer);
                }
                if(playerConnections.Contains(playerConnection)){
                    playerConnections.Remove(playerConnection);
                }
                PlayFabMultiplayerAgentAPI.UpdateConnectedPlayers(connectedPlayers);
            }
            base.OnServerDisconnect(conn);
            Debug.LogWarning("ScenePlayer component is missing.");
            return;
        }
        NavMeshAgent navMeshAgent = p.GetComponent<NavMeshAgent>();
        if(navMeshAgent != null)
        navMeshAgent.isStopped = true;
        string scene = p.currentScene;
        // Check if authentication data exists and is of type PlayerInfo
        if (!(conn.authenticationData is PlayerInfo playerData)) {
            Debug.LogWarning("Authentication data is missing or not of type PlayerInfo.");
            return;
        }
        DisconnectedList.Add(playerData.PlayFabId);
        print("Starting ProcessDisconnecting coroutine");
        StartCoroutine(ProcessingDisconnecting(conn, playerData, p.Energy, scene));   
    }

    private IEnumerator ServerDisconnectPlayerPause(NetworkConnectionToClient conn, string ID){
        //if(!CheckNullConnection(conn)){
        //        yield break;
        //    }
        yield return new WaitForSeconds(.1f);
        StopOperation(conn);
        var playerConnection = playerConnections.Find(c => c.ConnectionId == conn.connectionId);
        if(playerConnection != null){
            if(connectedPlayers.Contains(playerConnection.ConnectedPlayer)){
                connectedPlayers.Remove(playerConnection.ConnectedPlayer);
            }
            if(playerConnections.Contains(playerConnection)){
                playerConnections.Remove(playerConnection);
            }
        }
        PlayFabMultiplayerAgentAPI.UpdateConnectedPlayers(connectedPlayers);
        if(ID != null){
            if(DisconnectedList.Contains(ID)){
                DisconnectedList.Remove(ID);
            }
            if(ProcessingLogoutList.Contains(ID)){
                ProcessingLogoutList.Remove(ID);
            }
        }
       
        base.OnServerDisconnect(conn);
        if (playerConnections.Count == 0) {
            //StartCoroutine(Shutdown());
        }
    }
        private IEnumerator ServerDisconnectPlayer(NetworkConnectionToClient conn, string ID){
            //if(!CheckNullConnection(conn)){
            //    yield break;
            //}
            ScenePlayer p = conn.identity.gameObject.GetComponent<ScenePlayer>();
            if(p == null){
                yield break;
            }
            if(p.inMatch){
                MatchMaker.instance.PlayerDisconnected (p, p.matchID);
            } else {
                if(p.inLobby){
                    MatchMaker.instance.PlayerDisconnectedFromLobby (p, p.matchID);
                }
            }
            yield return new WaitForSeconds(1f);

            StartCoroutine(ServerDisconnectPlayerPause(conn, ID));
        }
        IEnumerator RemovePlayer(string id){
        WWWForm form = new WWWForm();
        form.AddField("id", id);
        using (UnityWebRequest www = UnityWebRequest.Post(_Heroku_URL + "/removePlayer", form))
        {
            www.SetRequestHeader("x-api-key", CONVO_KEY);

            yield return www.SendWebRequest();

            if (www.result == UnityWebRequest.Result.ConnectionError || www.result == UnityWebRequest.Result.ProtocolError)
            {
                Debug.Log(www.error);
            }
            else
            {
                RemoveResponseObj response = JsonUtility.FromJson<RemoveResponseObj>(www.downloadHandler.text);
                Debug.Log("Received JSON: " + www.downloadHandler.text);
                //print($"{response.success} was our success bool, {response.message} was our message and {response.details.userId} was our User ID, {response.details.goldAmount} was amount and {response.details.walletAddress} is our address");
                var jsonNode = JSON.Parse(www.downloadHandler.text);
                string _success = jsonNode["success"];
                Debug.Log("Success: " + _success);
                //if (response.success == "true")
                //{
                //    Debug.Log("Successfully completed transaction and removed gold");
                //    Debug.Log("User ID: " + response.details.userId);
                //    Debug.Log("Gold Amount: " + response.details.goldAmount);
                //    Debug.Log("Wallet Address: " + response.details.walletAddress);
                //}
                //else
                //{
                //    Debug.Log("Failed to complete transaction");
                //}
            }
        }
    }
        private IEnumerator Shutdown()
        {
            
            yield return new WaitForSeconds(.5f);
            if (playerConnections.Count == 0)
            {
                print("No players left closing server");
                if(!Local){
                    StartCoroutine(UnregisterServerToHeroku());
                    Application.Quit();
                }
            }
        }
        #endif

        void StartPlayFabAPI()
        {
#if UNITY_SERVER //|| UNITY_EDITOR
            
            PlayFabMultiplayerAgentAPI.Start();
            StartCoroutine(ReadyForPlayers());
            #endif
        }
        #if UNITY_SERVER //|| UNITY_EDITOR

                IEnumerator ReadyForPlayers()
                {
                    yield return new WaitForSeconds(.5f);
                    PlayFabMultiplayerAgentAPI.ReadyForPlayers();
                    
                }
            #endif
            //float expForNextLevel = BaseExp + (currentLevel * AdditionalExpPerLevel);

              //we need to add the exp into 
        public (int newLevel, float newExp, bool leveledUp) CheckForLevelUpSkill(int currentLevel, float currentExp, ScenePlayer sPlayer)
        {
            const int MaxLevel = 100;
            const int BaseExp = 1000;
            const int AdditionalExpPerLevel = 200;

            // Calculate the experience required for the next level
            float expForNextLevel = BaseExp + ((currentLevel - 1) * AdditionalExpPerLevel);
            // Check if current experience is enough for leveling up
            bool leveled = false;
            while (currentExp >= expForNextLevel && currentLevel < MaxLevel)
            {
                leveled = true;
                currentLevel++;
                currentExp -= expForNextLevel;
                // Update the experience required for the next level
                expForNextLevel = BaseExp + (currentLevel * AdditionalExpPerLevel);
                sPlayer.Energy -= 2;
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
                CheckForLevelUpTactician(sPlayer, 2);
            }
        
            return (currentLevel, currentExp, leveled);
        }
        public void CheckForLevelUpTactician(ScenePlayer sPlayer, float expAwarded)
        {
            int currentLevel = 1;
            float currentExp = 0;
            bool foundExp = false;
            bool foundLvl = false;
            foreach(var stat in sPlayer.GetTacticianSheet().TacticianStatData){
                if(foundLvl && foundExp){
                    break;
                }
                if(stat.Key == "EXP"){
                    currentExp = float.Parse(stat.Value);
                    foundExp = true;
                }
                if(stat.Key == "LVL"){
                    currentLevel = int.Parse(stat.Value);
                    foundLvl = true;
                }
            }
            currentExp += expAwarded;
            // Array of experience required for each level. Index 0 is for level 1, index 1 for level 2, etc.
            int[] expThresholds = new int[] { 10000, 15000, 18000, 23000, 29000, 35000, 38000, 44000, 50000, 55000, 58000, 65000, 75000, 85000, 90000, 95000, 100000, 115000, 130000, 150000 };
            const int MaxLevel = 20; // Adjust max level according to your requirements

            // Ensure current level is within the bounds of the array
            if (currentLevel < 1 || currentLevel >= MaxLevel) return;

            // Calculate the experience required for the next level using the current level as the index
            float expForNextLevel = expThresholds[currentLevel - 1];

            // Check if current experience is enough for leveling up
            
            while (currentExp >= expForNextLevel && currentLevel < MaxLevel)
            {
                currentLevel++;
                currentExp -= expForNextLevel;

                // Ensure not to overflow the expThresholds array
                if (currentLevel - 1 < expThresholds.Length)
                {
                    expForNextLevel = expThresholds[currentLevel - 1];
                }
            }
            CharacterStatListItem lvlStat = new CharacterStatListItem {
                Key = "LVL",
                Value = currentLevel.ToString()
            };
            CharacterStatListItem expStat = new CharacterStatListItem {
                Key = "EXP",
                Value = currentExp.ToString()
            };
            sPlayer.GetTacticianLVLEXP(lvlStat, expStat);
        }
        public int CalculateHarvestUnits(float skill, float strength)
    {
        float gatherAmount = (skill / 100f) + (strength / 200f);

        // Guaranteed units
        int guaranteedUnits = Mathf.FloorToInt(gatherAmount);

        // Calculate the chance for an extra unit
        float extraChance = gatherAmount - guaranteedUnits;

        // Use Random.Range to determine if the player gets the extra unit
        if (UnityEngine.Random.Range(0f, 1f) < extraChance)
        {
            guaranteedUnits += 1;
        }

        return guaranteedUnits;
    }

        void GetHarvestDropCloth(ClothNodeDrop clothDrop, PlayerCharacter pc){
            
        #if UNITY_SERVER //|| UNITY_EDITOR

            if(clothDrop == null){
                pc.RpcCancelOnNodeDeath();
                print("node had no more avail slots canceling this");
                return;
            }
            
            
            int strength = pc.GetStrength();
            int fortitude = pc.GetFortitude();
            int arcana = pc.GetArcana();
            float exp = 50f;
            float durabilityLossChance = .05f;
            int foragingSkill = 1;
            float foragingExp = 1f;
            int itemCount = 0;
            int harvestAmount = 0;
            print("starting to look for durability loss");
            print("Damaging tool for unlucky roll");
            // If the random number is within the 5% chance, set the boolean to true
            CharacterInventoryListItem damagedItem = (new CharacterInventoryListItem{
                Key = "LuckyRoll"
            });
            
                for(int x = 0; x < pc.assignedPlayer.GetInformationSheets().Count; x++){
                    if(pc.assignedPlayer.GetInformationSheets()[x].CharacterID == pc.CharID){
                        foragingSkill = pc.assignedPlayer.GetInformationSheets()[x].foragingSkill;
                        foragingExp = pc.assignedPlayer.GetInformationSheets()[x].foragingExp;
                        float gatheringStaminaCost = 50f * (1f - (foragingSkill/200f) - (fortitude/1000f));
                        pc.ChargeSpellDelay(gatheringStaminaCost);
                        if (UnityEngine.Random.Range(0f, 1f) <= durabilityLossChance)
                        {
                            var validIndices = pc.assignedPlayer.GetInformationSheets()[x].CharInventoryData
                            .Select((item, index) => new { Item = item, Index = index })
                            .Where(x => x.Item.Value.Durability != "0" && x.Item.Value.GetItemName() == "Scythe" && !x.Item.Value.Deleted && x.Item.Value.amount != 0)
                            .Select(x => new { 
                                x.Index, 
                                x.Item, 
                                Durability = float.TryParse(x.Item.Value.Durability, out float dura) ? dura : float.MaxValue 
                            })
                            .ToList();
                            if (validIndices.Count > 0) {
                                damagedItem.Key = validIndices.First().Item.Key;
                                damagedItem.Value = validIndices.First().Item.Value;
                                if (damagedItem.Value != null) {
                                    string dura = damagedItem.Value.Durability;
                                    float durability;
                                    if (!float.TryParse(dura, out durability))
                                    {
                                        durability = 100f;
                                    }
                                    durability--;
                                    dura = durability.ToString(); // You should convert the updated float back to a string
                                    damagedItem.Value.Durability = dura;
                                    damagedItem.Value.Changed = true;
                                    print($"{damagedItem.Key} took a durability loss of 1, its durability is now {damagedItem.Value.Durability}");
                                } else {
                                    print("Error: damagedItem.Value is null.");
                                    return;
                                }
                            } else {
                                print("no harvesitng tool!");
                                return;
                            }
                            pc.assignedPlayer.GetCharacterUpdateHarvestDurability(pc.CharID, damagedItem);
                        }
                        break;
                    }
                }
            harvestAmount = CalculateHarvestUnits(foragingSkill, strength);
            if(harvestAmount == 0){
                //we failed
                pc.TargetUpdateHarvestFinish(false, "Failed to harvest item", "-2 energy", "No rare");
                pc.assignedPlayer.Energy -= 2;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                if(clothDrop.hitsPerNode > 0){
                    pc.assignedPlayer.TargetHarvestContinous(pc, clothDrop.gameObject);
                }
                return;
            }
            for(int X = 0; X < pc.assignedPlayer.GetInformationSheets().Count; X++){
                if(pc.assignedPlayer.GetInformationSheets()[X].CharacterID == pc.CharID){
                    for(int t = 0; t < pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData.Count; t++){
                        if(pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.Deleted || pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.amount == 0){
                            continue;
                        }
                        if(!pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.EQUIPPED){
                            itemCount ++;
                        }
                    }
                }
            }
            if(itemCount <= 18){
                //can build the rare now lets roll to see if we get
            } else {
                return; //no room
            }
            if(clothDrop.SetOpened()){
                pc.assignedPlayer.Energy -= 2;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                CheckForLevelUpTactician(pc.assignedPlayer, 2);
            } else {
                pc.RpcCancelOnNodeDeath();
                print("node had no more avail slots canceling this");
                return;
            }
            if(clothDrop.hitsPerNode > 0){
                pc.assignedPlayer.TargetHarvestContinous(pc, clothDrop.gameObject);
            }
            foragingExp += exp;
            string RareName = "No rare drop";
            float chanceOnRare = arcana/20;
            bool triggeredRare = false;
            if (UnityEngine.Random.Range(0f, 100f) <= chanceOnRare){
                triggeredRare = true;
            }
            if(clothDrop.GetTier() == 1){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material10";
                    } else {
                        RareName = "Grown01";
                    }
                }
                //Amber, ruby, rose quartz, Lapis lazuli, saphhire
                //Amber, ruby, rose quartz, Lapis lazuli, saphhire
                //eyeball, heart
                //Tomato,mushroom
            }
            if(clothDrop.GetTier() == 2){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material10";
                    } else {
                        RareName = "Grown01";
                    }
                }
            }
            if(clothDrop.GetTier() == 3){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material10";
                    } else {
                        RareName = "Grown01";
                    }
                }
            }
            if(clothDrop.GetTier() == 4){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material10";
                    } else {
                        RareName = "Grown01";
                    }
                }
            }
            //clothDrop.SetOpened();
            (int newLevel, float newExp, bool leveledUp) = CheckForLevelUpSkill(foragingSkill, foragingExp, pc.assignedPlayer);
            pc.assignedPlayer.UpdateCharacterSkill(newLevel, newExp, "foragingSkill", pc.CharID);
            NetworkIdentity networkIdentity = pc.assignedPlayer.GetComponent<NetworkIdentity>();
            NetworkConnectionToClient nconn = networkIdentity.connectionToClient;
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            List<string> items = new List<string>();
            items.Add("Material01");
            if(triggeredRare){
                items.Add(RareName);
                        }
            string energyCostAmount = "-2 energy cost";
            if(leveledUp){
            int energyExpense = newLevel * 5 + 12;
                energyCostAmount = $"-{energyExpense} energy cost";
                energyExpense -= 2;
                pc.assignedPlayer.Energy -= energyExpense;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                CheckForLevelUpTactician(pc.assignedPlayer, energyExpense);
            }
            string _rareNameInput = "No rare drop";
            if(RareName == "Gem01"){
                _rareNameInput = "Lapis Lazuli";
            }
            if(RareName == "Gem02"){
                _rareNameInput = "Amber";
            }
            if(RareName == "Gem03"){
                _rareNameInput = "Ruby";
            }
            if(RareName == "Gem04"){
                _rareNameInput = "Sapphire";
            }
            if(RareName == "Gem05"){
                _rareNameInput = "Rose Quartz";
            }
            if(RareName == "Material08"){
                _rareNameInput = "Heart";
            }
            if(RareName == "Material09"){
                _rareNameInput = "Eyeball";
            }
            if(RareName == "Material10"){
                _rareNameInput = "Tomato";
            }
            if(RareName == "Grown01"){
                _rareNameInput = "Mushroom";
            }
            pc.TargetUpdateHarvestFinish(true, $"{harvestAmount} fiber", energyCostAmount, _rareNameInput);
            foreach(var result in items){
                if(result == "Material01"){
                    TransformItemIntoDragonKill(nconn, playerData, result, pc.CharID, "Plain", harvestAmount, false, false, null, true, pc.assignedPlayer.playerName, false);
                } else {
                    TransformItemIntoDragonKill(nconn, playerData, result, pc.CharID, "Plain", 1, false, false, null, true, pc.assignedPlayer.playerName, false);
                }
            }
            if(!pc.assignedPlayer.GetQuestCompletedFullyList().Contains("Arudine-A2-2")){
                    int resourceCount = 0;
                    foreach(var questInProg in pc.assignedPlayer.GetQuestSavedStatus()){
                        if(questInProg.questID == "Arudine-A2-2"){
                            foreach(var resourceItem in pc.assignedPlayer.GetTacticianSheet().TacticianInventoryData){
                                if(resourceCount >= 6){
                                    break;
                                }
                                if(resourceItem.Value.Deleted || resourceItem.Value.amount == 0){
                                    continue;
                                }if(resourceItem.Value.Item_Name == "Fiber"){
                                    resourceCount += resourceItem.Value.amount;
                                }
                            }
                            foreach(var resourceItem in pc.assignedPlayer.GetTacticianSheet().StashInventoryData){
                                if(resourceCount >= 6){
                                    break;
                                }
                                if(resourceItem.Value.Deleted || resourceItem.Value.amount == 0){
                                    continue;
                                }if(resourceItem.Value.Item_Name == "Fiber"){
                                    resourceCount += resourceItem.Value.amount;
                                }
                            }
                            foreach(var sheet in pc.assignedPlayer.GetInformationSheets()){
                                if(resourceCount >= 6){
                                    break;
                                }
                                foreach(var charItem in sheet.CharInventoryData){
                                    if(charItem.Value.Deleted || charItem.Value.amount == 0){
                                        continue;
                                    }
                                    if(charItem.Value.Item_Name =="Fiber"){
                                        resourceCount += charItem.Value.amount;
                                        if(resourceCount >= 6){
                                            break;
                                        }
                                    }
                                }
                            }
                            if(resourceCount >= 6){
                                pc.assignedPlayer.UpdateQuestProgress("Arudine-A2-2", "Gather 6 fiber");
                            }
                            break;
                        }
                    }
                }
        #endif
        
        }
        void GetHarvestDropLeather(LeatherNodeDrop leatherDrop, PlayerCharacter pc){
        #if UNITY_SERVER //|| UNITY_EDITOR

            if(leatherDrop == null){
                pc.RpcCancelOnNodeDeath();
                print("node had no more avail slots canceling this");
                return;
            }
            int strength = pc.GetStrength();
            int fortitude = pc.GetFortitude();
            int arcana = pc.GetArcana();
            float exp = 50f;
            float durabilityLossChance = .05f;
            int skinningSkill = 1;
            float skinningExp = 1f;
            int itemCount = 0;
            int harvestAmount = 0;
            print("starting to look for durability loss");
            // If the random number is within the 5% chance, set the boolean to true
            CharacterInventoryListItem damagedItem = (new CharacterInventoryListItem{
                Key = "LuckyRoll"
            });
            print("starting to look for durability loss");
            
                for(int x = 0; x < pc.assignedPlayer.GetInformationSheets().Count; x++){
                //foreach(var sheet in pc.assignedPlayer.GetInformationSheets()){
                    if(pc.assignedPlayer.GetInformationSheets()[x].CharacterID == pc.CharID){
                        skinningSkill = pc.assignedPlayer.GetInformationSheets()[x].skinningSkill;
                        skinningExp = pc.assignedPlayer.GetInformationSheets()[x].skinningExp;
                        float gatheringStaminaCost = 50f * (1f - (skinningSkill/200f) - (fortitude/1000f));
                        pc.ChargeSpellDelay(gatheringStaminaCost);
                        if (UnityEngine.Random.Range(0f, 1f) <= durabilityLossChance)
                        {
                            var validIndices = pc.assignedPlayer.GetInformationSheets()[x].CharInventoryData
                            .Select((item, index) => new { Item = item, Index = index })
                            .Where(x => x.Item.Value.Durability != "0" && x.Item.Value.GetItemName() == "Skinning Knife" && !x.Item.Value.Deleted && x.Item.Value.amount != 0)
                            //.Select(x => x.Index)
                            .Select(x => new { 
                                x.Index, 
                                x.Item, 
                                Durability = float.TryParse(x.Item.Value.Durability, out float dura) ? dura : float.MaxValue 
                            })
                            .ToList();
                            if (validIndices.Count > 0) {
                                damagedItem.Key = validIndices.First().Item.Key;
                                damagedItem.Value = validIndices.First().Item.Value;
                                if (damagedItem.Value != null) {
                                    string dura = damagedItem.Value.Durability;
                                    float durability;
                                    if (!float.TryParse(dura, out durability))
                                    {
                                        durability = 100f;
                                    }
                                    durability--;
                                    dura = durability.ToString(); // You should convert the updated float back to a string
                                    damagedItem.Value.Durability = dura;
                                    damagedItem.Value.Changed = true;
                                    print($"{damagedItem.Key} took a durability loss of 1, its durability is now {damagedItem.Value.Durability}");
                                } else {
                                    print("Error: damagedItem.Value is null.");
                                    return;
                                }
                            } else {
                                print("no harvesitng tool!");
                                return;
                            }
                            pc.assignedPlayer.GetCharacterUpdateHarvestDurability(pc.CharID, damagedItem);
                        }
                        break;
                    }
                }
            harvestAmount = CalculateHarvestUnits(skinningSkill, strength);
            if(harvestAmount == 0){
                //we failed
                pc.TargetUpdateHarvestFinish(false, "Failed to harvest item", "-2 energy", "No rare");
                pc.assignedPlayer.Energy -= 2;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                if(leatherDrop.hitsPerNode > 0){
                    pc.assignedPlayer.TargetHarvestContinous(pc, leatherDrop.gameObject);
                }
                return;
            }
            for(int X = 0; X < pc.assignedPlayer.GetInformationSheets().Count; X++){
                if(pc.assignedPlayer.GetInformationSheets()[X].CharacterID == pc.CharID){
                    for(int t = 0; t < pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData.Count; t++){
                        if(pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.Deleted || pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.amount == 0){
                            continue;
                        }
                        if(!pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.EQUIPPED){
                            itemCount ++;
                        }
                    }
                }
            }
            if(itemCount <= 18){
                //can build the rare now lets roll to see if we get
            } else {
                return; //no room
            }
            if(leatherDrop.SetOpened()){
                pc.assignedPlayer.Energy -= 2;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                CheckForLevelUpTactician(pc.assignedPlayer, 2);
            } else {
                pc.RpcCancelOnNodeDeath();
                print("node had no more avail slots canceling this");
                return;
            }
            if(leatherDrop.hitsPerNode > 0){
                pc.assignedPlayer.TargetHarvestContinous(pc, leatherDrop.gameObject);
            }
            skinningExp += exp;
            string RareName = "No rare drop";
            float chanceOnRare = arcana/20;
            bool triggeredRare = false;
            if (UnityEngine.Random.Range(0f, 100f) <= chanceOnRare){
                triggeredRare = true;
            }
            
            if(leatherDrop.GetTier() == 1){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material09";
                    } else {
                        RareName = "Material08";
                    }
                }
                //Amber, ruby, rose quartz, Lapis lazuli, saphhire
                //Amber, ruby, rose quartz, Lapis lazuli, saphhire
                //eyeball, heart
                //Tomato,mushroom
            }
            if(leatherDrop.GetTier() == 2){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material09";
                    } else {
                        RareName = "Material08";
                    }
                }
            }
            if(leatherDrop.GetTier() == 3){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material09";
                    } else {
                        RareName = "Material08";
                    }
                }
            }
            if(leatherDrop.GetTier() == 4){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material09";
                    } else {
                        RareName = "Material08";
                    }
                }
            }
            //leatherDrop.SetOpened();
            (int newLevel, float newExp, bool leveledUp) = CheckForLevelUpSkill(skinningSkill, skinningExp, pc.assignedPlayer);
            pc.assignedPlayer.UpdateCharacterSkill(newLevel, newExp, "skinningSkill", pc.CharID);
            NetworkIdentity networkIdentity = pc.assignedPlayer.GetComponent<NetworkIdentity>();
            NetworkConnectionToClient nconn = networkIdentity.connectionToClient;
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            List<string> items = new List<string>();
            items.Add("Material02");
            if(triggeredRare){
                items.Add(RareName);
                        }
            string energyCostAmount = "-2 energy cost";
            if(leveledUp){
            int energyExpense = newLevel * 5 + 12;
                energyCostAmount = $"-{energyExpense} energy cost";
                energyExpense -= 2;
                pc.assignedPlayer.Energy -= energyExpense;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                CheckForLevelUpTactician(pc.assignedPlayer, energyExpense);
            }
            string _rareNameInput = "No rare drop";
            if(RareName == "Gem01"){
                _rareNameInput = "Lapis Lazuli";
            }
            if(RareName == "Gem02"){
                _rareNameInput = "Amber";
            }
            if(RareName == "Gem03"){
                _rareNameInput = "Ruby";
            }
            if(RareName == "Gem04"){
                _rareNameInput = "Sapphire";
            }
            if(RareName == "Gem05"){
                _rareNameInput = "Rose Quartz";
            }
            if(RareName == "Material08"){
                _rareNameInput = "Heart";
            }
            if(RareName == "Material09"){
                _rareNameInput = "Eyeball";
            }
            pc.TargetUpdateHarvestFinish(true, $"{harvestAmount} hide", energyCostAmount, _rareNameInput);
            foreach(var result in items){
                if(result == "Material02"){
                    TransformItemIntoDragonKill(nconn, playerData, result, pc.CharID, "Plain", harvestAmount, false, false, null, true, pc.assignedPlayer.playerName, false);
                } else {
                    TransformItemIntoDragonKill(nconn, playerData, result, pc.CharID, "Plain", 1, false, false, null, true, pc.assignedPlayer.playerName, false);
                }
            }
                if(!pc.assignedPlayer.GetQuestCompletedFullyList().Contains("Arudine-A2-2")){
                    int resourceCount = 0;
                    foreach(var questInProg in pc.assignedPlayer.GetQuestSavedStatus()){
                        if(questInProg.questID == "Arudine-A2-2"){
                            if(resourceCount >= 6){
                                break;
                            }
                            foreach(var resourceItem in pc.assignedPlayer.GetTacticianSheet().TacticianInventoryData){
                                if(resourceItem.Value.Deleted || resourceItem.Value.amount == 0){
                                    continue;
                                }
                                if(resourceItem.Value.Item_Name == "Hide"){
                                    resourceCount += resourceItem.Value.amount;
                                }
                            }
                            foreach(var resourceItem in pc.assignedPlayer.GetTacticianSheet().StashInventoryData){
                                if(resourceCount >= 6){
                                    break;
                                }
                                if(resourceItem.Value.Deleted || resourceItem.Value.amount == 0){
                                    continue;
                                }
                                
                                if(resourceItem.Value.Item_Name == "Hide"){
                                    resourceCount += resourceItem.Value.amount;
                                }
                            }
                            foreach(var sheet in pc.assignedPlayer.GetInformationSheets()){
                                if(resourceCount >= 6){
                                    break;
                                }
                                foreach(var charItem in sheet.CharInventoryData){
                                    if(charItem.Value.Deleted || charItem.Value.amount == 0){
                                        continue;
                                    }
                                    if(charItem.Value.Item_Name == "Hide"){
                                        resourceCount += charItem.Value.amount;
                                        if(resourceCount >= 6){
                                            break;
                                        }
                                    }
                                }
                            }
                            if(resourceCount >= 6){
                                pc.assignedPlayer.UpdateQuestProgress("Arudine-A2-2", "Gather 6 hides");
                            }
                            
                            break;
                        }
                    }
                }
        #endif

        }
        void GetHarvestDropOre(OreNodeDrop oreDrop, PlayerCharacter pc){
        #if UNITY_SERVER //|| UNITY_EDITOR

            if(oreDrop == null){
                pc.RpcCancelOnNodeDeath();
                print("node had no more avail slots canceling this");
                return;
            }
            
            int strength = pc.GetStrength();
            int fortitude = pc.GetFortitude();
            int arcana = pc.GetArcana();
            float exp = 50f;
            float durabilityLossChance = .05f;
            int miningSkill = 1;
            float miningExp = 1f;
            int itemCount = 0;
            int harvestAmount = 0;
            // If the random number is within the 5% chance, set the boolean to true
            CharacterInventoryListItem damagedItem = (new CharacterInventoryListItem{
                Key = "LuckyRoll"
            });
            print("starting to look for durability loss");
            
                for(int x = 0; x < pc.assignedPlayer.GetInformationSheets().Count; x++){
                //foreach(var sheet in pc.assignedPlayer.GetInformationSheets()){
                    if(pc.assignedPlayer.GetInformationSheets()[x].CharacterID == pc.CharID){
                        miningSkill = pc.assignedPlayer.GetInformationSheets()[x].miningSkill;
                        miningExp = pc.assignedPlayer.GetInformationSheets()[x].miningExp;
                        float gatheringStaminaCost = 50f * (1f - (miningSkill/200f) - (fortitude/1000f));
                        pc.ChargeSpellDelay(gatheringStaminaCost);
                        if (UnityEngine.Random.Range(0f, 1f) <= durabilityLossChance)
                        {
                            var validIndices = pc.assignedPlayer.GetInformationSheets()[x].CharInventoryData
                            .Select((item, index) => new { Item = item, Index = index })
                            .Where(x => x.Item.Value.Durability != "0" && x.Item.Value.GetItemName() == "Pickaxe" && !x.Item.Value.Deleted && x.Item.Value.amount != 0)
                            //.Select(x => x.Index)
                            .Select(x => new { 
                                x.Index, 
                                x.Item, 
                                Durability = float.TryParse(x.Item.Value.Durability, out float dura) ? dura : float.MaxValue 
                            })
                            .ToList();
                            if (validIndices.Count > 0) {
                                damagedItem.Key = validIndices.First().Item.Key;
                                damagedItem.Value = validIndices.First().Item.Value;
                                if (damagedItem.Value != null) {
                                    string dura = damagedItem.Value.Durability;
                                    float durability;
                                    if (!float.TryParse(dura, out durability))
                                    {
                                        durability = 100f;
                                    }
                                    durability--;
                                    dura = durability.ToString(); // You should convert the updated float back to a string
                                    damagedItem.Value.Durability = dura;
                                    damagedItem.Value.Changed = true;
                                    print($"{damagedItem.Key} took a durability loss of 1, its durability is now {damagedItem.Value.Durability}");
                                } else {
                                    print("Error: damagedItem.Value is null.");
                                    return;
                                }
                            } else {
                                print("no harvesitng tool!");
                                return;
                            }
                            pc.assignedPlayer.GetCharacterUpdateHarvestDurability(pc.CharID, damagedItem);
                        }
                        break;
                }
            }
            harvestAmount = CalculateHarvestUnits(miningSkill, strength);
            if(harvestAmount == 0){
                //we failed
                pc.TargetUpdateHarvestFinish(false, "Failed to harvest item", "-2 energy", "No rare");
                pc.assignedPlayer.Energy -= 2;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                if(oreDrop.hitsPerNode > 0){
                    pc.assignedPlayer.TargetHarvestContinous(pc, oreDrop.gameObject);
                }
                return;
            }
            for(int X = 0; X < pc.assignedPlayer.GetInformationSheets().Count; X++){
                if(pc.assignedPlayer.GetInformationSheets()[X].CharacterID == pc.CharID){
                    for(int t = 0; t < pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData.Count; t++){
                        if(pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.Deleted || pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.amount == 0){
                            continue;
                        }
                        if(!pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.EQUIPPED){
                            itemCount ++;
                        }
                    }
                }
            }
            if(itemCount <= 18){
                //can build the rare now lets roll to see if we get
            } else {
                return; //no room
            }
            if(oreDrop.SetOpened()){
                pc.assignedPlayer.Energy -= 2;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                CheckForLevelUpTactician(pc.assignedPlayer, 2);
            } else {
                pc.RpcCancelOnNodeDeath();
                print("node had no more avail slots canceling this");
                return;
            }
            if(oreDrop.hitsPerNode > 0){
                pc.assignedPlayer.TargetHarvestContinous(pc, oreDrop.gameObject);
            }
            miningExp += exp;
            string RareName = "No rare drop";
            float chanceOnRare = arcana/20;
            bool triggeredRare = false;
            if (UnityEngine.Random.Range(0f, 100f) <= chanceOnRare){
                triggeredRare = true;
            }            
            if(oreDrop.GetTier() == 1){
                if(triggeredRare){
                    string[] rareItems = new string[] { "Gem02", "Gem03","Gem05", "Gem01", "Gem04" };
                    // Randomly select an index from the array
                    int randomIndex = UnityEngine.Random.Range(0, rareItems.Length);
                    // Assign the selected item to RareName
                    RareName = rareItems[randomIndex];
                }
                //Amber, ruby, rose quartz, Lapis lazuli, saphhire
                //Amber, ruby, rose quartz, Lapis lazuli, saphhire
                //eyeball, heart
                //Tomato,mushroom
            }
            if(oreDrop.GetTier() == 2){
                if(triggeredRare){
                    string[] rareItems = new string[] { "Gem02", "Gem03","Gem05", "Gem01", "Gem04" };
                    // Randomly select an index from the array
                    int randomIndex = UnityEngine.Random.Range(0, rareItems.Length);
                    // Assign the selected item to RareName
                    RareName = rareItems[randomIndex];
                }
            }
            if(oreDrop.GetTier() == 3){
                if(triggeredRare){
                    string[] rareItems = new string[] { "Gem02", "Gem03","Gem05", "Gem01", "Gem04" };
                    // Randomly select an index from the array
                    int randomIndex = UnityEngine.Random.Range(0, rareItems.Length);
                    // Assign the selected item to RareName
                    RareName = rareItems[randomIndex];
                }
            }
            if(oreDrop.GetTier() == 4){
                if(triggeredRare){
                    string[] rareItems = new string[] { "Gem02", "Gem03","Gem05", "Gem01", "Gem04" };
                    // Randomly select an index from the array
                    int randomIndex = UnityEngine.Random.Range(0, rareItems.Length);
                    // Assign the selected item to RareName
                    RareName = rareItems[randomIndex];
                }
            }
            //oreDrop.SetOpened();
            (int newLevel, float newExp, bool leveledUp) = CheckForLevelUpSkill(miningSkill, miningExp, pc.assignedPlayer);
            pc.assignedPlayer.UpdateCharacterSkill(newLevel, newExp, "miningSkill", pc.CharID);
            NetworkIdentity networkIdentity = pc.assignedPlayer.GetComponent<NetworkIdentity>();
            NetworkConnectionToClient nconn = networkIdentity.connectionToClient;
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            List<string> items = new List<string>();
            items.Add("Material03");
            if(triggeredRare){
                items.Add(RareName);
                        }
            string energyCostAmount = "-2 energy cost";
            if(leveledUp){
            int energyExpense = newLevel * 5 + 12;
                energyCostAmount = $"-{energyExpense} energy cost";
                energyExpense -= 2;
                pc.assignedPlayer.Energy -= energyExpense;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                CheckForLevelUpTactician(pc.assignedPlayer, energyExpense);
            }
            string _rareNameInput = "No rare drop";
            if(RareName == "Gem01"){
                _rareNameInput = "Lapis Lazuli";
            }
            if(RareName == "Gem02"){
                _rareNameInput = "Amber";
            }
            if(RareName == "Gem03"){
                _rareNameInput = "Ruby";
            }
            if(RareName == "Gem04"){
                _rareNameInput = "Sapphire";
            }
            if(RareName == "Gem05"){
                _rareNameInput = "Rose Quartz";
            }
            pc.TargetUpdateHarvestFinish(true, $"{harvestAmount} ore", energyCostAmount, _rareNameInput);
            foreach(var result in items){
                if(result == "Material03"){
                    TransformItemIntoDragonKill(nconn, playerData, result, pc.CharID, "Plain", harvestAmount, false, false, null, true, pc.assignedPlayer.playerName, false);
                } else {
                    TransformItemIntoDragonKill(nconn, playerData, result, pc.CharID, "Plain", 1, false, false, null, true, pc.assignedPlayer.playerName, false);
                }
            }
                if(!pc.assignedPlayer.GetQuestCompletedFullyList().Contains("Arudine-A2-2")){
                    int resourceCount = 0;
                    foreach(var questInProg in pc.assignedPlayer.GetQuestSavedStatus()){
                        if(questInProg.questID == "Arudine-A2-2"){
                            foreach(var resourceItem in pc.assignedPlayer.GetTacticianSheet().TacticianInventoryData){
                                if(resourceCount >= 6){
                                    break;
                                }
                                if(resourceItem.Value.Deleted || resourceItem.Value.amount == 0){
                                    continue;
                                }
                                if(resourceItem.Value.Item_Name == "Ore"){
                                    resourceCount += resourceItem.Value.amount;
                                }
                            }
                            foreach(var resourceItem in pc.assignedPlayer.GetTacticianSheet().StashInventoryData){
                                if(resourceCount >= 6){
                                    break;
                                }
                                if(resourceItem.Value.Deleted || resourceItem.Value.amount == 0){
                                    continue;
                                }
                                if(resourceItem.Value.Item_Name == "Ore"){
                                    resourceCount += resourceItem.Value.amount;
                                }
                            }
                            foreach(var sheet in pc.assignedPlayer.GetInformationSheets()){
                                if(resourceCount >= 6){
                                    break;
                                }
                                foreach(var charItem in sheet.CharInventoryData){
                                    if(charItem.Value.Deleted || charItem.Value.amount == 0){
                                        continue;
                                    }
                                    if(charItem.Value.Item_Name == "Ore"){
                                        resourceCount += charItem.Value.amount;
                                        if(resourceCount >= 6){
                                            break;
                                        }
                                    }
                                }
                            }
                            if(resourceCount >= 6){
                                pc.assignedPlayer.UpdateQuestProgress("Arudine-A2-2", "Gather 6 ore");
                            }
                            break;
                        }
                    }
                }
        #endif

        }
        void GetHarvestDropStone(StoneNodeDrop stoneDrop, PlayerCharacter pc){
        #if UNITY_SERVER //|| UNITY_EDITOR

            if(stoneDrop == null){
                pc.RpcCancelOnNodeDeath();
                print("node had no more avail slots canceling this");
                return;
            }
            
            
            int strength = pc.GetStrength();
            int fortitude = pc.GetFortitude();
            int arcana = pc.GetArcana();
            float exp = 50f;
            float durabilityLossChance = .05f;
            int prospectingSkill = 1;
            float prospectingExp = 1f;
            int itemCount = 0;
            int harvestAmount = 0;
            print("starting to look for durability loss");
            // If the random number is within the 5% chance, set the boolean to true
            CharacterInventoryListItem damagedItem = (new CharacterInventoryListItem{
                Key = "LuckyRoll"
            });
            print("starting to look for durability loss");
            
                for(int x = 0; x < pc.assignedPlayer.GetInformationSheets().Count; x++){
                    if(pc.assignedPlayer.GetInformationSheets()[x].CharacterID == pc.CharID){
                        prospectingSkill = pc.assignedPlayer.GetInformationSheets()[x].prospectingSkill;
                        prospectingExp = pc.assignedPlayer.GetInformationSheets()[x].prospectingExp;
                        float gatheringStaminaCost = 50f * (1f - (prospectingSkill/200f) - (fortitude/1000f));
                        pc.ChargeSpellDelay(gatheringStaminaCost);
                        if (UnityEngine.Random.Range(0f, 1f) <= durabilityLossChance)
                        {
                            var validIndices = pc.assignedPlayer.GetInformationSheets()[x].CharInventoryData
                            .Select((item, index) => new { Item = item, Index = index })
                            .Where(x => x.Item.Value.Durability != "0" && x.Item.Value.GetItemName() == "Stone Hammer" && !x.Item.Value.Deleted && x.Item.Value.amount != 0)
                            //.Select(x => x.Index)
                            .Select(x => new { 
                                x.Index, 
                                x.Item, 
                                Durability = float.TryParse(x.Item.Value.Durability, out float dura) ? dura : float.MaxValue 
                            })
                            .ToList();
                            if (validIndices.Count > 0) {
                                damagedItem.Key = validIndices.First().Item.Key;
                                damagedItem.Value = validIndices.First().Item.Value;
                                if (damagedItem.Value != null) {
                                    string dura = damagedItem.Value.Durability;
                                    float durability;
                                    if (!float.TryParse(dura, out durability))
                                    {
                                        durability = 100f;
                                    }
                                    durability--;
                                    dura = durability.ToString(); // You should convert the updated float back to a string
                                    damagedItem.Value.Durability = dura;
                                    damagedItem.Value.Changed = true;
                                    print($"{damagedItem.Key} took a durability loss of 1, its durability is now {damagedItem.Value.Durability}");
                                } else {
                                    print("Error: damagedItem.Value is null.");
                                    return;
                                }
                            } else {
                                print("no harvesitng tool!");
                                return;
                            }
                            pc.assignedPlayer.GetCharacterUpdateHarvestDurability(pc.CharID, damagedItem);
                        }
                        break;
                    }
                }
            harvestAmount = CalculateHarvestUnits(prospectingSkill, strength);
            if(harvestAmount == 0){
                //we failed
                pc.TargetUpdateHarvestFinish(false, "Failed to harvest item", "-2 energy", "No rare");
                pc.assignedPlayer.Energy -= 2;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                if(stoneDrop.hitsPerNode > 0){
                    pc.assignedPlayer.TargetHarvestContinous(pc, stoneDrop.gameObject);
                }
                return;
            }
            for(int X = 0; X < pc.assignedPlayer.GetInformationSheets().Count; X++){
                if(pc.assignedPlayer.GetInformationSheets()[X].CharacterID == pc.CharID){
                    for(int t = 0; t < pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData.Count; t++){
                        if(pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.Deleted || pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.amount == 0){
                            continue;
                        }
                        if(!pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.EQUIPPED){
                            itemCount ++;
                        }
                    }
                }
            }
            if(itemCount <= 18){
                //can build the rare now lets roll to see if we get
            } else {
                return; //no room
            }
            if(stoneDrop.SetOpened()){
                pc.assignedPlayer.Energy -= 2;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                CheckForLevelUpTactician(pc.assignedPlayer, 2);
            } else {
                pc.RpcCancelOnNodeDeath();
                print("node had no more avail slots canceling this");
                return;
            }
            if(stoneDrop.hitsPerNode > 0){
                pc.assignedPlayer.TargetHarvestContinous(pc, stoneDrop.gameObject);
            }
            prospectingExp += exp;
            string RareName = "No rare drop";
            float chanceOnRare = arcana/20;
            bool triggeredRare = false;
            if (UnityEngine.Random.Range(0f, 100f) <= chanceOnRare){
                triggeredRare = true;
            }
            if(stoneDrop.GetTier() == 1){
                if(triggeredRare){
                    string[] rareItems = new string[] { "Gem02", "Gem03","Gem05", "Gem01", "Gem04" };
                    // Randomly select an index from the array
                    int randomIndex = UnityEngine.Random.Range(0, rareItems.Length);
                    // Assign the selected item to RareName
                    RareName = rareItems[randomIndex];
                }
                //Amber, ruby, rose quartz, Lapis lazuli, saphhire
                //Amber, ruby, rose quartz, Lapis lazuli, saphhire
                //eyeball, heart
                //Tomato,mushroom
            }
            if(stoneDrop.GetTier() == 2){
                if(triggeredRare){
                    string[] rareItems = new string[] { "Gem02", "Gem03","Gem05", "Gem01", "Gem04" };
                    // Randomly select an index from the array
                    int randomIndex = UnityEngine.Random.Range(0, rareItems.Length);
                    // Assign the selected item to RareName
                    RareName = rareItems[randomIndex];
                }
            }
            if(stoneDrop.GetTier() == 3){
                if(triggeredRare){
                    string[] rareItems = new string[] { "Gem02", "Gem03","Gem05", "Gem01", "Gem04" };
                    // Randomly select an index from the array
                    int randomIndex = UnityEngine.Random.Range(0, rareItems.Length);
                    // Assign the selected item to RareName
                    RareName = rareItems[randomIndex];
                }
            }
            if(stoneDrop.GetTier() == 4){
                if(triggeredRare){
                    string[] rareItems = new string[] { "Gem02", "Gem03","Gem05", "Gem01", "Gem04" };
                    // Randomly select an index from the array
                    int randomIndex = UnityEngine.Random.Range(0, rareItems.Length);
                    // Assign the selected item to RareName
                    RareName = rareItems[randomIndex];
                }
            }
            //stoneDrop.SetOpened();
            (int newLevel, float newExp, bool leveledUp) = CheckForLevelUpSkill(prospectingSkill, prospectingExp, pc.assignedPlayer);
            pc.assignedPlayer.UpdateCharacterSkill(newLevel, newExp, "prospectingSkill", pc.CharID);
            NetworkIdentity networkIdentity = pc.assignedPlayer.GetComponent<NetworkIdentity>();
            NetworkConnectionToClient nconn = networkIdentity.connectionToClient;
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            List<string> items = new List<string>();
            items.Add("Material04");
            if(triggeredRare){
                items.Add(RareName);
                        }
            string energyCostAmount = "-2 energy cost";
            if(leveledUp){
            int energyExpense = newLevel * 5 + 12;
                energyCostAmount = $"-{energyExpense} energy cost";
                energyExpense -= 2;
                pc.assignedPlayer.Energy -= energyExpense;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                CheckForLevelUpTactician(pc.assignedPlayer, energyExpense);
            }
            string _rareNameInput = "No rare drop";
            if(RareName == "Gem01"){
                _rareNameInput = "Lapis Lazuli";
            }
            if(RareName == "Gem02"){
                _rareNameInput = "Amber";
            }
            if(RareName == "Gem03"){
                _rareNameInput = "Ruby";
            }
            if(RareName == "Gem04"){
                _rareNameInput = "Sapphire";
            }
            if(RareName == "Gem05"){
                _rareNameInput = "Rose Quartz";
            }
            pc.TargetUpdateHarvestFinish(true, $"{harvestAmount} stone", energyCostAmount, _rareNameInput);
            foreach(var result in items){
                if(result == "Material04"){
                    TransformItemIntoDragonKill(nconn, playerData, result, pc.CharID, "Plain", harvestAmount, false, false, null, true, pc.assignedPlayer.playerName, false);
                } else {
                    TransformItemIntoDragonKill(nconn, playerData, result, pc.CharID, "Plain", 1, false, false, null, true, pc.assignedPlayer.playerName, false);
                }
            }
                if(!pc.assignedPlayer.GetQuestCompletedFullyList().Contains("Arudine-A2-2")){
                    print("Checking resource count on stone");
                    int resourceCount = 0;
                    foreach(var questInProg in pc.assignedPlayer.GetQuestSavedStatus()){
                        if(questInProg.questID == "Arudine-A2-2"){
                            foreach(var resourceItem in pc.assignedPlayer.GetTacticianSheet().TacticianInventoryData){
                                if(resourceCount >= 6){
                                    break;
                                }
                                if(resourceItem.Value.Deleted || resourceItem.Value.amount == 0){
                                    continue;
                                }
                                if(resourceItem.Value.Item_Name == "Stone"){
                                    resourceCount += resourceItem.Value.amount;
                                    print(resourceCount + " is new resource count for stone");
                                }
                            }
                            foreach(var resourceItem in pc.assignedPlayer.GetTacticianSheet().StashInventoryData){
                                if(resourceCount >= 6){
                                    break;
                                }
                                if(resourceItem.Value.Deleted || resourceItem.Value.amount == 0){
                                    continue;
                                }
                                if(resourceItem.Value.Item_Name == "Stone"){
                                    resourceCount += resourceItem.Value.amount;
                                }
                            }
                            foreach(var sheet in pc.assignedPlayer.GetInformationSheets()){
                                if(resourceCount >= 6){
                                    break;
                                }
                                foreach(var charItem in sheet.CharInventoryData){
                                    if(charItem.Value.Deleted || charItem.Value.amount == 0){
                                        continue;
                                    }
                                    if(charItem.Value.Item_Name == "Stone"){
                                        resourceCount += charItem.Value.amount;
                                        print(resourceCount + " is new resource count for stone");
                                        if(resourceCount >= 6){
                                            break;
                                        }
                                    }
                                }
                            }
                            print(resourceCount + " is new resource count for stone");
                            if(resourceCount >= 6){
                                pc.assignedPlayer.UpdateQuestProgress("Arudine-A2-2", "Gather 6 stone");
                            }
                            break;
                        }
                    }
                }
        #endif

        }
        void GetHarvestDropTree(TreeNodeDrop woodDrop, PlayerCharacter pc){
        #if UNITY_SERVER //|| UNITY_EDITOR

            if(woodDrop == null){
                pc.RpcCancelOnNodeDeath();
                print("node had no more avail slots canceling this");
                return;
            }
            int strength = pc.GetStrength();
            int fortitude = pc.GetFortitude();
            int arcana = pc.GetArcana();
            float exp = 50f;
            float durabilityLossChance = .05f;
            int woodCuttingSkill = 1;
            float woodCuttingExp = 1f;
            int itemCount = 0;
            int harvestAmount = 0;
            print("starting to look for durability loss");
            // If the random number is within the 5% chance, set the boolean to true
            CharacterInventoryListItem damagedItem = (new CharacterInventoryListItem{
                Key = "LuckyRoll"
            });
            print("starting to look for durability loss");
            
                for(int x = 0; x < pc.assignedPlayer.GetInformationSheets().Count; x++){
                    if(pc.assignedPlayer.GetInformationSheets()[x].CharacterID == pc.CharID){
                        woodCuttingSkill = pc.assignedPlayer.GetInformationSheets()[x].woodCuttingSkill;
                        woodCuttingExp = pc.assignedPlayer.GetInformationSheets()[x].woodCuttingExp;
                        float gatheringStaminaCost = 50f * (1f - (woodCuttingSkill/200f) - (fortitude/1000f));
                        pc.ChargeSpellDelay(gatheringStaminaCost);
                        if (UnityEngine.Random.Range(0f, 1f) <= durabilityLossChance)
                        {
                            var validIndices = pc.assignedPlayer.GetInformationSheets()[x].CharInventoryData
                            .Select((item, index) => new { Item = item, Index = index })
                            .Where(x => x.Item.Value.Durability != "0" && x.Item.Value.GetItemName() == "Lumberjack Axe" && !x.Item.Value.Deleted && x.Item.Value.amount != 0)
                            //.Select(x => x.Index)
                            .Select(x => new { 
                                x.Index, 
                                x.Item, 
                                Durability = float.TryParse(x.Item.Value.Durability, out float dura) ? dura : float.MaxValue 
                            })
                            .ToList();
                            if (validIndices.Count > 0) {
                                damagedItem.Key = validIndices.First().Item.Key;
                                damagedItem.Value = validIndices.First().Item.Value;
                                if (damagedItem.Value != null) {
                                    string dura = damagedItem.Value.Durability;
                                    float durability;
                                    if (!float.TryParse(dura, out durability))
                                    {
                                        durability = 100f;
                                    }
                                    durability--;
                                    dura = durability.ToString(); // You should convert the updated float back to a string
                                    damagedItem.Value.Durability = dura;
                                    damagedItem.Value.Changed = true;
                                    print($"{damagedItem.Key} took a durability loss of 1, its durability is now {damagedItem.Value.Durability}");
                                } else {
                                    print("Error: damagedItem.Value is null.");
                                    return;
                                }
                            } else {
                                print("no harvesitng tool!");
                                return;
                            }
                            pc.assignedPlayer.GetCharacterUpdateHarvestDurability(pc.CharID, damagedItem);
                        }
                        break;
                    }

                }
            harvestAmount = CalculateHarvestUnits(woodCuttingSkill, strength);
            if(harvestAmount == 0){
                //we failed
                pc.TargetUpdateHarvestFinish(false, "Failed to harvest item", "-2 energy", "No rare");
                pc.assignedPlayer.Energy -= 2;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                if(woodDrop.hitsPerNode > 0){
                    pc.assignedPlayer.TargetHarvestContinous(pc, woodDrop.gameObject);
                }
                return;
            }
            
            for(int X = 0; X < pc.assignedPlayer.GetInformationSheets().Count; X++){
                if(pc.assignedPlayer.GetInformationSheets()[X].CharacterID == pc.CharID){
                    for(int t = 0; t < pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData.Count; t++){
                        if(pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.Deleted || pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.amount == 0){
                            continue;
                        }
                        if(!pc.assignedPlayer.GetInformationSheets()[X].CharInventoryData[t].Value.EQUIPPED){
                            itemCount ++;
                        }
                    }
                }
            }
            if(itemCount <= 18){
                //can build the rare now lets roll to see if we get
            } else {
                return; //no room
            }
            if(woodDrop.SetOpened()){
                pc.assignedPlayer.Energy -= 2;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                CheckForLevelUpTactician(pc.assignedPlayer, 2);
            } else {
                pc.RpcCancelOnNodeDeath();
                print("node had no more avail slots canceling this");
                return;
            }
            if(woodDrop.hitsPerNode > 0){
                pc.assignedPlayer.TargetHarvestContinous(pc, woodDrop.gameObject);
            }
            woodCuttingExp += exp;
            string RareName = "No rare drop";
            float chanceOnRare = arcana/20;
            bool triggeredRare = false;
            if (UnityEngine.Random.Range(0f, 100f) <= chanceOnRare){
                triggeredRare = true;
            }
            if(woodDrop.GetTier() == 1){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material06";
                    } else {
                        RareName = "Material07";
                    }
                }
                //Amber, ruby, rose quartz, Lapis lazuli, saphhire
                //Amber, ruby, rose quartz, Lapis lazuli, saphhire
                //eyeball, heart
                //Tomato,mushroom
            }
            if(woodDrop.GetTier() == 2){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material06";
                    } else {
                        RareName = "Material07";
                    }
                }
            }
            if(woodDrop.GetTier() == 3){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material06";
                    } else {
                        RareName = "Material07";
                    }
                }
            }
            if(woodDrop.GetTier() == 4){
                if(triggeredRare){
                    if (UnityEngine.Random.Range(0f, 1f) <= .5){
                        RareName = "Material06";
                    } else {
                        RareName = "Material07";
                    }
                }
            }
            (int newLevel, float newExp, bool leveledUp) = CheckForLevelUpSkill(woodCuttingSkill, woodCuttingExp, pc.assignedPlayer);
            pc.assignedPlayer.UpdateCharacterSkill(newLevel, newExp, "woodCuttingSkill", pc.CharID);
            NetworkIdentity networkIdentity = pc.assignedPlayer.GetComponent<NetworkIdentity>();
            NetworkConnectionToClient nconn = networkIdentity.connectionToClient;
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            List<string> items = new List<string>();
            items.Add("Material05");
            if(triggeredRare){
                items.Add(RareName);
            }
            string energyCostAmount = "-2 energy cost";
            if(leveledUp){
                int energyExpense = newLevel * 5 + 12;
                energyCostAmount = $"-{energyExpense} energy cost";
                energyExpense -= 2;
                pc.assignedPlayer.Energy -= energyExpense;
                pc.assignedPlayer.TargetUpdateEnergyDisplay(pc.assignedPlayer.Energy);
                CheckForLevelUpTactician(pc.assignedPlayer, energyExpense);
            }
            string _rareNameInput = "No rare drop";
            if(RareName == "Gem01"){
                _rareNameInput = "Lapis Lazuli";
            }
            if(RareName == "Gem02"){
                _rareNameInput = "Amber";
            }
            if(RareName == "Gem03"){
                _rareNameInput = "Ruby";
            }
            if(RareName == "Gem04"){
                _rareNameInput = "Sapphire";
            }
            if(RareName == "Gem05"){
                _rareNameInput = "Rose Quartz";
            }
            if(RareName == "Material08"){
                _rareNameInput = "Heart";
            }
            if(RareName == "Material09"){
                _rareNameInput = "Eyeball";
            }
            if(RareName == "Material06"){
                _rareNameInput = "Orange";
            }
            if(RareName == "Material07"){
                _rareNameInput = "Cherry";
            }
            if(RareName == "Material10"){
                _rareNameInput = "Tomato";
            }
            if(RareName == "Grown01"){
                _rareNameInput = "Mushroom";
            }
            pc.TargetUpdateHarvestFinish(true, $"{harvestAmount} wood", energyCostAmount, _rareNameInput);
            foreach(var result in items){
                if(result == "Material05"){
                    TransformItemIntoDragonKill(nconn, playerData, result, pc.CharID, "Plain", harvestAmount, false, false, null, true, pc.assignedPlayer.playerName, false);
                } else {
                    TransformItemIntoDragonKill(nconn, playerData, result, pc.CharID, "Plain", 1, false, false, null, true, pc.assignedPlayer.playerName, false);
                }
            }
                if(!pc.assignedPlayer.GetQuestCompletedFullyList().Contains("Arudine-A2-2")){
                    int resourceCount = 0;
                    foreach(var questInProg in pc.assignedPlayer.GetQuestSavedStatus()){
                        if(questInProg.questID == "Arudine-A2-2"){
                            foreach(var resourceItem in pc.assignedPlayer.GetTacticianSheet().TacticianInventoryData){
                                if(resourceCount >= 6){
                                    break;
                                }
                                if(resourceItem.Value.Deleted || resourceItem.Value.amount == 0){
                                    continue;
                                }
                                if(resourceItem.Value.Item_Name == "Wood"){
                                    resourceCount += resourceItem.Value.amount;
                                }
                            }
                            foreach(var resourceItem in pc.assignedPlayer.GetTacticianSheet().StashInventoryData){
                                if(resourceCount >= 6){
                                    break;
                                }
                                if(resourceItem.Value.Deleted || resourceItem.Value.amount == 0){
                                    continue;
                                }
                                if(resourceItem.Value.Item_Name == "Wood"){
                                    resourceCount += resourceItem.Value.amount;
                                }
                            }
                            foreach(var sheet in pc.assignedPlayer.GetInformationSheets()){
                                if(resourceCount >= 6){
                                    break;
                                }
                                foreach(var charItem in sheet.CharInventoryData){
                                    if(charItem.Value.Deleted || charItem.Value.amount == 0){
                                        continue;
                                    }
                                    if(charItem.Value.Item_Name == "Wood"){
                                        resourceCount += charItem.Value.amount;
                                        if(resourceCount >= 6){
                                            break;
                                        }
                                    }
                                }
                            }
                            if(resourceCount >= 6){
                                pc.assignedPlayer.UpdateQuestProgress("Arudine-A2-2", "Gather 6 wood");
                            }
                            break;
                        }
                    }
                }
        #endif

        }
        bool shuttingDown = false;
        void StartServerShutDown(NetworkConnectionToClient nconn){
        #if UNITY_SERVER //|| UNITY_EDITOR
            print("Started StartServerShutDown");
            
            /*
            if(!Local){
                StopCoroutine(HerokuHeartBeat);
                HerokuHeartBeat = null;
                StartCoroutine(UnregisterServerToHeroku());
            }
            */
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            if(sPlayer.GameMaster){
                if (ws != null && ws.IsAlive)
            {
                Debug.Log("Sending periodic message to WebSocket...");
                var data = new
                {
                    buildID = BuildID,
                    sessionID = SessionID,
                    endSession = "true",
                    version = Version,
                    tactician = CONVO_KEY // Add API key for authentication
                };

                //string json = JsonUtility.ToJson(data);
                string json = JsonConvert.SerializeObject(data); // Use JsonConvert instead of JsonUtility
                            Debug.Log("Sending JSON: " + json); // Log the JSON string


                ws.Send(json);
            }
                StartCoroutine(ServerShuttingDownDevCommand());
            }
        #endif

        }
        #if UNITY_SERVER //|| UNITY_EDITOR

        IEnumerator UnregisterServerToHeroku(){
            // Create a JSON object to hold the session ID
    JSONNode json = JSON.Parse("{}");
    json["sessionID"] = SessionID;

    // Convert JSON to string
    string jsonString = json.ToString();

    // Convert string to byte array
    byte[] bodyRaw = System.Text.Encoding.UTF8.GetBytes(jsonString);

    // Create a UnityWebRequest with DELETE method
    UnityWebRequest www = new UnityWebRequest(_Heroku_URL + "/removeServer", UnityWebRequest.kHttpVerbDELETE);

    // Set request headers
    www.SetRequestHeader("Content-Type", "application/json");
    www.SetRequestHeader("x-api-key", CONVO_KEY);

    // Attach body data
    www.uploadHandler = new UploadHandlerRaw(bodyRaw);

    // Send the request
    yield return www.SendWebRequest();

    // Check for errors
    if (www.result == UnityWebRequest.Result.ConnectionError || www.result == UnityWebRequest.Result.ProtocolError)
    {
        Debug.LogError($"Error to unregister game server from Heroku server: {www.error}");
    }
    else
    {
        print($"Our server on build {BuildID} and session {SessionID} is unregistered!");
        // Handle the response if needed
    }
            //WWWForm form = new WWWForm();
            //form.AddField("sessionID", SessionID);
            //using (UnityWebRequest www = UnityWebRequest.Delete(_Heroku_URL + "/removeServer"))
            //{
            //    www.SetRequestHeader("x-api-key", CONVO_KEY);
            //    yield return www.SendWebRequest();
            //    if (www.result == UnityWebRequest.Result.ConnectionError || www.result == UnityWebRequest.Result.ProtocolError)
            //    {
            //        Debug.Log(www.error);
            //    }
            //    else
            //    {
            //        print($"Our server on build {BuildID} and session {SessionID} is unregsitered!");
            //        //ResponseObj response = JsonUtility.FromJson<ResponseObj>(www.downloadHandler.text);
            //        //Debug.Log("Received JSON: " + www.downloadHandler.text);
            //        ////print($"{response.success} was our success bool, {response.message} was our message and {response.details.userId} was our User ID, {response.details.goldAmount} was amount and {response.details.walletAddress} is our address");
            //        //var jsonNode = JSON.Parse(www.downloadHandler.text);
            //    }
            //}
        }
        void OnDestroy(){
            /*
            if(!Local){
                StartCoroutine(UnregisterServerToHeroku());
            }
            */
        }
        #endif

        
        IEnumerator ServerShuttingDownDevCommand(){
            print("Started ServerShuttingDownDevCommand");
            //first tell server to not allow anymore connections to this url
                    yield return new WaitForSeconds(5f); // Wait for 1 minute

            int totalSeconds = 15 * 60; // 15 minutes in seconds
            int secondsLeft = totalSeconds;
                shuttingDown = true;
            while (secondsLeft > 0)
            {
                // Calculate minutes and seconds
                int minutes = secondsLeft / 60;
                int seconds = secondsLeft % 60;
                // Construct the message
                string message = "Shutting server down";
                if (minutes > 1)// || (minutes == 1 && seconds > 0))
                {
                    message = $"[Server] Shutting down server in {minutes} minutes";
                }
                else
                {
                    message = $"[Server] Shutting down server in {seconds} seconds";
                }

                // Send the message to all players
                foreach (var key in playerConnections)
                {
                    if(key == null){
                        continue;
                    }
                    if(key.conn == null){
                        continue;
                    }
                    if(key.conn.identity == null){
                        continue;
                    }
                    if(key.conn.identity.gameObject == null){
                        continue;
                    }
                    ScenePlayer sPlayer = key.conn.identity.gameObject.GetComponent<ScenePlayer>();
                    if(sPlayer){
                        sPlayer.TargetShuttingDownCall(message);
                    }
                }
                // Wait for the next interval
                if (minutes > 1)
                {
                    secondsLeft -= 60; // Decrease by 1 minute
                    yield return new WaitForSeconds(60f); // Wait for 1 minute
                }
                else
                {
                    secondsLeft -= 15; // Decrease by 15 seconds
                    yield return new WaitForSeconds(15f); // Wait for 15 seconds
                }
                
            }
            List<NetworkConnectionToClient> disconnectList = new List<NetworkConnectionToClient>();
            foreach(var key in playerConnections){
                if(key == null){
                        continue;
                    }
                    if(key.conn == null){
                        continue;
                    }
                    PlayerInfo playerData = (PlayerInfo)key.conn.authenticationData;
                    if(DisconnectedList.Contains(playerData.PlayFabId)){
                        continue;
                    }
                    if(ProcessingLogoutList.Contains(playerData.PlayFabId)){
                        continue;
                    }
                    disconnectList.Add(key.conn);
            }
            foreach(var con in disconnectList){
                OnServerDisconnect(con);
            }
            //yield return new WaitForSeconds(300f); // Wait for 15 seconds
            //Application.Quit();
        }
        void StopOperation(NetworkConnectionToClient connection)
        {
            #if UNITY_SERVER //|| UNITY_EDITOR

            if (operations.TryRemove(connection, out var cancellationToken))
            {
                ScenePlayer p = connection.identity.gameObject.GetComponent<ScenePlayer>();
                print($"Stopped operation for {p.playerName} for registration");
                cancellationToken.Cancel();
                cancellationToken.Dispose();
            }
            #endif
        }
        
        void RegisterAccountStart(NetworkConnectionToClient conn){
            #if UNITY_SERVER //|| UNITY_EDITOR

            PlayerInfo playerinfo = (PlayerInfo)conn.authenticationData;
            int tries = 1;
            string pubAddress = "Undefined";
            RegisterAccount(conn, playerinfo.PlayFabId, tries, pubAddress);
            #endif

        }
        void OnEnable(){
#if UNITY_SERVER //|| UNITY_EDITOR

            ScenePlayer.CreateGuild.AddListener(CastGuildBuild);

#endif
            ScenePlayer.SendBackOverflow.AddListener(OverflowItemlooted);
            ScenePlayer.EndDuelServer.AddListener(EndDuel);
            ScenePlayer.RegisterWalletRequest.AddListener(RegisterAccountStart);
            ScenePlayer.CancelRegistration.AddListener(StopOperation);
            ScenePlayer.DevShutingDownServer.AddListener(StartServerShutDown);
            ScenePlayer.GetRandomCost.AddListener(ServerRandomCost);
            ScenePlayer.GameMasterCreateList.AddListener(DEVBUILDITEMREQUESTED);
            ScenePlayer.GameMasterTeleport.AddListener(DEVTELEPORT);
            ScenePlayer.GameMasterHeal.AddListener(DEVHEALTEAM);
            ScenePlayer.GameMasterBreakingPointReleased.AddListener(DEVBREAKINGPOINT);
            ScenePlayer.GameMasterCreateItem.AddListener(BuildGameMasterItemRequest);
            ScenePlayer.GameMasterCreateItemForPlayer.AddListener(BuildItemFromGameMaster);
            ScenePlayer.CraftedItemPermissionToBuild.AddListener(BuildCraftItemCompletedAndClicked);
            ScenePlayer.CraftedItemCancel.AddListener(CancelCraftingBuild);
            ScenePlayer.ServerCraftRequest.AddListener(PermissionToCraft);
            ScenePlayer.DeleteCharacter.AddListener(DeletingACharacterFromPlayer);
            ScenePlayer.PurchaseCharacterToken.AddListener(PurchaseToken);
            ScenePlayer.BuildStackableItem.AddListener(BuildNewStack);
            TurnManager.ProcessMainChest.AddListener(GetMainChestDropTable);
            TurnManager.ProcessMiniChest.AddListener(GetMiniChestDropTable);
            TurnManager.ProcessArmorRack.AddListener(GetArmorRackDropTable);
            TurnManager.ProcessWeaponRack.AddListener(GetWeaponRackDropTable);
            TurnManager.ProcessClothNode.AddListener(GetHarvestDropCloth);
            TurnManager.ProcessLeatherNode.AddListener(GetHarvestDropLeather);
            TurnManager.ProcessOreNode.AddListener(GetHarvestDropOre);
            TurnManager.ProcessStoneNode.AddListener(GetHarvestDropStone);
            TurnManager.ProcessWoodNode.AddListener(GetHarvestDropTree);
            TurnManager.LevelUpCheck.AddListener(CheckForLevelUpTactician);

            VoteManager.BuildItemServer.AddListener(BuildItemDropped);
            MatchMaker.EnterNodeCost.AddListener(AuthorizeEnergyUpdate);
            //MatchMaker.SendCuratorTMToPlayer.AddListener(SendTurnManagerToPlayerCharacter);
            //MatchMaker.MakeCharacters.AddListener(SendPCToMatch);
            MatchMaker.MoveChatNodeTOWNOFARUDINE.AddListener(ChatManagerNodeTOWNOFARUDINETransport);
            MatchMaker.MoveChatNodeOVM.AddListener(ChatManagerNodeOVMTransport);
            MatchMaker.CLEARTHEMATCH.AddListener(ClearMatch);
            MatchMaker.moveTurnManager.AddListener(SendTurnManagerToMatch);
            MatchMaker.moveChatManagerNode.AddListener(SendChatManagerNodeToMatch);
            MatchMaker.moveMob.AddListener(SendMobToMatch);
            //Finished Match
            ScenePlayer.PermissionToFinish.AddListener(FinishingMatch);
            TurnManager.Evacuating.AddListener(EvacuateMatch);
            ScenePlayer.PermissionToFinishSewers.AddListener(FinishSewersMatch);

            
            //Drop calls
            TurnManager.RetrievingDroppedItem.AddListener(GetDropTable);
            TurnManager.ProcessEXPandCP.AddListener(GiveExpClassPoints);
            //Spell manipulation
            ScenePlayer.SpellPurchase.AddListener(PlayerRequestedLearnSpell);
            ScenePlayer.SpellChange.AddListener(PlayerRequestedSpellChange);
            //info calls
            ScenePlayer.GetPlayerInfo.AddListener(NonCombatTargetInfoCheck);//do the check for health percentage
            
            //Movement request
            //ScenePlayer.FinalRequest.AddListener(AuthorizeMovementRequest);
            ScenePlayer.ResetOVM.AddListener(UpdatePlayerOVMPosition);
            //BuildCharacter request
            ScenePlayer.ServerCharacterBuildRequest.AddListener(CharacterCreation);
            ScenePlayer.ServerWyvernHatch.AddListener(OpenWyvernEgg);
            //Party Requests
            ScenePlayer.SendParty.AddListener(SavePartyListAdding);
            ScenePlayer.PartyRemoval.AddListener(SavePartyListRemoving);
            ScenePlayer.ServerTransmitTX.AddListener(PurchasedVendorItem);
            //StashToTactician
            ScenePlayer.StashToTactInv.AddListener(AuthenticateThenSavePF);//completed
            ScenePlayer.StashToTactSafetyBelt.AddListener(AuthenticateThenSavePF);//completed
            ScenePlayer.StashToTactEquipped.AddListener(AuthenticateThenSavePFEquip);//completed
            //StashToCharacter
            ScenePlayer.StashToCharInv.AddListener(AuthenticateThenSavePFCharacters);//completed
            ScenePlayer.StashToCharEquip.AddListener(AuthenticateThenSavePFCharactersEquip);//completed
            //TacticianToStash
            ScenePlayer.TactInvToStash.AddListener(AuthenticateThenSavePF);//completed
            ScenePlayer.TactEquipToStash.AddListener(AuthenticateThenSavePF);//completed
            ScenePlayer.TactBeltToStash.AddListener(AuthenticateThenSavePF);//completed
            //TacticianToTactician
            ScenePlayer.TactEquipToTactInv.AddListener(AuthenticateThenSavePF);//completed
            ScenePlayer.TactEquipToTactBelt.AddListener(AuthenticateThenSavePF);//completed
            ScenePlayer.TactInvToTactEquip.AddListener(AuthenticateThenSavePFEquip);//completed
            ScenePlayer.TactInvToTactBelt.AddListener(AuthenticateThenSavePF);//completed
            ScenePlayer.TactBeltToTactEquip.AddListener(AuthenticateThenSavePFEquip);//completed
            ScenePlayer.TactBeltToTactInv.AddListener(AuthenticateThenSavePF);//completed
            //TacticianToChars
            ScenePlayer.TactInvToCharInv.AddListener(AuthenticateThenSavePFCharacters);//completed
            ScenePlayer.TactInvToCharEquip.AddListener(AuthenticateThenSavePFCharactersEquip);//completed
            ScenePlayer.TactSafetyBeltToCharEquip.AddListener(AuthenticateThenSavePFCharactersEquip);//completed
            ScenePlayer.TactSafetyBeltToCharInv.AddListener(AuthenticateThenSavePFCharacters);//completed 
            ScenePlayer.TactEquipToCharInv.AddListener(AuthenticateThenSavePFCharacters);//completed
            //CharacterToTactician
            ScenePlayer.CharInvToTactInv.AddListener(AuthenticateThenSavePFCharacters);//completed
            ScenePlayer.CharInvToTactBelt.AddListener(AuthenticateThenSavePFCharacters);//completed
            ScenePlayer.CharInvToTactEquip.AddListener(AuthenticateThenSavePFCharactersEquip);//completed
            ScenePlayer.CharEquipToTactInv.AddListener(AuthenticateThenSavePFCharacters);//completed
            ScenePlayer.CharEquipToTactBelt.AddListener(AuthenticateThenSavePFCharacters);//completed
            //CharacterToCharacter
            //These require a swap to user then back to the character
            ScenePlayer.CharInvToCharInv.AddListener(AuthenticateThenSavePFCharactersEquip);//completed
            ScenePlayer.CharInvToCharEquip.AddListener(AuthenticateThenSavePFCharactersEquip);//completed
            ScenePlayer.CharEquipToCharInv.AddListener(AuthenticateThenSavePFCharactersEquip);//completed
            ScenePlayer.CharEquipToCharEquip.AddListener(AuthenticateThenSavePFCharactersEquip);//completed
            ScenePlayer.CharEquipToEquipSame.AddListener(AuthenticateThenSavePFCharactersEquip);//completed
            ScenePlayer.CharEquipToInvSame.AddListener(AuthenticateThenSavePFCharactersEquip);//completed
            ScenePlayer.CharInvToEquipSame.AddListener(AuthenticateThenSavePFCharactersEquip);//completed
            ScenePlayer.CharOneUnequipToCharEquip.AddListener(AuthenticateThenSavePFCharactersSwap);
            ScenePlayer.CharTwoUnequipToCharEquip.AddListener(AuthenticateThenSavePFCharactersSwap);

            ScenePlayer.CharOneUnequipToCharEquipSendTwo.AddListener(AuthenticateThenSavePFCharactersSwap);
            ScenePlayer.CharTwoUnequipToCharEquipSendOne.AddListener(AuthenticateThenSavePFCharactersSwap);

            ScenePlayer.CharUnequipTactToCharEquip.AddListener(AuthenticateDropBox);
            //CharacterToStash
            ScenePlayer.CharInvToStash.AddListener(AuthenticateThenSavePFCharacters);//completed
            ScenePlayer.CharEquipToStash.AddListener(AuthenticateThenSavePFCharacters);//completed
            ScenePlayer.OnPlayerDataUpdateRequest.AddListener(UpdatePlayerData);
            ScenePlayer.LevelUpEnded.AddListener(LevelUpEnding);
            ScenePlayer.LevelUpStarted.AddListener(LevelUpStarting);
            ScenePlayer.StackingItem.AddListener(StackingItem);
            ScenePlayer.ServerDestroyItem.AddListener(RemoveThisItem);
            ScenePlayer.ServerConsumingItemFullyEvent.AddListener(ConsumeItemFully);
            ScenePlayer.ServerConsumingItemPartiallyEvent.AddListener(ConsumeItemPartially);

            ScenePlayer.SalvageRefundItemList.AddListener(RefundSalvage);
            ScenePlayer.HealPartyServer.AddListener(ServerINNRoomRest);
            ScenePlayer.QuestCompleteRewardAccess.AddListener(RewardingPlayerForQuest);
            ScenePlayer.ResCharacter.AddListener(ResCharacterServer);
            TurnManager.ResCharacter.AddListener(RessurectedCharacterCombat);
            ScenePlayer.LogoutPlayer.AddListener(OnServerDisconnect);
            MovingObject.TakeDamageCharacter.AddListener(CharacterTakingDamage);
            MovingObject.DeathCharacter.AddListener(CharacterDied);
            PlayerCharacter.SaveCharacter.AddListener(SaveGame);
            PlayerCharacter.TrapMP.AddListener(CharacterCastedSpell);
            TurnManager.HealingCharacter.AddListener(CharacterHealed);
            TurnManager.SpendingMP.AddListener(CharacterCastedSpell);
            TurnManager.FullWipe.AddListener(WipeoutMatch);
            MatchMaker.FullWipe.AddListener(WipeoutMatch);
            ScenePlayer.RepairAllItemsEVENT.AddListener(SentRepairAll);
            ScenePlayer.RepairSingleItemEVENT.AddListener(SentRepairSingle);

            //interactive calls

            //trade calls
            ScenePlayer.RequestedTrade.AddListener(RequestTrade);//do the check for health percentage
            ScenePlayer.TradeItemsSet.AddListener(UpdateTradeItems);
            ScenePlayer.TradeGoldSet.AddListener(UpdateTradeGoldValue);//do the check for health percentage
            ScenePlayer.TradeFinalRequest.AddListener(AcceptTrade);//do the check for health percentage
            ScenePlayer.CancelTradeCompletely.AddListener(CancelTrade);//do the check for health percentage
            ScenePlayer.TradeCancelKeepOpen.AddListener(CancelTradeButKeep);//do the check for health percentage
            ScenePlayer.TradeConfirm.AddListener(ConfirmedTrade);

            //challenge calls
            ScenePlayer.requestChallengeServer.AddListener(RequestChallenge);
            ScenePlayer.requestInspectServer.AddListener(RequestInspect);
            ScenePlayer.decisionChallengeServer.AddListener(AcceptedChallenge);
            ScenePlayer.cancelChallengeRequestServer.AddListener(CancelledChallenge);

	//public static event Action<NetworkConnectionToClient, int, string> SpendingMP;
            
        }

        private List<TradeSession> activeTrades = new List<TradeSession>();
        [Server]
        public void StartTrade(ScenePlayer initiator, ScenePlayer target)
        {
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(target.inLobby){
                initiator.ServerDenyTradeRequest(1);
            }
            bool initiatorInTrade = false;
            bool targetInTrade = false;
            for(int i = 0; i < activeTrades.Count; i++){
                if(activeTrades[i].PlayerOne == target || activeTrades[i].PlayerTwo == target){
                    targetInTrade = true;
                }
                if(activeTrades[i].PlayerOne == initiator || activeTrades[i].PlayerTwo == initiator){
                    initiatorInTrade = true;
                }
                if(initiatorInTrade && targetInTrade){
                    break;
                }
            }
            if(targetInTrade){
                initiator.ServerDenyTradeRequest(1);
                return;
            }
            if(initiatorInTrade){
                initiator.ServerDenyTradeRequest(2);
                return;
            }
            var session = new TradeSession(initiator, target);
            activeTrades.Add(session);
            //trade began but we arent ready to send the ServerAcceptTradeStart yet because one it sends botht he confirmation which is bad and two it needs to wait for confirmation now

            //initiator.ServerAcceptTradeStart(target);
            target.ServerAskToConfirmTrade(initiator);
            #endif
        }
        [Server]
        public void ConfirmedTrade(ScenePlayer playerBeingAsked, bool confirmation)
        {
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!confirmation){
                CancelTrade(playerBeingAsked);
                return;
            }
            for(int i = 0; i < activeTrades.Count; i++){

                if(activeTrades[i].PlayerOne == playerBeingAsked){
                    activeTrades[i].PlayerTwo.ServerAcceptTradeStart(playerBeingAsked);
                }
                if(activeTrades[i].PlayerTwo == playerBeingAsked){
                    activeTrades[i].PlayerOne.ServerAcceptTradeStart(playerBeingAsked);
                    
                }
            }
            #endif
        }
        [Server]
        public void UpdateTradeItems(ScenePlayer player, List<ItemSelectable> items)
        {
            #if UNITY_SERVER //|| UNITY_EDITOR

            for(int i = 0; i < activeTrades.Count; i++){
                if(activeTrades[i].PlayerOne == player || activeTrades[i].PlayerTwo == player){
                    activeTrades[i].UpdateTrade(player, items);
                    if(activeTrades[i].PlayerOne == player )
                    {
                        activeTrades[i].PlayerTwo.ServerSetPartnerItems(items);
                        //print($"UpdateTradeItems player one {player.playerName} is offering {goldAmount}");
                    }  
                    if(activeTrades[i].PlayerTwo == player )
                    {
                        activeTrades[i].PlayerOne.ServerSetPartnerItems(items);
                        //print($"UpdateTradeItems player two {player.playerName} is offering {goldAmount}");
                    }                    
                    break;
                }
            }
            #endif
        }
        [Server]
        void UpdateTradeGoldValue(ScenePlayer player, string goldAmount)
        {
            #if UNITY_SERVER //|| UNITY_EDITOR

            print($"UpdateTradeGoldValue player {player.playerName} is offering {goldAmount}");

            for(int i = 0; i < activeTrades.Count; i++){
                if(activeTrades[i].PlayerOne == player || activeTrades[i].PlayerTwo == player){
                    activeTrades[i].UpdateGold(player, goldAmount);
                    print($"UpdateGold player one is offering {activeTrades[i].PlayerOneGoldAmount} player two is offering {activeTrades[i].PlayerTwoGoldAmount}");
                    if(player == activeTrades[i].PlayerOne){
                        //player one 
                        activeTrades[i].PlayerTwo.ServerSetGoldTradeValueFromPlayer(player, goldAmount);
                    } else {
                        //player two 
                        activeTrades[i].PlayerOne.ServerSetGoldTradeValueFromPlayer(player, goldAmount);
                    }
                    break;
                }
            }
            #endif
        }
        [Server]
        void CancelTrade(ScenePlayer cancelingPlayer)
        {
            #if UNITY_SERVER //|| UNITY_EDITOR

            for(int i = 0; i < activeTrades.Count; i++){
                if(activeTrades[i].PlayerOne == cancelingPlayer || activeTrades[i].PlayerTwo == cancelingPlayer){
                    if(cancelingPlayer == activeTrades[i].PlayerOne){
                        activeTrades[i].PlayerTwo.ServerCancelTradeCompletely();
                    } else {
                        activeTrades[i].PlayerOne.ServerCancelTradeCompletely();
                    }
                    activeTrades.Remove(activeTrades[i]);
                    break;
                }
            }
            #endif
        }
        [Server]
        void CancelTradeButKeep(ScenePlayer cancelingPlayer)
        {
            #if UNITY_SERVER //|| UNITY_EDITOR

            for(int i = 0; i < activeTrades.Count; i++){
                if(activeTrades[i].PlayerOne == cancelingPlayer || activeTrades[i].PlayerTwo == cancelingPlayer){
                    activeTrades[i].CancelButKeepOpen();
                    activeTrades[i].PlayerTwo.ServerCancelTradePartially();
                    activeTrades[i].PlayerOne.ServerCancelTradePartially();
                    break;
                }
            }
            #endif
        }
        [Server]
        void AcceptTrade(ScenePlayer player)
        {
            #if UNITY_SERVER //|| UNITY_EDITOR

            
            ScenePlayer playerOne;
            ScenePlayer playerTwo;
            List<ItemSelectable> playerOneItemsOffered = new List<ItemSelectable>();
            List<ItemSelectable> playerTwoItemsOffered = new List<ItemSelectable>();
            string playerOneGoldOffered = "0";
            string playerTwoGoldOffered = "0";
            print($"Part one accept trade");
            for(int i = 0; i < activeTrades.Count; i++){
                if(activeTrades[i].PlayerOne == player || activeTrades[i].PlayerTwo == player){
                    activeTrades[i].PlayerAcceptsTrade(player);
                    if (activeTrades[i].AttemptFinalizeTrade())
                    {
                        // Handle trade completion
                        playerOne = activeTrades[i].PlayerOne;
                        playerOneItemsOffered = activeTrades[i].PlayerOneItemsOffered;
                        playerOneGoldOffered = activeTrades[i].PlayerOneGoldAmount;
                        playerTwo = activeTrades[i].PlayerTwo;
                        playerTwoItemsOffered = activeTrades[i].PlayerTwoItemsOffered;
                        playerTwoGoldOffered = activeTrades[i].PlayerTwoGoldAmount;
                        NetworkConnectionToClient connectionToClientOne = playerOne.GetConnection();
                        NetworkConnectionToClient connectionToClientTwo = playerTwo.GetConnection();
                        if(playerOne == null){
                            return;
                        }
                        if(playerTwo == null){
                            return;
                        }
                        print($"Part two accept trade");

                        //remove items from player One
                        if(playerOneItemsOffered.Count > 0){
                            for(int e = 0; e < playerOneItemsOffered.Count; e++){
                                // is how we call RemoveThisItem
                                ItemSelectable removeThisitem = null;
                                string serial = "Tactician";
                                //check stashes
                                bool foundItem = false;
                                for(int s = 0; s < playerOne.GetTacticianSheet().StashInventoryData.Count; s++){
                                    if(playerOne.GetTacticianSheet().StashInventoryData[s].Value.customID == playerOneItemsOffered[e].customID){
                                        removeThisitem = playerOne.GetTacticianSheet().StashInventoryData[s].Value;
                                        serial = "Stash";
                                        foundItem = true;
                                        break;
                                    }
                                }
                                //check tactician inv
                                for(int s = 0; s < playerOne.GetTacticianSheet().TacticianInventoryData.Count; s++){
                                    if(foundItem){
                                        break;
                                    }
                                    if(playerOne.GetTacticianSheet().TacticianInventoryData[s].Value.customID == playerOneItemsOffered[e].customID){
                                        removeThisitem = playerOne.GetTacticianSheet().TacticianInventoryData[s].Value;
                                        serial = "Tactician";
                                        foundItem = true;
                                        break;
                                    }
                                }
                                for(int s = 0; s < playerOne.GetInformationSheets().Count; s++){
                                    if(foundItem){
                                        break;
                                    }
                                    for(int v = 0; v < playerOne.GetInformationSheets()[s].CharInventoryData.Count; v++){
                                        if(playerOne.GetInformationSheets()[s].CharInventoryData[v].Value.customID == playerOneItemsOffered[e].customID){
                                            removeThisitem = playerOne.GetInformationSheets()[s].CharInventoryData[v].Value;
                                            serial = playerOne.GetInformationSheets()[s].CharacterID;
                                            foundItem = true;
                                            break;
                                        }
                                    }
                                }
                                //check char sheets inv
                                if(removeThisitem != null){
                                    RemoveThisItem(connectionToClientOne, removeThisitem, serial);
                                }
                            }
                        }
                        
                        print($"Part three accept trade");
                        if(playerTwoItemsOffered.Count > 0){
                            for(int p = 0; p < playerTwoItemsOffered.Count; p++){
                                ItemSelectable removeThisitem = null;
                                string serial = "Tactician";
                                //check stashes
                                bool foundItem = false;
                                for(int s = 0; s < playerTwo.GetTacticianSheet().StashInventoryData.Count; s++){
                                    if(playerTwo.GetTacticianSheet().StashInventoryData[s].Value.customID == playerTwoItemsOffered[p].customID){
                                        removeThisitem = playerTwo.GetTacticianSheet().StashInventoryData[s].Value;
                                        serial = "Stash";
                                        foundItem = true;
                                        break;
                                    }
                                }
                                //check tactician inv
                                for(int s = 0; s < playerTwo.GetTacticianSheet().TacticianInventoryData.Count; s++){
                                    if(foundItem){
                                        break;
                                    }
                                    if(playerTwo.GetTacticianSheet().TacticianInventoryData[s].Value.customID == playerTwoItemsOffered[p].customID){
                                        removeThisitem = playerTwo.GetTacticianSheet().TacticianInventoryData[s].Value;
                                        serial = "Tactician";
                                        foundItem = true;
                                        break;
                                    }
                                }
                                for(int s = 0; s < playerTwo.GetInformationSheets().Count; s++){
                                    if(foundItem){
                                        break;
                                    }
                                    for(int v = 0; v < playerTwo.GetInformationSheets()[s].CharInventoryData.Count; v++){
                                        if(playerTwo.GetInformationSheets()[s].CharInventoryData[v].Value.customID == playerTwoItemsOffered[p].customID){
                                            removeThisitem = playerTwo.GetInformationSheets()[s].CharInventoryData[v].Value;
                                            serial = playerTwo.GetInformationSheets()[s].CharacterID;
                                            foundItem = true;
                                            break;
                                        }
                                    }
                                }
                                //check char sheets inv
                                if(removeThisitem != null){
                                    RemoveThisItem(connectionToClientTwo, removeThisitem, serial);
                                }
                            }
                        }
                        print($"Part four accept trade");

                        if(playerOneGoldOffered != "0"){
                            if (long.TryParse(playerOneGoldOffered, out long value))
                            {
                                if(playerOne.Gold < value){
                                    //no good
                                print($"Error on giving gold amount {playerOneGoldOffered} from {playerOne.playerName} to {playerTwo.playerName}  not enough gold");

                                } else {
                                    playerOne.Gold -= value;
                                    playerOne.ServerRefreshWallet();
                                    playerTwo.Gold += value;
                                    playerTwo.ServerRefreshWallet();
                                }
                            } else {
                                print($"Error on giving gold amount {playerOneGoldOffered} from {playerOne.playerName} to {playerTwo.playerName} bad parse!");
                            }
                        }
                        print($"Part five accept trade");

                        if(playerTwoGoldOffered != "0"){
                            if (long.TryParse(playerTwoGoldOffered, out long value))
                            {
                                if(playerTwo.Gold < value){
                                    //no good
                                print($"Error on giving gold amount {playerTwoGoldOffered} from {playerTwo.playerName} to {playerOne.playerName}  not enough gold");

                                } else {
                                    playerOne.Gold += value;
                                    playerOne.ServerRefreshWallet();
                                    playerTwo.Gold -= value;
                                    playerTwo.ServerRefreshWallet();
                                }
                            } else {
                                print($"Error on giving gold amount {playerTwoGoldOffered} from {playerTwo.playerName} to {playerOne.playerName}  bad parse!");
                            }
                        }
                        print($"Part six accept trade");

                        //now we need to add the items to the account lets get here after gold is verified

                        //DEVBUILDINGITEMSCOROUTINE
                        // reference that to build the new items on the clients
                        
                        //Lets tell them to ungreen now and reset the amounts to 0
                        activeTrades[i].CancelButKeepOpen();
                        activeTrades[i].PlayerOne.ServerCompletedTradeResetWindows();
                        activeTrades[i].PlayerTwo.ServerCompletedTradeResetWindows();
                        PlayerInfo playerDataOne = (PlayerInfo)connectionToClientOne.authenticationData;
                        PlayerInfo playerDataTwo = (PlayerInfo)connectionToClientTwo.authenticationData;
                        foreach(var itemTwoOfferedUp in playerTwoItemsOffered){
                            TransformItemIntoDragonKill(connectionToClientOne, playerDataOne, itemTwoOfferedUp.GetItemID(), TACTICIAN, itemTwoOfferedUp.GetQuality(), itemTwoOfferedUp.GetAmount(), false, false, null, false, itemTwoOfferedUp.Engraving, true);
                        }
                        foreach(var itemOneOfferedUp in playerOneItemsOffered){
                            TransformItemIntoDragonKill(connectionToClientTwo, playerDataTwo, itemOneOfferedUp.GetItemID(), TACTICIAN, itemOneOfferedUp.GetQuality(), itemOneOfferedUp.GetAmount(), false, false, null, false, itemOneOfferedUp.Engraving, true);
                        }
                        //if(activeTrades.Contains(activeTrades[i])){
                        //    activeTrades.Remove(activeTrades[i]);
                        //}
                    } else {
                        if(player == activeTrades[i].PlayerOne){
                            //player one 
                            activeTrades[i].PlayerTwo.ServerTradeParterAccept();
                        } else {
                            //player two 
                            activeTrades[i].PlayerOne.ServerTradeParterAccept();
                        }
                    }
                    break;
                }
            }
            
            #endif
        }
        void RequestTrade(ScenePlayer targetPlayer, ScenePlayer returningPlayer){
            #if UNITY_SERVER //|| UNITY_EDITOR

            if(targetPlayer.TradesAcceptedCheck()){
                StartTrade(returningPlayer, targetPlayer);
            } else {
                returningPlayer.ServerCancelTradeCompletelyCannotTrade();
                //reject the trade
            }
            #endif
        }
        void RequestChallenge(ScenePlayer returningPlayer, ScenePlayer targetPlayer){
            #if UNITY_SERVER //|| UNITY_EDITOR

            if(targetPlayer.ChallengesAcceptedCheck()){
                targetPlayer.TargetAskChallenge(returningPlayer);
            } else {
                returningPlayer.TargetDeniedResponse();
                //returningPlayer.ServerCancelTradeCompletelyCannotTrade();
                //reject the Challenge
            }
            #endif
        }
        void AcceptedChallenge(ScenePlayer returningPlayer, ScenePlayer targetPlayer, bool accepted){
            if(accepted){
                targetPlayer.ServerStartArenaDuel(returningPlayer); //do this last
            } else {

                returningPlayer.TargetDeniedResponse();
                //reject Challenge
            }
        }
        void CancelledChallenge(ScenePlayer challengedPlayer, ScenePlayer targetPlayer){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(challengedPlayer.ChallengesAcceptedCheck()){
                challengedPlayer.TargetDeniedResponse();
            }
            targetPlayer.TargetDeniedResponse();
            #endif
        }
        void RequestInspect(ScenePlayer returningPlayer, ScenePlayer targetPlayer){
            #if UNITY_SERVER //|| UNITY_EDITOR

            if(targetPlayer.InspectsAcceptedCheck()){
                //returningPlayer.TargetReceiveCustomInspect();
            } else {
                //reject the Inspect
            }
            #endif
        }
        void NonCombatTargetInfoCheck(ScenePlayer targetPlayer, ScenePlayer returningPlayer){
            #if UNITY_SERVER //|| UNITY_EDITOR

            float healthPercentage = 0;
            float manaPercentage = 0;
            int tactFortBonus = 0;
            int tactArcanaBonus = 0;
            if(int.TryParse(targetPlayer.GetTacticianSheet().FortitudeBonus, out int parsedFortBonus)){
                tactFortBonus += parsedFortBonus;
            }
            if(int.TryParse(targetPlayer.GetTacticianSheet().ArcanaBonus, out int parsedArcanaBonus)){
                tactArcanaBonus += parsedArcanaBonus;
            }
            for(int i = 0; i < targetPlayer.GetTacticianSheet().TacticianInventoryData.Count; i++){
                if(targetPlayer.GetTacticianSheet().TacticianInventoryData[i].Value.Deleted || targetPlayer.GetTacticianSheet().TacticianInventoryData[i].Value.amount == 0){
                    continue;
                }
                if(targetPlayer.GetTacticianSheet().TacticianInventoryData[i].Value.EQUIPPED){
                    if (!string.IsNullOrEmpty(targetPlayer.GetTacticianSheet().TacticianInventoryData[i].Value.FORTITUDE_item)) {
                        if (int.Parse(targetPlayer.GetTacticianSheet().TacticianInventoryData[i].Value.FORTITUDE_item) > 0) {
                            tactFortBonus += int.Parse(targetPlayer.GetTacticianSheet().TacticianInventoryData[i].Value.FORTITUDE_item);
                        }
                    }
                    if (!string.IsNullOrEmpty(targetPlayer.GetTacticianSheet().TacticianInventoryData[i].Value.ARCANA_item)) {
                        if (int.Parse(targetPlayer.GetTacticianSheet().TacticianInventoryData[i].Value.ARCANA_item) > 0) {
                            tactArcanaBonus += int.Parse(targetPlayer.GetTacticianSheet().TacticianInventoryData[i].Value.ARCANA_item);
                        }
                    }
                }
            }
            if(targetPlayer.GetParty().Count != 0){
             foreach(var member in targetPlayer.GetParty()){
                foreach(var sheet in targetPlayer.GetInformationSheets()){
                    if(sheet.CharacterID == member){
                        bool healthFound = false;
                        bool manaFound = false;
                        bool lvlFound = false;
                        bool classFound = false;
                        bool coreFound = false;

                        float health = 1;
                        float mana = 1;
                        int _level = 1;
                        string _core = "STANDARD";
                        string _class = string.Empty;
                        foreach(var stat in sheet.CharStatData){
                            if(healthFound && manaFound && lvlFound && classFound && coreFound){
                                break;
                            }
                            if(stat.Key == "currentHP"){
                                if(float.TryParse(stat.Value, out float parsedHealth)){
                                    health = parsedHealth;
                                }
                                healthFound = true;
                            }
                            if(stat.Key == "currentMP"){
                                 if(float.TryParse(stat.Value, out float parsedMana)){
                                    mana = parsedMana;
                                }
                                manaFound = true;
                            }
                            if (stat.Key == "Class") {
                                _class = stat.Value;
                                classFound = true;
                            }
                            if (stat.Key == "LVL") {
                                _level = int.Parse(stat.Value);
                                lvlFound = true;
                            }
                            if (stat.Key == "CORE") {
                                _core = stat.Value;
                                coreFound = true;
                            }
                        }
                        int equipHP = 0;
                        int equipArcana = 0;
                        var charInventoryDataList = sheet.CharInventoryData;
                        for (int k = 0; k < charInventoryDataList.Count; k++) {
                            var charItem = charInventoryDataList[k];
                            if (charItem.Value.EQUIPPED) {
                                if (!string.IsNullOrEmpty(charItem.Value.FORTITUDE_item)) {
                                    if (int.Parse(charItem.Value.FORTITUDE_item) > 0) {
                                        equipHP += int.Parse(charItem.Value.FORTITUDE_item);
                                    }
                                }
                                if (!string.IsNullOrEmpty(charItem.Value.ARCANA_item)) {
                                    if (int.Parse(charItem.Value.ARCANA_item) > 0) {
                                        equipArcana += int.Parse(charItem.Value.ARCANA_item);
                                    }
                                }
                            }
                        }
        int PASSIVE_Arcana = 0;
        int PASSIVE_Fortitude = 0;
        for(int _char = 0; _char < targetPlayer.GetInformationSheets().Count; _char++){
            if(targetPlayer.GetInformationSheets()[_char].CharacterID == member){
                for(int ability = 0; ability < targetPlayer.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                    if(targetPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(targetPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                        if (abilityRankString.Success) {
                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                            PASSIVE_Fortitude = abilityRank;
                        }
                    }
                    if(targetPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(targetPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                        if (abilityRankString.Success) {
                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                            PASSIVE_Arcana = abilityRank;
                        }
                    }
                }
                break;
            }
        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        float maxHP = equipHP + baseFortitude + tactFortBonus + PASSIVE_Fortitude;
                        float maxMP = (equipArcana + baseArcana + tactArcanaBonus + PASSIVE_Arcana) / 7;
                        //Get max HP and MP then divide the current by max
                        health /= maxHP;
                        mana /= maxMP;
                        healthPercentage += health;
                        manaPercentage += mana;
                        break;
                    }
                }
            }
            healthPercentage /= targetPlayer.GetParty().Count;
            manaPercentage /= targetPlayer.GetParty().Count;
            } else {
                healthPercentage = 0f;
                manaPercentage = 0f;
            }
            returningPlayer.ServerFinalTargetReturn(targetPlayer, healthPercentage, manaPercentage);
            #endif
        }
        void SentRepairAll(NetworkConnectionToClient connectionToClient){
            if(!CheckNullConnection(connectionToClient)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED SentRepairAll");
            print("Starting SentRepairAll");
            ScenePlayer sPlayer = connectionToClient.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            int totalRepairCost = 0;
            Dictionary<CharacterInventoryListItem, string> repairDictionary = new Dictionary<CharacterInventoryListItem, string>();
            foreach(var tactItem in sPlayer.GetTacticianSheet().TacticianInventoryData){
                if(tactItem.Value.Deleted || tactItem.Value.amount == 0 || tactItem.Value.Durability == "None" || string.IsNullOrEmpty(tactItem.Value.Durability) || tactItem.Value.NFT){
                    continue;
                }
                if(int.Parse(tactItem.Value.Durability) < 100){
                    int durabilityRemaining = int.Parse(tactItem.Value.Durability);
                    int durabilityLost = 100 - durabilityRemaining;
                    int tier = ItemDataStorage.Instance.ReturnTier(tactItem.Value.Item_Name);
                    int goldCost = tier * durabilityLost;
                    totalRepairCost += goldCost;
                    repairDictionary.Add(tactItem, "Tactician");
                    //repairitemprefab code here
                }
            }
            foreach(var sheet in sPlayer.GetInformationSheets()){
                foreach(var charItem in sheet.CharInventoryData){
                    if(charItem.Value.Deleted || charItem.Value.amount == 0 || charItem.Value.Durability == "None" || string.IsNullOrEmpty(charItem.Value.Durability) || charItem.Value.NFT){
                        continue;
                    }
                    if(int.Parse(charItem.Value.Durability) < 100){
                        int durabilityRemaining = int.Parse(charItem.Value.Durability);
                        int durabilityLost = 100 - durabilityRemaining;
                        int tier = ItemDataStorage.Instance.ReturnTier(charItem.Value.Item_Name);
                        int goldCost = tier * durabilityLost;
                        totalRepairCost += goldCost;
                        repairDictionary.Add(charItem, sheet.CharacterID);

                        //repairitemprefab code here
                    }
                }
            }
            if(sPlayer.Gold < totalRepairCost){
                return;
            }
            sPlayer.Gold -= totalRepairCost;
            
            // Extract keys into a list
            List<string> values = new List<string>(repairDictionary.Values);
            List<CharacterInventoryListItem> keys = new List<CharacterInventoryListItem>(repairDictionary.Keys);
            Dictionary<CharacterInventoryListItem, string> repairDictionaryUpdated = new Dictionary<CharacterInventoryListItem, string>();
            print("Starting repairDictionaryUpdated");

            // Iterate over the list of keys
            for (int p = 0; p < keys.Count; p++)
            {
                CharacterInventoryListItem key = keys[p];
                print("Fixing " + key.Value.Item_Name);
                key.Value.Durability = "100";
                key.Value.Changed = true;

                // Add the updated key and its value to the new dictionary
                repairDictionaryUpdated.Add(key, repairDictionary[key]);
            }
            foreach(var repairItem in repairDictionaryUpdated){
                print("Repairing " + repairItem.Key.Value.Item_Name);
                sPlayer.ServerRepairItem(repairItem.Value, repairItem.Key);
            }
            sPlayer.TargetRepairedAll();
            //sPlayer.ServerRepairItem(charID, repairingItem);

            //check gold, remove gold, find all repairable items and send to the repair method in sceneplayer
        }
        void SentRepairSingle(NetworkConnectionToClient connectionToClient, ItemSelectable item){
            print($"Starting SentRepairSingle");
            if(!CheckNullConnection(connectionToClient)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED SentRepairSingle on item: {item.GetItemName()}");
            ScenePlayer sPlayer = connectionToClient.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterInventoryListItem repairingItem = (new CharacterInventoryListItem{
                Key = item.InstanceID,
                Value = item
            });
            repairingItem.Value.Durability = "100";
            repairingItem.Value.Changed = true;
            string repairItemID = item.customID;
            string charID = string.Empty;
            if(!string.IsNullOrEmpty(repairItemID)){
                bool TacticianOwned = false;
                foreach(var tactItem in sPlayer.GetTacticianSheet().TacticianInventoryData){
                    if(tactItem.Value.Deleted || tactItem.Value.amount == 0 || string.IsNullOrEmpty(tactItem.Value.Durability) || tactItem.Value.NFT){
                        continue;
                    }
                    if(tactItem.Value.customID == repairItemID){
                        TacticianOwned = true;
                        charID = "Tactician";
                        break;
                    }
                }
                if(!TacticianOwned){
                    bool charFound = false;
                    foreach(var sheet in sPlayer.GetInformationSheets()){
                        foreach(var charItem in sheet.CharInventoryData){
                            if(charItem.Value.Deleted || charItem.Value.amount == 0 || string.IsNullOrEmpty(charItem.Value.Durability) || charItem.Value.NFT){
                                continue;
                            }
                            if(charItem.Value.customID == repairItemID){
                                charFound = true;
                                charID = sheet.CharacterID;
                                break;
                            }
                        }
                        if(charFound){
                            break;
                        }
                    }
                }
            }
            print($"Starting ServerRepairItem");
            sPlayer.ServerRepairItem(charID, repairingItem);
            //check gold, remove gold, find this item and send to the repair method in sceneplayer
        }
        void OnDisable(){
            
            MatchMaker.CLEARTHEMATCH.RemoveListener(ClearMatch);
            MatchMaker.moveTurnManager.RemoveListener(SendTurnManagerToMatch);
            MatchMaker.moveMob.RemoveListener(SendMobToMatch);
            //ScenePlayer.FinalRequest.RemoveListener(AuthorizeMovementRequest);
        }
        
        void UpdatePlayerData(NetworkConnectionToClient connectionToClient, string energy, string lastScene, string lastNode) 
        {
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(connectionToClient)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED UpdatePlayerData");
            string playFabId = ((PlayerInfo)connectionToClient.authenticationData).PlayFabId;

            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = playFabId,
                Data = new Dictionary<string, string>
                {
                    {"energy", energy},
                    {"LastScene", lastScene},
                    {"savedNode", lastNode}
                }
            }, result =>
            {
                Debug.Log("Successfully updated player data for player " + playFabId);
            }, error =>
            {
                Debug.LogError("Failed to update player data: " + error.ErrorMessage);
            });
            #endif

        }
        public (int, int, float, int) GetCharacterLevelUp(int _level, string CORE){
            int ExpCost = 0;
            int EnergyCost = 0;
            float TimeCost = 0f;
            int GoldCost = 0;
            switch (CORE) {
                case "STANDARD":
                    switch (_level) {
                        case 1:
                            ExpCost = 4000;
                            EnergyCost = 100;
                            TimeCost = 60f; // 1 minute in seconds
                            GoldCost = 500;
                            break;
                        case 2:
                            ExpCost = 8000;
                            EnergyCost = 200;
                            TimeCost = 300f; // 5 minutes in seconds
                            GoldCost = 750;
                            break;
                        case 3:
                            ExpCost = 12000;
                            EnergyCost = 300;
                            TimeCost = 900f; // 15 minutes in seconds
                            GoldCost = 1000;
                            break;
                        case 4:
                            ExpCost = 20000;
                            EnergyCost = 400;
                            TimeCost = 3600f; // 1 hour in seconds
                            GoldCost = 1500;
                            break;
                        case 5:
                            ExpCost = 30000;
                            EnergyCost = 500;
                            TimeCost = 10800f; // 3 hours in seconds
                            GoldCost = 2000;
                            break;
                        case 6:
                            ExpCost = 55000;
                            EnergyCost = 600;
                            TimeCost = 18000f; // 5 hours in seconds
                            GoldCost = 2500;
                            break;
                        case 7:
                            ExpCost = 75000;
                            EnergyCost = 700;
                            TimeCost = 21600f; // 6 hours in seconds
                            GoldCost = 3000;
                            break;
                        case 8:
                            ExpCost = 100000;
                            EnergyCost = 800;
                            TimeCost = 25200f; // 7 hours in seconds
                            GoldCost = 3500;
                            break;
                        case 9:
                            ExpCost = 145000;
                            EnergyCost = 900;
                            TimeCost = 28800f; // 8 hours in seconds
                            GoldCost = 4000;
                            break;
                        case 10:
                            ExpCost = 180000;
                            EnergyCost = 1000;
                            TimeCost = 32400f; // 9 hours in seconds
                            GoldCost = 4500;
                            break;
                        case 11:
                            ExpCost = 220000;
                            EnergyCost = 1200;
                            TimeCost = 39600f; // 11 hours in seconds
                            GoldCost = 5000;
                            break;
                        case 12:
                            ExpCost = 265000;
                            EnergyCost = 1400;
                            TimeCost = 46800f; // 13 hours in seconds
                            GoldCost = 5500;
                            break;
                        case 13:
                            ExpCost = 300000;
                            EnergyCost = 1600;
                            TimeCost = 54000f; // 15 hours in seconds
                            GoldCost = 6000;
                            break;
                        case 14:
                            ExpCost = 350000;
                            EnergyCost = 1800;
                            TimeCost = 61200f; // 17 hours in seconds
                            GoldCost = 6500;
                            break;
                        case 15:
                            ExpCost = 425000;
                            EnergyCost = 2000;
                            TimeCost = 68400f; // 19 hours in seconds
                            GoldCost = 7000;
                            break;
                        case 16:
                            ExpCost = 500000;
                            EnergyCost = 2200;
                            TimeCost = 75600f; // 21 hours in seconds
                            GoldCost = 7500;
                            break;
                        case 17:
                            ExpCost = 600000;
                            EnergyCost = 2400;
                            TimeCost = 82800f; // 23 hours in seconds
                            GoldCost = 8000;
                            break;
                        case 18:
                            ExpCost = 700000;
                            EnergyCost = 2600;
                            TimeCost = 90000f; // 25 hours in seconds
                            GoldCost = 9000;
                            break;
                        case 19:
                            ExpCost = 800000;
                            EnergyCost = 2800;
                            TimeCost = 97200f; // 27 hours in seconds
                            GoldCost = 10000;
                            break;
                        default:
                            break;
                    }
                    break;
                case "HARDCORE":
                    switch (_level) {
                        case 1:
                            ExpCost = 8000;
                            EnergyCost = 200;
                            TimeCost = 3600f;
                            GoldCost = 800;
                            break;
                        case 2:
                            ExpCost = 16000;
                            EnergyCost = 400;
                            TimeCost = 7200f;
                            GoldCost = 2500;
                            break;
                        case 3:
                            ExpCost = 24000;
                            EnergyCost = 600;
                            TimeCost = 14400f;
                            GoldCost = 5000;
                            break;
                        case 4:
                            ExpCost = 40000;
                            EnergyCost = 800;
                            TimeCost = 21600f;
                            GoldCost = 10000;
                            break;
                        case 5:
                            ExpCost = 60000;
                            EnergyCost = 1000;
                            TimeCost = 28800f;
                            GoldCost = 15000;
                            break;
                        case 6:
                            ExpCost = 110000;
                            EnergyCost = 1200;
                            TimeCost = 36000f;
                            GoldCost = 20000;
                            break;
                        case 7:
                            ExpCost = 150000;
                            EnergyCost = 1400;
                            TimeCost = 43200f;
                            GoldCost = 25000;
                            break;
                        case 8:
                            ExpCost = 200000;
                            EnergyCost = 1600;
                            TimeCost = 50400f;
                            GoldCost = 30000;
                            break;
                        case 9:
                            ExpCost = 290000;
                            EnergyCost = 1800;
                            TimeCost = 57600f;
                            GoldCost = 35000;
                            break;
                        case 10:
                            ExpCost = 360000;
                            EnergyCost = 2000;
                            TimeCost = 64800f;
                            GoldCost = 40000;
                            break;
                        case 11:
                            ExpCost = 440000;
                            EnergyCost = 2200;
                            TimeCost = 72000f;
                            GoldCost = 45000;
                            break;
                        case 12:
                            ExpCost = 530000;
                            EnergyCost = 2400;
                            TimeCost = 79200f;
                            GoldCost = 50000;
                            break;
                        case 13:
                            ExpCost = 600000;
                            EnergyCost = 2600;
                            TimeCost = 86400f;
                            GoldCost = 55000;
                            break;
                        case 14:
                            ExpCost = 700000;
                            EnergyCost = 2800;
                            TimeCost = 93600f;
                            GoldCost = 60000;
                            break;
                        case 15:
                            ExpCost = 850000;
                            EnergyCost = 3000;
                            TimeCost = 100800f;
                            GoldCost = 70000;
                            break;
                        case 16:
                            ExpCost = 1000000;
                            EnergyCost = 3200;
                            TimeCost = 108000f;
                            GoldCost = 80000;
                            break;
                        case 17:
                            ExpCost = 1200000;
                            EnergyCost = 3400;
                            TimeCost = 115200f;
                            GoldCost = 90000;
                            break;
                        case 18:
                            ExpCost = 1400000;
                            EnergyCost = 3600;
                            TimeCost = 122400f;
                            GoldCost = 100000;
                            break;
                        case 19:
                            ExpCost = 1600000;
                            EnergyCost = 3800;
                            TimeCost = 129600f;
                            GoldCost = 125000;
                            break;
                        case 20:
                            ExpCost = 2000000;
                            EnergyCost = 4000;
                            TimeCost = 136800f;
                            GoldCost = 150000;
                            break;
                        default:
                            break;
                    }
                    break;
                case "HERO":
                    switch (_level) {
                        case 1:
                            ExpCost = 16000;
                            EnergyCost = 300;
                            TimeCost = 7200f;
                            GoldCost = 1500;
                            break;
                        case 2:
                            ExpCost = 32000;
                            EnergyCost = 600;
                            TimeCost = 18000f;
                            GoldCost = 4000;
                            break;
                        case 3:
                            ExpCost = 48000;
                            EnergyCost = 900;
                            TimeCost = 28800f;
                            GoldCost = 10000;
                            break;
                        case 4:
                            ExpCost = 80000;
                            EnergyCost = 1200;
                            TimeCost = 39600f;
                            GoldCost = 16000;
                            break;
                        case 5:
                            ExpCost = 120000;
                            EnergyCost = 1500;
                            TimeCost = 50400f;
                            GoldCost = 25000;
                            break;
                        case 6:
                            ExpCost = 220000;
                            EnergyCost = 1800;
                            TimeCost = 61200f;
                            GoldCost = 35000;
                            break;
                        case 7:
                            ExpCost = 300000;
                            EnergyCost = 2100;
                            TimeCost = 72000f;
                            GoldCost = 45000;
                            break;
                        case 8:
                            ExpCost = 400000;
                            EnergyCost = 2400;
                            TimeCost = 82800f;
                            GoldCost = 55000;
                            break;
                        case 9:
                            ExpCost = 580000;
                            EnergyCost = 2700;
                            TimeCost = 93600f;
                            GoldCost = 65000;
                            break;
                        case 10:
                            ExpCost = 720000;
                            EnergyCost = 3000;
                            TimeCost = 104400f;
                            GoldCost = 75000;
                            break;
                        case 11:
                            ExpCost = 880000;
                            EnergyCost = 3300;
                            TimeCost = 115200f;
                            GoldCost = 100000;
                            break;
                        case 12:
                            ExpCost = 1060000;
                            EnergyCost = 3600;
                            TimeCost = 126000f;
                            GoldCost = 125000;
                            break;
                        case 13:
                            ExpCost = 1200000;
                            EnergyCost = 3900;
                            TimeCost = 136800f;
                            GoldCost = 150000;
                            break;
                        case 14:
                            ExpCost = 1400000;
                            EnergyCost = 4200;
                            TimeCost = 147600f;
                            GoldCost = 175000;
                            break;
                        case 15:
                            ExpCost = 1800000;
                            EnergyCost = 4500;
                            TimeCost = 158400f;
                            GoldCost = 200000;
                            break;
                        case 16:
                            ExpCost = 2100000;
                            EnergyCost = 4800;
                            TimeCost = 169200f;
                            GoldCost = 225000;
                            break;
                        case 17:
                            ExpCost = 2400000;
                            EnergyCost = 5100;
                            TimeCost = 180000f;
                            GoldCost = 250000;
                            break;
                        case 18:
                            ExpCost = 2800000;
                            EnergyCost = 5400;
                            TimeCost = 190800f;
                            GoldCost = 275000;
                            break;
                        case 19:
                            ExpCost = 3200000;
                            EnergyCost = 5700;
                            TimeCost = 201600f;
                            GoldCost = 350000;
                            break;
                        case 20:
                            ExpCost = 4000000;
                            EnergyCost = 6000;
                            TimeCost = 212400f;
                            GoldCost = 500000;
                            break;
                        default:
                            break;
                    }
                    break;
                default:
                    break;
            }
        return (ExpCost, EnergyCost, TimeCost, GoldCost);
    }
        public bool CanAddMoreCraftingItems(ScenePlayer sPlayer)
        {
            return sPlayer.GetTacticianSheet().CraftingItems.Count < 5;
        }
        public (int newLevel, float newExp, bool leveledUp) CheckForLevelUpSkillCrafting(int currentLevel, float currentExp, ScenePlayer sPlayer, int energyCost)
        {
            const int MaxLevel = 100;
            const int BaseExp = 1000;
            const int AdditionalExpPerLevel = 200;

            // Calculate the experience required for the next level
            float expForNextLevel = BaseExp + ((currentLevel - 1) * AdditionalExpPerLevel);
            // Check if current experience is enough for leveling up
            bool leveled = false;
            while (currentExp >= expForNextLevel && currentLevel < MaxLevel)
            {
                leveled = true;
                currentLevel++;
                currentExp -= expForNextLevel;
                // Update the experience required for the next level
                expForNextLevel = BaseExp + (currentLevel * AdditionalExpPerLevel);
                sPlayer.Energy -= energyCost;
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
                CheckForLevelUpTactician(sPlayer, energyCost);
            }
        
            return (currentLevel, currentExp, leveled);
        }
        void PermissionToCraft(NetworkConnectionToClient connectionToClient, string id, string mode, int quant){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(connectionToClient)){
                return;
            }
            ScenePlayer sPlayer = connectionToClient.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED PermissionToCraft ID is {id} mode is {mode} and quant is {quant}");
            if(CanAddMoreCraftingItems(sPlayer)){
                (string itemID, int exp, int energy, int reqSkill, int craftTime, int craftMode, int maxStack) = CraftingRef.Instance.GetCraftingCosts(id);
                if(sPlayer.Energy < energy * quant){
                    return;
                }
                List<string> ingredientList = CraftingRef.Instance.FindIngredientList(id);
                List<string> combinedIngredients = new List<string>();
                for (int i = 0; i < quant; i++) {
                    combinedIngredients.AddRange(ingredientList);
                }
                List<CharacterInventoryListItem> invCopy = new List<CharacterInventoryListItem>();
                foreach(var invItem in sPlayer.GetTacticianSheet().TacticianInventoryData){
                    if(invItem.Value.Deleted || invItem.Value.GetAmount() == 0){
                        continue;
                    }
                    ItemSelectable itemCopy = (new ItemSelectable {
                        NFTID = invItem.Value.NFTID,
                        itemID = invItem.Value.itemID,
                        customID = invItem.Value.customID,
                        Changed = invItem.Value.Changed,
                        QUESTITEM = invItem.Value.QUESTITEM,
                        TacticianInventory = invItem.Value.TacticianInventory,
                        OGTacticianInventory = invItem.Value.OGTacticianInventory,
                        TacticianEquip = invItem.Value.TacticianEquip,
                        TacticianStash = invItem.Value.TacticianStash,
                        OGTacticianStash = invItem.Value.OGTacticianStash,
                        OGTacticianEquip = invItem.Value.OGTacticianEquip,
                        TacticianBelt = invItem.Value.TacticianBelt,
                        OGTacticianBelt = invItem.Value.OGTacticianBelt,
                        NFT = invItem.Value.NFT,
                        OwnerID = invItem.Value.OwnerID,
                        InstanceID = invItem.Value.InstanceID,
                        itemType = invItem.Value.itemType,
                        Item_Name = invItem.Value.Item_Name,
                        ItemSpecificClass = invItem.Value.ItemSpecificClass,
                        itemSlot = invItem.Value.itemSlot,
                        MagicalEffectActive = invItem.Value.MagicalEffectActive,
                        Deleted = invItem.Value.Deleted,
                        amount = invItem.Value.amount,
                        Weight = invItem.Value.Weight,
                        Durability = invItem.Value.Durability,
                        DurabilityMax = invItem.Value.DurabilityMax,
                        BlockValue = invItem.Value.BlockValue,
                        BlockChance = invItem.Value.BlockChance,
                        DamageMin = invItem.Value.DamageMin,
                        DamageMax = invItem.Value.DamageMax,
                        Parry = invItem.Value.Parry,
                        Penetration = invItem.Value.Penetration,
                        AttackDelay = invItem.Value.AttackDelay,
                        STRENGTH_item = invItem.Value.STRENGTH_item,
                        AGILITY_item = invItem.Value.AGILITY_item,
                        FORTITUDE_item = invItem.Value.FORTITUDE_item,
                        ARCANA_item = invItem.Value.ARCANA_item,
                        MagicResist_item = invItem.Value.MagicResist_item,
                        FireResist_item = invItem.Value.FireResist_item,
                        ColdResist_item = invItem.Value.ColdResist_item,
                        PoisonResist_item = invItem.Value.PoisonResist_item,
                        DiseaseResist_item = invItem.Value.DiseaseResist_item,
                        Armor_item = invItem.Value.Armor_item,
                        Rarity_item = invItem.Value.Rarity_item,
                        EQUIPPED = invItem.Value.EQUIPPED,
                        Equippable = invItem.Value.Equippable,
                        INVENTORY = invItem.Value.INVENTORY,
                        EQUIPPEDSLOT = invItem.Value.EQUIPPEDSLOT,
                        Quality_item = invItem.Value.Quality_item,
                        Engraving = invItem.Value.Engraving
                    });
                    string keyName = invItem.Key;
                    CharacterInventoryListItem invItemCopy = (new CharacterInventoryListItem{
                        Key = keyName,
                        Value = itemCopy
                    });
                    invCopy.Add(invItemCopy);
                }
                print("item copies made on PermissionToCraft");

                //copy has been made lets check ingredient list
                List<CharacterInventoryListItem> changedItems = new List<CharacterInventoryListItem>();
                foreach(var ingredient in combinedIngredients){
                    // Loop through each inventory item
                    CharacterInventoryListItem consumingIngredient = (new CharacterInventoryListItem{
                        Key = "keyName"
                        //Value = "itemCopy"
                    });
                    bool foundIngredient = false;
                    foreach (var invItem in invCopy) //loop through each inv item copy to find our ingredient
                    {
                        // Continue if the item is marked as deleted
                        if (invItem.Value.Deleted)
                        {
                            continue;
                        }
                        if(invItem.Value.amount == 0){
                            continue;
                        }
                        // Check if the inventory item is one of the required ingredients
                        if (invItem.Value.Item_Name == ingredient)
                        {
                            // Do something to the invItem here if needed, like removing one from its quantity

                            // Add this inventory item to the list of changed items
                            consumingIngredient.Key = invItem.Key;
                            consumingIngredient.Value = invItem.Value;
                            print("changing amount of resource to consume, our resource amount before consumtion is " + consumingIngredient.Value.amount);
                            consumingIngredient.Value.amount -= 1;
                            consumingIngredient.Value.Changed = true;
                            print("changing amount of resource to consume, our resource amount after consumtion is " + consumingIngredient.Value.amount);
                            if(consumingIngredient.Value.amount == 0){
                                consumingIngredient.Value.Deleted = true;
                            }
                            foundIngredient = true;
                            break;
                        }
                    }
                    if(!foundIngredient){
                        print("No ingredient found leaving PermissionToCraft");

                        return;
                    } else {
                        int itemIndex = -1;
                        for (int i = 0; i < invCopy.Count; i++)
                        {
                            if (invCopy[i].Value.customID == consumingIngredient.Value.customID)
                            {
                                itemIndex = i;
                                break;
                            }
                        }
                        // If the item is found, remove it
                        if (itemIndex != -1)
                        {
                            invCopy.RemoveAt(itemIndex);
                        }
                        int changedItemIndex = -1;
                        for (int p = 0; p < changedItems.Count; p++)
                        {
                            if (changedItems[p].Value.customID == consumingIngredient.Value.customID)
                            {
                                changedItemIndex = p;
                                break;
                            }
                        }
                        // If the item is found, remove it
                        if (changedItemIndex != -1)
                        {
                            changedItems.RemoveAt(changedItemIndex);
                        }
                        // Add the new CharacterInventoryListItem to the CharInventoryData list
                        invCopy.Add(consumingIngredient);
                        changedItems.Add(consumingIngredient);
                    }
                }
                print("Checking Skills");

                bool enoughSkill = false;
                float newExp = (float)exp;
                int skillLevel = 1;
                string skillUsed = "weaponCraftingSkill";
                if(mode == "armor crafting"){
                    if(sPlayer.GetTacticianSheet().armorCraftingSkill >= reqSkill){
                        enoughSkill = true;
                        skillUsed = "armorCraftingSkill";
                        skillLevel = sPlayer.GetTacticianSheet().armorCraftingSkill;
                        newExp += sPlayer.GetTacticianSheet().armorCraftingExp;
                    }
                }
                if(mode == "weapon crafting"){
                    if(sPlayer.GetTacticianSheet().weaponCraftingSkill >= reqSkill){
                        enoughSkill = true;
                        skillUsed = "weaponCraftingSkill";
                        skillLevel = sPlayer.GetTacticianSheet().weaponCraftingSkill;
                        newExp += sPlayer.GetTacticianSheet().weaponCraftingExp;
                    }
                }
                if(mode == "jewel crafting"){
                    if(sPlayer.GetTacticianSheet().jewelCraftingSkill >= reqSkill){
                        enoughSkill = true;
                        skillUsed = "jewelCraftingSkill";
                        skillLevel = sPlayer.GetTacticianSheet().jewelCraftingSkill;
                        newExp += sPlayer.GetTacticianSheet().jewelCraftingExp;
                    }
                }
                if(mode == "cooking"){
                    if(sPlayer.GetTacticianSheet().cookingSkill >= reqSkill){
                        enoughSkill = true;
                        skillUsed = "cookingSkill";
                        skillLevel = sPlayer.GetTacticianSheet().cookingSkill;
                        newExp += sPlayer.GetTacticianSheet().cookingExp;
                    }
                }
                if(mode == "alchemy"){
                    if(sPlayer.GetTacticianSheet().alchemySkill >= reqSkill){
                        enoughSkill = true;
                        skillUsed = "alchemySkill";
                        skillLevel = sPlayer.GetTacticianSheet().alchemySkill;
                        newExp += sPlayer.GetTacticianSheet().alchemyExp;
                    }
                }
                if(mode == "refining"){
                    if(sPlayer.GetTacticianSheet().refiningSkill >= reqSkill){
                        enoughSkill = true;
                        skillUsed = "refiningSkill";
                        skillLevel = sPlayer.GetTacticianSheet().refiningSkill;
                        newExp += sPlayer.GetTacticianSheet().refiningExp;
                    }
                }
                //if(mode == "salvaging"){
                //    if(sPlayer.GetTacticianSheet().salvagingSkill >= reqSkill){
                //        enoughSkill = true;
                //    }
                //}
                //if(mode == "enchanting"){
                //    if(sPlayer.GetTacticianSheet().enchantingSkill >= reqSkill){
                //        enoughSkill = true;
                //    }
                //}
                if(mode == "transmuting"){
                    skillUsed = "transmuting";
                    enoughSkill = true;
                }
                print("Checking Time");

                //now we have verified we can build another and its time to actually build the item
                // 1. Get the current UTC time
                DateTime currentUtcTime = DateTime.UtcNow;
                craftTime *= quant;
                // 2. Calculate the future end time by adding the crafting duration
                DateTime endCraftingTime = currentUtcTime.AddSeconds(craftTime);
                
                // 3. Convert the future end time to ISO 8601 format
                string dateTimeWithZone = endCraftingTime.ToString("o");
                //string dateTimeWithZone = DateTime.UtcNow.ToString("o");
                string ownerName = sPlayer.playerName;
                string priorQuality = "Plain";
                bool dropped = false;
                print("Checking changed items");

                foreach(var invItem in changedItems){
                    if(invItem.Value.itemSlot != "Cannot Equip"){
                        if(string.IsNullOrEmpty(invItem.Value.Engraving)){
                            print($"Item {invItem.Value.Item_Name} was missing an Engraving");
                            //continue;
                        }
                        if(string.IsNullOrEmpty(invItem.Value.Quality_item)){
                            print($"Item {invItem.Value.Item_Name} was missing an Quality_item");
                            //continue;
                        }
                        ownerName = invItem.Value.Engraving;
                        priorQuality = invItem.Value.Quality_item;
                        print($"{priorQuality} is our quality and {ownerName} is the engraving");
                        if (ownerName.Contains("Found"))
                        {
                            ownerName = ownerName.Substring("Found by ".Length);
                            dropped = true;
                        }
                        else if (ownerName.Contains("Crafted"))
                        {
                            ownerName = ownerName.Substring("Crafted by ".Length);
                            dropped = false;
                        }

                        break;
                    }
                }
                print($"About to build crafting item here are stats {ownerName} is ownername {priorQuality} is prior quality {quant} is our quant and {id} is our Item name");

                CraftingListItem CraftingItem = (new CraftingListItem{
                    ItemID = itemID,
                    Time = dateTimeWithZone,
                    Finished = false,
                    ItemName = id,
                    Mode = skillUsed,
                    reqSkill = reqSkill,
                    exp = exp,
                    energy = energy,
                    OwnerName = ownerName,
                    Dropped = dropped,
                    Quant = quant,
                    PriorQuality = priorQuality

                });
                int energyPayment = energy * quant;
                sPlayer.Energy -= energyPayment;
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
                print($"Energy payment for this craftable item is {energyPayment} energy");
                
                print(CraftingItem.Time + " is our time of start for crafting");
                if(enoughSkill){
                    sPlayer.ServerStartCraftItem(CraftingItem, changedItems);
                }
                
                
            }
            #endif
            //add error before this dont forget
            
            //sPlayer.TargetCraftReturn();
            //make sure to add this into the end of the target
        }
        void CancelCraftingBuild(NetworkConnectionToClient connectionToClient, CraftingListItem craftingitemBuilt){
            #if UNITY_SERVER //|| UNITY_EDITOR

            print("cancel craft part 1");
            ScenePlayer sPlayer = connectionToClient.identity.gameObject.GetComponent<ScenePlayer>();
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            List<string> itemIds = new List<string>();
            Dictionary<string, IngredientDistributionCancel> QualitySavedDict = new Dictionary<string, IngredientDistributionCancel>();
            print("cancel craft item name was " + craftingitemBuilt.ItemName);
            (string _itemID, int _exp, int _energy, int _reqSkill, int _craftTime, int craftMode, int maxStack) = CraftingRef.Instance.GetCraftingCosts(craftingitemBuilt.ItemName);
            List<string> ingredients = CraftingRef.Instance.FindIngredientList(craftingitemBuilt.ItemName);
            List<string> combinedIngredients = new List<string>();
            for (int i = 0; i < craftingitemBuilt.Quant; i++) {
                combinedIngredients.AddRange(ingredients);
            }
            print("cancel craft part 2");
            foreach(var ingredient in combinedIngredients){
                if(ingredient == "Earring"){
                    if(QualitySavedDict.ContainsKey("Earring01")){
                        QualitySavedDict["Earring01"].quantity++;
                    } else {
                        QualitySavedDict.Add("Earring01", new IngredientDistributionCancel { quantity = 1, quality = "Plain"});
                        itemIds.Add("Earring01");
                    }
                    continue;
                }
                if(ingredient == "Amulet"){
                    if(QualitySavedDict.ContainsKey("Necklace01")){
                        QualitySavedDict["Necklace01"].quantity++;
                    } else {
                        QualitySavedDict.Add("Necklace01", new IngredientDistributionCancel { quantity = 1, quality = "Plain"});
                        itemIds.Add("Necklace01");
                    }
                    continue;
                }
                if(ingredient == "Ring"){
                    if(QualitySavedDict.ContainsKey("Ring01")){
                        QualitySavedDict["Ring01"].quantity++;
                    } else {
                        QualitySavedDict.Add("Ring01", new IngredientDistributionCancel { quantity = 1, quality = "Plain"});
                        itemIds.Add("Ring01");
                    }
                    continue;
                }
                (string _itemIDingredient, int _expingredient, int _energyingredient, int _reqSkillingredient, int _craftTimeingredient, int craftModeingredient, int _maxStack) = CraftingRef.Instance.GetCraftingCosts(ingredient);
                if(craftModeingredient == 1 || craftModeingredient == 2 || craftModeingredient == 3 ){
                        QualitySavedDict.Add(_itemIDingredient, new IngredientDistributionCancel { quantity = 1, quality = craftingitemBuilt.PriorQuality});
                        itemIds.Add(_itemIDingredient);
                } else {
                    if(QualitySavedDict.ContainsKey(_itemIDingredient)){
                        QualitySavedDict[_itemIDingredient].quantity++;
                    } else {
                        QualitySavedDict.Add(_itemIDingredient, new IngredientDistributionCancel { quantity = 1, quality = "Plain"});
                        itemIds.Add(_itemIDingredient);
                    }   
                }
            }
            print("cancel craft part 3");
            foreach(var key in QualitySavedDict){
                print($"Key is {key.Key}, quality is {key.Value.quality} and quantity is {key.Value.quantity}");
            }
            foreach(var stringitem in itemIds){
                print($"{stringitem} is our itemID for this ingredient");
                string Quality = "Plain";
                    int Quantity = 1;
                    foreach(var key in QualitySavedDict){
                        if(key.Key == stringitem){
                            Quality = key.Value.quality;
                            Quantity = key.Value.quantity;
                            break;
                        }
                    }
                    string ownerStripped = craftingitemBuilt.OwnerName;
                    ownerStripped = ownerStripped.Replace("Found by ", "").Replace("Crafted by ", "");
                    TransformItemIntoDragonKill(connectionToClient, playerData, stringitem , "Tactician", craftingitemBuilt.PriorQuality, Quantity, false, false, null, false, ownerStripped, false);
            }
            sPlayer.Energy += _energy * craftingitemBuilt.Quant;
            sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
            sPlayer.ServerDeleteCraftItem(craftingitemBuilt);
            #endif

        }
        void BuildItemFromGameMaster(string playerName, string itemName, string quality, int quant){
            #if UNITY_SERVER //|| UNITY_EDITOR

            foreach(var connection in playerConnections){
                ScenePlayer sPlayer = connection.conn.identity.gameObject.GetComponent<ScenePlayer>();
                if(sPlayer.playerName == playerName){
                    BuildGameMasterItemRequest(connection.conn, itemName, quality, quant);
                    return;
                }
            }
            #endif

        }
        void BuildGameMasterItemRequest(NetworkConnectionToClient connectionToClient, string itemName, string quality, int quant){
            #if UNITY_SERVER //|| UNITY_EDITOR

            (string _itemID, int _exp, int _energy, int _reqSkill, int _craftTime, int craftMode, int maxStack) = CraftingRef.Instance.GetCraftingCosts(itemName);
            ScenePlayer sPlayer = connectionToClient.identity.gameObject.GetComponent<ScenePlayer>();
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            TransformItemIntoDragonKill(connectionToClient, playerData, _itemID, "Stash", quality, quant, false, false, null, false, sPlayer.playerName, false);
            #endif

        }
        void BuildCraftItemCompletedAndClicked(NetworkConnectionToClient connectionToClient, CraftingListItem craftingitemBuilt){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(connectionToClient)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED BuildCraftItemCompletedAndClicked for {craftingitemBuilt.ItemName}");
            List<string> itemsBuilding = new List<string>();
            itemsBuilding.Add(craftingitemBuilt.ItemID);
            
            ScenePlayer sPlayer = connectionToClient.identity.gameObject.GetComponent<ScenePlayer>();
            float newExp = (float)craftingitemBuilt.exp * craftingitemBuilt.Quant;
            if(sPlayer.GetTacticianSheet().TacticianInventoryData != null){
                for(int j = 0; j < sPlayer.GetTacticianSheet().TacticianInventoryData.Count; j++){
                    if(sPlayer.GetTacticianSheet().TacticianInventoryData[j].Value.Deleted || sPlayer.GetTacticianSheet().TacticianInventoryData[j].Value.amount == 0){
                        continue;
                    }
                    if(sPlayer.GetTacticianSheet().TacticianInventoryData[j].Value.TacticianEquip){
                        if(sPlayer.GetTacticianSheet().TacticianInventoryData[j].Value.GetItemName() == "Tactician's Gloves"){
                            newExp *= 1.10f; // Increase by 10%
                        }   
                    }
                }
            }
                int skillLevel = 1;
                if(craftingitemBuilt.Mode == "armorCraftingSkill"){
                    if(sPlayer.GetTacticianSheet().armorCraftingSkill >= craftingitemBuilt.reqSkill){
                        skillLevel = sPlayer.GetTacticianSheet().armorCraftingSkill;
                        newExp += sPlayer.GetTacticianSheet().armorCraftingExp;
                    }
                }
                if(craftingitemBuilt.Mode == "weaponCraftingSkill"){
                    if(sPlayer.GetTacticianSheet().weaponCraftingSkill >= craftingitemBuilt.reqSkill){
                        skillLevel = sPlayer.GetTacticianSheet().weaponCraftingSkill;
                        newExp += sPlayer.GetTacticianSheet().weaponCraftingExp;
                    }
                }
                if(craftingitemBuilt.Mode == "jewelCraftingSkill"){
                    if(sPlayer.GetTacticianSheet().jewelCraftingSkill >= craftingitemBuilt.reqSkill){
                        skillLevel = sPlayer.GetTacticianSheet().jewelCraftingSkill;
                        newExp += sPlayer.GetTacticianSheet().jewelCraftingExp;
                    }
                }
                if(craftingitemBuilt.Mode == "cookingSkill"){
                    if(sPlayer.GetTacticianSheet().cookingSkill >= craftingitemBuilt.reqSkill){
                        skillLevel = sPlayer.GetTacticianSheet().cookingSkill;
                        newExp += sPlayer.GetTacticianSheet().cookingExp;
                    }
                }
                if(craftingitemBuilt.Mode == "alchemySkill"){
                    if(sPlayer.GetTacticianSheet().alchemySkill >= craftingitemBuilt.reqSkill){
                        skillLevel = sPlayer.GetTacticianSheet().alchemySkill;
                        newExp += sPlayer.GetTacticianSheet().alchemyExp;
                    }
                }
                if(craftingitemBuilt.Mode == "refiningSkill"){
                    if(sPlayer.GetTacticianSheet().refiningSkill >= craftingitemBuilt.reqSkill){
                        skillLevel = sPlayer.GetTacticianSheet().refiningSkill;
                        newExp += sPlayer.GetTacticianSheet().refiningExp;
                    }
                }
            (int newLevel, float newExpUpdated, bool leveledUp) = CheckForLevelUpSkillCrafting(skillLevel, newExp, sPlayer, craftingitemBuilt.energy);
            //we need to send the new exp lvl for skill we did, and we need to send the removed items while telling client to build a prefab building craft item
            if(leveledUp){
                int energyExpense = newLevel * 5 + 12;
                energyExpense -= 2;
                sPlayer.Energy -= energyExpense;
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
                CheckForLevelUpTactician(sPlayer, energyExpense);
            }
                (string _itemID, int _exp, int energy, int reqSkill, int craftTime, int craftMode, int maxStack) = CraftingRef.Instance.GetCraftingCosts(craftingitemBuilt.ItemName);

            int energyPayment = energy * craftingitemBuilt.Quant;
            //sPlayer.Energy -= energyPayment;
            //sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
            CheckForLevelUpTactician(sPlayer, energyPayment);
            (string DisplayName, string ItemClass, string ConsumableStatus) = GetItemDetails(craftingitemBuilt.ItemID);
                string Quality = "Plain";
                if(ItemClass == "TwoHandedWeapon" || ItemClass == "SingleHandedWeapon" || ItemClass == "Head" || 
                ItemClass == "Chest"  || ItemClass == "Waist" || ItemClass == "Wrists" || ItemClass == "Earring" ||
                ItemClass == "Arms" || ItemClass == "Feet" || ItemClass == "Hands" || ItemClass == "Ring"
                || ItemClass == "Leggings" || ItemClass == "Necklace" || ItemClass == "OffHand"
                || ItemClass == "Shield" || ItemClass == "Shoulders" || ItemClass == "Arms"){
                    Quality = GetQualityCraftFormula(skillLevel, craftingitemBuilt.PriorQuality);
                }
                    TransformItemIntoDragonKill(connectionToClient, playerData, craftingitemBuilt.ItemID, "Tactician", Quality, craftingitemBuilt.Quant, false, false, null, false, sPlayer.playerName, false);
                if(!sPlayer.QuestProgression.Contains("Arudine-A2-3")){
                    if(craftMode == 6){//bow and cloth cord
                       sPlayer.UpdateQuestProgress("Arudine-A2-3", "Refine the raw resources you gathered");
                    }
                } else {
                    if(!sPlayer.QuestProgression.Contains("Arudine-A2-4")){
                        if(craftingitemBuilt.ItemName == "Bow"){
                            sPlayer.UpdateQuestProgress("Arudine-A2-4", "Craft 1 bow");
                        }
                        if(craftingitemBuilt.ItemName == "Cloth Cord"){
                            sPlayer.UpdateQuestProgress("Arudine-A2-4", "Craft 1 cloth cord");
                        }
                    }
                }
                sPlayer.ServerFinishedCraftItem(craftingitemBuilt, newLevel, newExpUpdated, craftingitemBuilt.Mode);
            #endif
        }
        void DeletingACharacterFromPlayer(NetworkConnectionToClient connectionToClient, string id){
            if(!CheckNullConnection(connectionToClient)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED DeletingACharacterFromPlayer for {id}");
            StartCoroutine(DeleteCharacterFromPlayerFunction(connectionToClient, id));
        }
    IEnumerator DeleteCharacterFromPlayerFunction(NetworkConnectionToClient connectionToClient, string id){

        ScenePlayer sPlayer = connectionToClient.identity.gameObject.GetComponent<ScenePlayer>();
        CharacterFullDataMessage SheetRemoving = new CharacterFullDataMessage();
        foreach(var sheet in sPlayer.GetInformationSheets()){
            if(sheet.CharacterID == id){
                SheetRemoving = sheet;
                break;
            }
        }
        PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
        bool characterReset = false;
            #if UNITY_SERVER //|| UNITY_EDITOR

        PlayFabServerAPI.DeleteCharacterFromUser(new DeleteCharacterFromUserRequest
        {
            PlayFabId = playerData.PlayFabId,
            CharacterId = id,
            SaveCharacterInventory = false // Set this to false to not save character's inventory
        }, deleteResult =>
        {
            characterReset = true;
        }, error =>
        {
            Debug.Log(error.ErrorMessage);
        });
        #endif

        while(!characterReset){
            yield return null;
        }
        sPlayer.ServerDeleteChar(SheetRemoving);
    }

    void PurchaseToken(NetworkConnectionToClient connectionToClient){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(connectionToClient)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED PurchaseToken");
        int price = 5000;
        ScenePlayer sPlayer = connectionToClient.identity.gameObject.GetComponent<ScenePlayer>();
        if(sPlayer.QuestProgression.Contains("Arudine-A1-8")){
            if(sPlayer.TokenCount + sPlayer.GetInformationSheets().Count >= 11){
                print("Housing is required to continue purchasing more characters tokens");
                return;
            }
            if(sPlayer.GetInformationSheets().Count >= 11){
                print("Housing is required to continue purchasing more characters tokens");
                return;
            }
            if(sPlayer.Gold < price){
                print("Not enough gold to purchase a character token, earn more by discovering chests or transmute DKP XLS-20 token to Gold");
                return;
            }
            print("bought token");
        } else {
            print("Complete the sewers quest campaign before purchasing more characters.");
            return;
        }
        GrantItemsToUserRequest GetInventoryRequest = new GrantItemsToUserRequest();
        GetInventoryRequest.CatalogVersion = "DragonKill_Characters_Bundles_Items";
        List<string> UToken = new List<string>();
        string token = "UniversalToken";
        UToken.Add(token);
        GetInventoryRequest.ItemIds = UToken;
        GetInventoryRequest.PlayFabId = playerData.PlayFabId;
        PlayFabServerAPI.GrantItemsToUser(GetInventoryRequest, result => {
            sPlayer.TokenCount++;
            sPlayer.Gold -= 5000;
            StartCoroutine(WalletWakeupServer(sPlayer));
        }, error => {
            Debug.Log(error.ErrorMessage);
            Debug.Log(error.ErrorDetails);
            Debug.Log(error.Error);
        });
        #endif
    }
IEnumerator WalletWakeupServer(ScenePlayer sPlayer){
        yield return new WaitForSeconds(.25f);
        sPlayer.TargetTokenUpdate();
        //sPlayer.TargetWalletAwake();
    }
    void RewardingPlayerForQuest(NetworkConnectionToClient connectionToClient, string questID){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(connectionToClient)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED RewardingPlayerForQuest for {questID}");
        //ChainValue = "Arudine-A1-1",
        //Reward = "100 gold  250 tactician exp 200 energy
        ScenePlayer sPlayer = connectionToClient.identity.gameObject.GetComponent<ScenePlayer>();
        if(questID == "Arudine-A1-1"){
            sPlayer.Gold += 100;
            //Figure out energy and tactician exp
            sPlayer.Energy += 100f;
            sPlayer.TargetWalletAwake();
            sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
            CheckForLevelUpTactician(sPlayer, 250);
            //Find exp now and then replicate this for all energy spendatures for tactician level progression
        }
        if(questID == "Arudine-A1-2"){
            GrantItemsToUserRequest GetInventoryRequest = new GrantItemsToUserRequest();
            GetInventoryRequest.CatalogVersion = "DragonKill_Characters_Bundles_Items";
            List<string> UToken = new List<string>();
            string token = "UniversalToken";
            UToken.Add(token);
            GetInventoryRequest.ItemIds = UToken;
            GetInventoryRequest.PlayFabId = playerData.PlayFabId;
            PlayFabServerAPI.GrantItemsToUser(GetInventoryRequest, result => {
                sPlayer.TokenCount++;
                sPlayer.TargetTokenUpdate();
            }, error => {
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
        }
        if(questID == "Arudine-A1-3"){
            GrantItemsToUserRequest GetInventoryRequest = new GrantItemsToUserRequest();
            GetInventoryRequest.CatalogVersion = "DragonKill_Characters_Bundles_Items";
            List<string> UToken = new List<string>();
            string token = "UniversalToken";
            UToken.Add(token);
            GetInventoryRequest.ItemIds = UToken;
            GetInventoryRequest.PlayFabId = playerData.PlayFabId;
            PlayFabServerAPI.GrantItemsToUser(GetInventoryRequest, result => {
                sPlayer.TokenCount++;
                sPlayer.TargetTokenUpdate();
                sPlayer.Gold += 250;
                sPlayer.Energy += 200;
                sPlayer.TargetWalletAwake();
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
                CheckForLevelUpTactician(sPlayer, 500);
            }, error => {
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
        }
        if(questID == "Arudine-A1-4"){
            GrantItemsToUserRequest GetInventoryRequest = new GrantItemsToUserRequest();
            GetInventoryRequest.CatalogVersion = "DragonKill_Characters_Bundles_Items";
            List<string> UToken = new List<string>();
            string token = "UniversalToken";
            UToken.Add(token);
            GetInventoryRequest.ItemIds = UToken;
            GetInventoryRequest.PlayFabId = playerData.PlayFabId;
            //PlayFabServerAPI.GrantItemsToUser(GetInventoryRequest, result => {
                //sPlayer.TokenCount++;
                //sPlayer.TargetTokenUpdate();
                sPlayer.Gold += 100;
                sPlayer.Energy += 100f;
                sPlayer.TargetWalletAwake();
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
                CheckForLevelUpTactician(sPlayer, 250);

                List<string> itemIDs = new List<string>();
                string sword = "Tier1Sword";
                itemIDs.Add(sword);
                BuildQuestRewardItem(connectionToClient, itemIDs, 1); // the number at end is our quant of the item we want to give to player
                List<string> itemIDsOne = new List<string>();
                string shield = "Tier1Shield";
                itemIDsOne.Add(shield);
                BuildQuestRewardItem(connectionToClient, itemIDsOne, 1); // the number at end is our quant of the item we want to give to player
            //}, error => {
            //    Debug.Log(error.ErrorMessage);
            //    Debug.Log(error.ErrorDetails);
            //    Debug.Log(error.Error);
            //});
            //sPlayer.Gold += 100;
            //sPlayer.Energy += 100f;
            //EXP += 250f;
            //EXPItem.Value = Math.Round(EXP, 2).ToString("F2");
            //sPlayer.TargetWalletAwake();
            //sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
            //sPlayer.GetTacticianEXP(EXPItem);
            //List<string> itemIDs = new List<string>();
            //string sword = "Tier1Sword";
            //itemIDs.Add(sword);
            //BuildQuestRewardItem(connectionToClient, itemIDs, 1); // the number at end is our quant of the item we want to give to player
            //List<string> itemIDsOne = new List<string>();
            //string shield = "Tier1Shield";
            //itemIDsOne.Add(shield);
            //BuildQuestRewardItem(connectionToClient, itemIDsOne, 1); // the number at end is our quant of the item we want to give to player
        }
         if(questID == "Arudine-A1-5"){
            GrantItemsToUserRequest GetInventoryRequest = new GrantItemsToUserRequest();
            GetInventoryRequest.CatalogVersion = "DragonKill_Characters_Bundles_Items";
            List<string> UToken = new List<string>();
            string token = "UniversalToken";
            UToken.Add(token);
            GetInventoryRequest.ItemIds = UToken;
            GetInventoryRequest.PlayFabId = playerData.PlayFabId;
            PlayFabServerAPI.GrantItemsToUser(GetInventoryRequest, result => {
                sPlayer.TokenCount++;
                sPlayer.TargetTokenUpdate();
            sPlayer.Gold += 250;
            sPlayer.Energy += 200f;
            sPlayer.TargetWalletAwake();
            sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
            CheckForLevelUpTactician(sPlayer, 1500);
            List<string> itemIDs = new List<string>();
            string chest = "Tier1PlateChest";
            itemIDs.Add(chest);
            BuildQuestRewardItem(connectionToClient, itemIDs, 1); // the number at end is our quant of the item we want to give to player
            }, error => {
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
        }
        if(questID == "Arudine-A1-6"){
            GrantItemsToUserRequest GetInventoryRequest = new GrantItemsToUserRequest();
            GetInventoryRequest.CatalogVersion = "DragonKill_Characters_Bundles_Items";
            List<string> UToken = new List<string>();
            string token = "UniversalToken";
            UToken.Add(token);
            GetInventoryRequest.ItemIds = UToken;
            GetInventoryRequest.PlayFabId = playerData.PlayFabId;
            PlayFabServerAPI.GrantItemsToUser(GetInventoryRequest, result => {
                sPlayer.TokenCount++;
                sPlayer.TargetTokenUpdate();
                sPlayer.Energy += 200;
                sPlayer.TargetWalletAwake();
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
                CheckForLevelUpTactician(sPlayer, 1500);
                List<string> itemIDs = new List<string>();
                string itemid = "StoneOfLife";
                itemIDs.Add(itemid);
                BuildQuestRewardItem(connectionToClient, itemIDs, 1); // the number at end is our quant of the item we want to give to player
                //add the stone of life
            }, error => {
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
        }
        if(questID == "Arudine-A1-7"){
            GrantItemsToUserRequest GetInventoryRequest = new GrantItemsToUserRequest();
            GetInventoryRequest.CatalogVersion = "DragonKill_Characters_Bundles_Items";
            List<string> UToken = new List<string>();
            string token = "UniversalToken";
            UToken.Add(token);
            GetInventoryRequest.ItemIds = UToken;
            GetInventoryRequest.PlayFabId = playerData.PlayFabId;
            PlayFabServerAPI.GrantItemsToUser(GetInventoryRequest, result => {
                sPlayer.TokenCount++;
                sPlayer.TargetTokenUpdate();
                sPlayer.Gold += 250;
                sPlayer.Energy += 200;
                sPlayer.TargetWalletAwake();
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
                CheckForLevelUpTactician(sPlayer, 1500);
                List<string> itemIDs = new List<string>();
                string itemid = "Resource01";
                itemIDs.Add(itemid);
                BuildQuestRewardItem(connectionToClient, itemIDs, 5); // the number at end is our quant of the item we want to give to player
                // 5 rat meat
            }, error => {
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
        }
        if(questID == "Arudine-A1-8"){
            GrantItemsToUserRequest GetInventoryRequest = new GrantItemsToUserRequest();
            GetInventoryRequest.CatalogVersion = "DragonKill_Characters_Bundles_Items";
            List<string> UToken = new List<string>();
            string token = "UniversalToken";
            UToken.Add(token);
            GetInventoryRequest.ItemIds = UToken;
            GetInventoryRequest.PlayFabId = playerData.PlayFabId;
            PlayFabServerAPI.GrantItemsToUser(GetInventoryRequest, result => {
                sPlayer.TokenCount++;
                sPlayer.TargetTokenUpdate();
                sPlayer.Energy += 300;
                sPlayer.Gold += 1000;
                sPlayer.TargetWalletAwake();
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
                CheckForLevelUpTactician(sPlayer, 5000);
                List<string> itemIDs = new List<string>();
                string itemid = "TacticianHandsT1";
                itemIDs.Add(itemid);
                BuildQuestRewardItem(connectionToClient, itemIDs, 1); // the number at end is our quant of the item we want to give to player
            }, error => {
            Debug.Log(error.ErrorMessage);
            Debug.Log(error.ErrorDetails);
            Debug.Log(error.Error);
        });
        }
        if(questID == "Arudine-A2-1"){
                List<string> itemIDs = new List<string>();
                string itemid = "Tool01";
                string itemidtwo = "Tool02";
                string itemidthree = "Tool03";
                string itemidfour = "Tool04";
                string itemidfive = "Tool05";
                itemIDs.Add(itemid);
                itemIDs.Add(itemidtwo);
                itemIDs.Add(itemidthree);
                itemIDs.Add(itemidfour);
                itemIDs.Add(itemidfive);

                BuildQuestRewardItem(connectionToClient, itemIDs, 1); // the number at end is our quant of the item we want to give to player
        }
        if(questID == "Arudine-A2-2"){
            sPlayer.Energy += 300f;
            sPlayer.TargetWalletAwake();
            sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
            CheckForLevelUpTactician(sPlayer, 1000);
        }
        if(questID == "Arudine-A2-3"){
            sPlayer.Energy += 200f;
            sPlayer.TargetWalletAwake();
            sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
            CheckForLevelUpTactician(sPlayer, 500);
        }
        if(questID == "Arudine-A2-4"){
            sPlayer.Energy += 300f;
            sPlayer.TargetWalletAwake();
            sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
            CheckForLevelUpTactician(sPlayer, 750);
        }
        sPlayer.TargetQuestCompleted();
            #endif
        
//"1 stone of life 500 tact exp 200 energy 1 character token",
//Reward = "250 gold 5 rat meat 500 tact exp 200 energy 1 character token",

    }
    void BuildSalvageItem(NetworkConnectionToClient nconn, string itemID, int quant){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED BuildSalvageItem for {itemID} in amount of {quant}");
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            string Quality = "Plain";
            //print($"{choice} is choice {Quality} is quality");
            TransformItemIntoDragonKill(nconn, playerData, itemID, "Tactician", Quality, quant, false, false, null, false, sPlayer.playerName, false);
            sPlayer.SalvageItemsLooted();
            /*
            PlayFabServerAPI.GrantItemsToUser(new GrantItemsToUserRequest
            {
                PlayFabId = playerData.PlayFabId,
                ItemIds = itemID
            }, result =>
            {
                
                foreach(var item in result.ItemGrantResults){
                    
                }
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            */
            #endif
        }
    void BuildQuestRewardItem(NetworkConnectionToClient nconn, List<string> itemID, int quant){
    #if UNITY_SERVER //|| UNITY_EDITOR

            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            if(itemID.Count > 0)
            print($"{playerData.PlayFabId} REQUESTED BuildQuestRewardItem for {itemID[0]} in amount of {quant}");
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            foreach(var itemid in itemID){
                (string DisplayName, string ItemClass, string ConsumableStatus) = GetItemDetails(itemid);
                string Quality = "Plain";
                if(ItemClass == "TwoHandedWeapon" || ItemClass == "SingleHandedWeapon" || ItemClass == "Head" || 
                ItemClass == "Chest"  || ItemClass == "Waist" || ItemClass == "Wrists" || ItemClass == "Earring" ||
                ItemClass == "Arms" || ItemClass == "Feet" || ItemClass == "Hands" || ItemClass == "Ring"
                || ItemClass == "Leggings" || ItemClass == "Necklace" || ItemClass == "OffHand"
                || ItemClass == "Shield" || ItemClass == "Shoulders" || ItemClass == "Arms"){
                    Quality = GetQualityDropFormula();
                }
                //print($"{choice} is choice {Quality} is quality");
                TransformItemIntoDragonKill(nconn, playerData, itemid, "Tactician", Quality, quant, false, false, null, false, sPlayer.playerName, false);
                sPlayer.TargetLootedQuestItem();
            }
    #endif
        }
        void LevelUpStarting(NetworkConnectionToClient connectionToClient, string timeStamp, string charID) 
{
    //print("Starting LevelUP Start");
    if(!CheckNullConnection(connectionToClient)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED LevelUpStarting for charID {charID}");
    float charEXP = 0;
    int _level = 0;
    string _CORE = string.Empty;

    ScenePlayer sPlayer = connectionToClient.identity.gameObject.GetComponent<ScenePlayer>();

    // Get necessary character data
    foreach(var sheet in sPlayer.GetInformationSheets())
    {
        if(sheet.CharacterID == charID)
        {
            foreach(var stat in sheet.CharStatData)
            {
                switch(stat.Key)
                {
                    case "LVL":
                        _level = int.Parse(stat.Value);
                        break;
                    case "EXP":
                        charEXP = float.Parse(stat.Value);
                        break;
                    case "CORE":
                        _CORE = stat.Value;
                        break;
                }
            }
        }
    }


    (int ExpCost, int EnergyCost, float TimeCost, int GoldCost) = GetCharacterLevelUp(_level, _CORE);
    
    // Validate if player has enough resources to level up
    if(sPlayer.Energy < EnergyCost || sPlayer.Gold < GoldCost || charEXP < ExpCost)
        return;

    // Deduct the resources
    sPlayer.Energy -= EnergyCost;
                CheckForLevelUpTactician(sPlayer, EnergyCost);

    //print($"Paid {EnergyCost}");
    sPlayer.Gold -= (long)GoldCost;

    int amount = GoldCost;
    //SubtractVirtualCurrency(playerData, amount);

    //UpdatePlayerEnergy(sPlayer, playerData);
    
    // Deduct EXP cost and start leveling process
    charEXP -= ExpCost;
    StartLevelingProcess(charEXP, playerData, charID, timeStamp, sPlayer, TimeCost);
}

private void SubtractVirtualCurrency(PlayerInfo playerData, int amount)
{
    #if UNITY_SERVER //|| UNITY_EDITOR

    PlayFabServerAPI.SubtractUserVirtualCurrency(new SubtractUserVirtualCurrencyRequest
    {
        PlayFabId = playerData.PlayFabId,
        Amount = amount,
        VirtualCurrency = "DK"
    }, result =>
    {
        //print($"Paid {amount}");
    }, error =>
    {
        Debug.Log(error.ErrorMessage);
    });
    #endif
}

private void UpdatePlayerEnergy(ScenePlayer sPlayer, PlayerInfo playerData)
{
    #if UNITY_SERVER //|| UNITY_EDITOR
    PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
    {
        PlayFabId = playerData.PlayFabId,
        Data = new Dictionary<string, string>
        {
            {"energy", sPlayer.Energy.ToString()}
        }
    }, result => {}, 
    error =>
    {
        Debug.LogError("Failed to update player data: " + error.ErrorMessage);
    });
    #endif
}

private void StartLevelingProcess(float charEXP, PlayerInfo playerData, string charID, string timeStamp, ScenePlayer sPlayer, float TimeCost)
{
    #if UNITY_SERVER //|| UNITY_EDITOR


    DateTime initialTime = DateTime.Parse(timeStamp);
    DateTime updatedTime = initialTime.AddSeconds(TimeCost);
    string newTimeStamp = updatedTime.ToString("o");
    //string dateTimeWithZone = DateTime.UtcNow.ToString("o");
        CharacterStatListItem Leveling = new CharacterStatListItem
        {
            Key = "LEVELING",
            Value = newTimeStamp
        };
        CharacterStatListItem Exp = new CharacterStatListItem
        {
            Key = "EXP",
            Value = charEXP.ToString()
        };
        sPlayer.GetCharacterUpdateLVLINGEXP(charID, Leveling, Exp);
        Debug.Log($"Level up in progress until {updatedTime}");
    #endif
}

        void LevelUpEnding(NetworkConnectionToClient connectionToClient, string timeStamp, string charID)
{
    //print("Starting LevelUP Ending");
    if(!CheckNullConnection(connectionToClient)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)connectionToClient.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED LevelUpEnding for charID {charID}");
    int _level = 0;
    string _CORE = string.Empty;
    string dateTimeWithZone = DateTime.UtcNow.ToString("o");
    bool lvlFound = false;
    bool lvlingFound = false;
    bool coreFound = false;

    
    string serverTimeStamp = string.Empty;
    //DateTime endingTimeStamp = DateTime.Parse(timeStamp);

    ScenePlayer sPlayer = connectionToClient.identity.gameObject.GetComponent<ScenePlayer>();

    // Get necessary character data
    foreach(var sheet in sPlayer.GetInformationSheets())
    {
        if(sheet.CharacterID == charID)
        {
            foreach(var stat in sheet.CharStatData)
            {
                if(lvlFound && lvlingFound && coreFound){
                    break;
                }
                if(stat.Key == "LVL"){
                    _level = int.Parse(stat.Value);
                    lvlFound = true;
                }
                if(stat.Key == "LEVELING"){
                    serverTimeStamp = stat.Value;
                    lvlingFound = true;
                }
                if(stat.Key == "CORE"){
                    _CORE = stat.Value;
                    coreFound = true;
                }
                //switch(stat.Key)
                //{
                //    case "LVL":
                //        _level = int.Parse(stat.Value);
                //        break;
                //    case "LEVELING":
                //        serverTimeStamp = stat.Value;
                //        break;
                //    case "CORE":
                //        _CORE = stat.Value;
                //        break;
                //}
            }
            break;
        }
    }
    if(string.IsNullOrEmpty(serverTimeStamp)){
        return;
    }
    (int ExpCost, int EnergyCost, float TimeCost, int GoldCost) = GetCharacterLevelUp(_level, _CORE);
    DateTime initialTime = DateTime.Parse(dateTimeWithZone);
    DateTime completedTime = DateTime.Parse(serverTimeStamp);
    if (initialTime >= completedTime)
    {
        // initialTime is equal to or beyond completedTime
        // Perform actions when leveling is complete
        _level++;
        UpdateCharacterData(_level, playerData, charID, sPlayer);
    }
    //TimeSpan timeDifference = endingTimeStamp - serverTimeStamp;
    //TimeSpan timeCostSpan = TimeSpan.FromSeconds(TimeCost);
//
    //// Validate if leveling time is up
    //if(timeDifference < timeCostSpan)
    //{
    //    Debug.Log("Error on level up - Server side");
    //    return;
    //}

    // Level up
    
}

private void UpdateCharacterData(int _level, PlayerInfo playerData, string charID, ScenePlayer sPlayer)
{
    #if UNITY_SERVER //|| UNITY_EDITOR
    CharacterStatListItem LEVEL = new CharacterStatListItem
    {
        Key = "LVL",
        Value = _level.ToString()
    };
    sPlayer.GetCharacterUpdateLVL(charID, LEVEL, "LEVELING");

    //PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
    //{
    //    PlayFabId = playerData.PlayFabId,
    //    CharacterId = charID,
    //    Data = new Dictionary<string, string>
    //    {
    //        {"LEVELING", null},
    //        {"LVL", _level.ToString()}
    //    }
    //}, result =>
    //{
    //    sPlayer.GetCharacterUpdateLVL(charID, LEVEL, "LEVELING");
    //}, error =>
    //{
    //    Debug.Log(error.ErrorMessage); 
    //    Debug.Log(error.ErrorDetails);
    //    Debug.Log(error.Error);
    //});
    #endif
}

        //Login Process
        
        void OnReceivePlayerInfo(NetworkConnectionToClient nconn, PlayerInfo netMsg)
        {
            #if UNITY_SERVER //|| UNITY_EDITOR
            
            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = netMsg.SessionTicket
            }, result =>
            {
                /*
                PlayFabServerAPI.GetPlayerProfile(new GetPlayerProfileRequest
                {
                    PlayFabId = result.UserInfo.PlayFabId,
                    ProfileConstraints = new PlayerProfileViewConstraints(){
                        ShowContactEmailAddresses = true
                    }
                }, accountInfoResult =>
                {
                    ContactEmailInfoModel contactEmail = null;
                    List<ContactEmailInfoModel> contactEmails = new List<ContactEmailInfoModel>();
                    if(accountInfoResult.PlayerProfile.ContactEmailAddresses != null){
                            print($"not null for the contact emails");
                        contactEmails = accountInfoResult.PlayerProfile.ContactEmailAddresses;
                    } else {
                            print($"we are def null for the contact emails  not good");
                    }
                    if(contactEmails.Count > 0){
                        foreach(var email in contactEmails){
                            contactEmail = email;
                        }
                        EmailVerificationStatus? emailStatus = contactEmail.VerificationStatus;

                        // Check if the email is confirmed
                        if (emailStatus == EmailVerificationStatus.Confirmed)
                        {
                            // Proceed to CheckDisplayName
                            print($"confirmed on {contactEmail.EmailAddress}");
                            CheckDisplayName(result.UserInfo.PlayFabId, nconn, netMsg.SessionTicket, netMsg);
                            return;
                        }
                        else
                        {
                            print($"not confirmed on {contactEmail.EmailAddress}");
                            OnServerDisconnect(nconn);
                            // Handle unconfirmed or pending email verification status
                            // You might want to disconnect the user or send them a warning message, etc.
                        }
                    }
                    print($"not confirmed on {accountInfoResult.PlayerProfile.DisplayName}");
                    OnServerDisconnect(nconn);
                }, accountInfoError =>
                {
                    // Handle any errors in fetching the account info
                    Debug.Log(accountInfoError.ErrorMessage);
                });
                */
                CheckDisplayName(result.UserInfo.PlayFabId, nconn, netMsg.SessionTicket, netMsg);
                //StartCoroutine(CheckPlayerData(result.UserInfo.PlayFabId, nconn, netMsg.SessionTicket, netMsg, result.UserInfo.TitleInfo.DisplayName));
                
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
       
        void CheckDisplayName(string playFabID, NetworkConnectionToClient nconn, string ticket, PlayerInfo netMsg){
            #if UNITY_SERVER //|| UNITY_EDITOR
            
            PlayFabServerAPI.GetUserAccountInfo(new GetUserAccountInfoRequest
            {
                PlayFabId = playFabID
            }, result =>
            {
                string display = result.UserInfo.TitleInfo.DisplayName;
                if(string.IsNullOrEmpty(display)){
                    display = "NOTACTICIANNAMEPHASE";
                }
                //StartCoroutine(CheckPlayerData(playFabID, nconn, ticket, netMsg, result.UserInfo.TitleInfo.DisplayName));
                CheckPlayerData(playFabID, nconn, ticket, netMsg, result.UserInfo.TitleInfo.DisplayName);

            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        //IEnumerator CheckPlayerData(string playFabID, NetworkConnectionToClient nconn, string ticket, PlayerInfo netMsg, string tacticianNamePlayFab){
        void CheckPlayerData(string playFabID, NetworkConnectionToClient nconn, string ticket, PlayerInfo netMsg, string tacticianNamePlayFab){

            #if UNITY_SERVER //|| UNITY_EDITOR

            PlayFabServerAPI.GetUserData(new GetUserDataRequest
            {
                PlayFabId = playFabID
            }, result =>
            {
                print($"Starting Check if player is connected with CheckIfPlayerIsConnected");
                StartCoroutine(CheckIfPlayerIsConnected(playFabID, nconn, result, netMsg, tacticianNamePlayFab, ticket));
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        //New Account login
        void NoobPlayer(NetworkConnectionToClient nconn, Noob clientMsg){
            OnServerAddPlayer(nconn);
        }
        public (int, int) GetDate(string input){
    StringBuilder dayString = new StringBuilder();
        StringBuilder monthString = new StringBuilder();
        
        foreach (char c in input)
        {
            if (Char.IsDigit(c))
            {
                dayString.Append(c);
            }
            else
            {
                monthString.Append(c);
            }
        }

        int selectedDay = int.Parse(dayString.ToString());

        // Convert month string to month number
        int selectedMonth = 0;
        switch (monthString.ToString())
        {
            case "January":
                selectedMonth = 1;
                break;
            case "February":
                selectedMonth = 2;
                break;
            case "March":
                selectedMonth = 3;
                break;
            case "April":
                selectedMonth = 4;
                break;
            case "May":
                selectedMonth = 5;
                break;
            case "June":
                selectedMonth = 6;
                break;
            case "July":
                selectedMonth = 7;
                break;
            case "August":
                selectedMonth = 8;
                break;
            case "September":
                selectedMonth = 9;
                break;
            case "October":
                selectedMonth = 10;
                break;
            case "November":
                selectedMonth = 11;
                break;
            case "December":
                selectedMonth = 12;
                break;
            default:
                Console.WriteLine("Invalid month");
                return (selectedDay, selectedMonth);
        }
        return (selectedDay, selectedMonth);

}
            #if UNITY_SERVER //|| UNITY_EDITOR

        void CreatePlayerProcess(NetworkConnectionToClient nconn, NoobToPlayer clientMsg){
            PlayerInfo playerinfo = (PlayerInfo)nconn.authenticationData;
            int GiantRep = 1000;
            int DragonRep = 1000;
            int LizardRep = 3500;
            int OrcRep = 3500;
            int FaerieRep = 4500;
            int ElvesRep = 4500;
            int DwarvesRep = 4500;
            int GnomesRep = 4500;
            int Arcana = 0;
            int Str = 0;
            int Fort = 0;
            int Agi = 0;
            string type = "";
            string zodiacDescription = string.Empty;
            (int selectedDay, int selectedMonth) = GetDate(clientMsg.BirthDate);
            string zodiacSign = "";
            if ((selectedMonth == 3 && selectedDay >= 21) || (selectedMonth == 4 && selectedDay <= 19))
                zodiacSign = "Aries";
            else if ((selectedMonth == 4 && selectedDay >= 20) || (selectedMonth == 5 && selectedDay <= 20))
                zodiacSign = "Taurus";
            else if ((selectedMonth == 5 && selectedDay >= 21) || (selectedMonth == 6 && selectedDay <= 21))
                zodiacSign = "Gemini";
            else if ((selectedMonth == 6 && selectedDay >= 22) || (selectedMonth == 7 && selectedDay <= 22))
                zodiacSign = "Cancer";
            else if ((selectedMonth == 7 && selectedDay >= 23) || (selectedMonth == 8 && selectedDay <= 22))
                zodiacSign = "Leo";
            else if ((selectedMonth == 8 && selectedDay >= 23) || (selectedMonth == 9 && selectedDay <= 22))
                zodiacSign = "Virgo";
            else if ((selectedMonth == 9 && selectedDay >= 23) || (selectedMonth == 10 && selectedDay <= 22))
                zodiacSign = "Libra";
            else if ((selectedMonth == 10 && selectedDay >= 23) || (selectedMonth == 11 && selectedDay <= 21))
                zodiacSign = "Scorpio";
            else if ((selectedMonth == 11 && selectedDay >= 22) || (selectedMonth == 12 && selectedDay <= 21))
                zodiacSign = "Sagittarius";
            else if ((selectedMonth == 12 && selectedDay >= 22) || (selectedMonth == 1 && selectedDay <= 19))
                zodiacSign = "Capricorn";
            else if ((selectedMonth == 1 && selectedDay >= 20) || (selectedMonth == 2 && selectedDay <= 18))
                zodiacSign = "Aquarius";
            else if ((selectedMonth == 2 && selectedDay >= 19) || (selectedMonth == 3 && selectedDay <= 20))
            zodiacSign = "Pisces";
            if (zodiacSign == "Aries") {
                GiantRep += 0; DragonRep += 0; LizardRep += 600; OrcRep += -600; FaerieRep += -600; ElvesRep += -600; DwarvesRep += -600; GnomesRep += -600;
                Arcana = 2; Str = 1; Fort = 1; Agi = 2; type = "Fire"; zodiacDescription = "Courageous, determined, confident, enthusiastic, optimistic, and honest the Aries are worshipped by the Lizard folk.";
            } else if (zodiacSign == "Taurus") {
                GiantRep += 0; DragonRep += 0; LizardRep += -600; OrcRep += 600; FaerieRep += -600; ElvesRep += -600; DwarvesRep += -600; GnomesRep += -600;
                Arcana = 1; Str = 2; Fort = 1; Agi = 2; type = "Earth"; zodiacDescription = "Reliable, patient, practical, devoted, responsible, and stable the Taurus are worshipped by the Orcs";
            } else if (zodiacSign == "Gemini") {
                GiantRep += 0; DragonRep += 0; LizardRep += 0; OrcRep += 0; FaerieRep += 1000; ElvesRep += -250; DwarvesRep += -250; GnomesRep += -250;
                Arcana = 3; Str = 1; Fort = 1; Agi = 1; type = "Air"; zodiacDescription = "Gentle, affectionate, curious, adaptable, with the ability to learn quickly Geimini are worshipped by the Faeries";
            } else if (zodiacSign == "Cancer") {
                GiantRep += 0; DragonRep += 0; LizardRep += 0; OrcRep += 0; FaerieRep += -250; ElvesRep += 1000; DwarvesRep += -250; GnomesRep += -250;
                Arcana = 1; Str = 3; Fort = 2; Agi = 1;type = "Water"; zodiacDescription = "Tenacious, highly imaginative, loyal, emotional, sympathetic, and persuasive Cancer is favored by the elves";
            } else if (zodiacSign == "Leo") {
                GiantRep += 0; DragonRep += 0; LizardRep += 0; OrcRep += 0; FaerieRep += 0; ElvesRep += 0; DwarvesRep += 0; GnomesRep += 0;
                Arcana = 3; Str = 1; Fort = 1; Agi = 1;type = "Fire"; zodiacDescription = "Creative, passionate, generous, warm-hearted, cheerful, humorous Leo are favored by the gnomes";
            } else if (zodiacSign == "Virgo") {
                GiantRep += 0; DragonRep += 200; LizardRep += -500; OrcRep += -500; FaerieRep += -500; ElvesRep += -500; DwarvesRep += -500; GnomesRep += -500;
                Arcana = 1; Str = 2; Fort = 2; Agi = 1;type = "Earth"; zodiacDescription = "Loyal, analytical, kind, hardworking, practical, Virgo are revered by the Dragons";
            } else if (zodiacSign == "Libra") {
                GiantRep += 200; DragonRep += 0; LizardRep += -500; OrcRep += -500; FaerieRep += -500; ElvesRep += -500; DwarvesRep += -500; GnomesRep += -500;
                Arcana = 2; Str = 1; Fort = 2; Agi = 1;type = "Air"; zodiacDescription = "Cooperative,diplomatic, gracious, fair-minded, social, Libra are revered by the Giants";
            } else if (zodiacSign == "Scorpio") {
                GiantRep += -200; DragonRep += -200; LizardRep += 600; OrcRep += 600; FaerieRep += 600; ElvesRep += 600; DwarvesRep += 600; GnomesRep += 600;
                Arcana = 0; Str = 2; Fort = 2; Agi = 2;type = "Water"; zodiacDescription = "Resourceful, powerful, brave, passionate, trustworthy, the scorpio are hated by dragons and giants but favored by all others";
            } else if (zodiacSign == "Sagittarius") {
                GiantRep += 0; DragonRep += 0; LizardRep += 0; OrcRep += 0; FaerieRep += -250; ElvesRep += -250; DwarvesRep += 1000; GnomesRep += -250;
                Arcana = 0; Str = 1; Fort = 4; Agi = 1; type = "Fire"; zodiacDescription = "Generous, idealistic, has a great sense of humor Sagittarius are favored by the Dwarves";
            } else if (zodiacSign == "Capricorn") {
                GiantRep += 100; DragonRep += 100; LizardRep += -500; OrcRep += -500; FaerieRep += -500; ElvesRep += -500; DwarvesRep += -500; GnomesRep += -500;
                Arcana = 1; Str = 1; Fort = 1; Agi = 3; type = "Earth"; zodiacDescription = "Responsible, disciplined, strong self-control, and strong leaders capricorns are revered by giants and dragons and uneasy with others.";
            } else if (zodiacSign == "Aquarius") {
                GiantRep += 0; DragonRep += 0; LizardRep += 0; OrcRep += 0; FaerieRep += -250; ElvesRep += -250; DwarvesRep += -250; GnomesRep += 1000;
                Arcana = 4; Str = 0; Fort = 1; Agi = 1; type = "Air"; zodiacDescription = "Progressive, original, independent, humanitarian, the Aquarius are viewed equally by all";
            } else if (zodiacSign == "Pisces") {
                GiantRep += 0; DragonRep += 0; LizardRep += 0; OrcRep += 0; FaerieRep += 1000; ElvesRep += 1000; DwarvesRep += 1000; GnomesRep += 1000;
                Arcana = 0; Str = 0; Fort = 1; Agi = 4; type = "Water"; zodiacDescription = "Compassionate, artistic, intuitive, gentle, wise, musical, the pisces are viewed neutrally";
            }
            clientMsg.bonusStatStrength = (int.Parse(clientMsg.bonusStatStrength) + Str).ToString();
            clientMsg.bonusStatAgility = (int.Parse(clientMsg.bonusStatAgility) + Agi).ToString();
            clientMsg.bonusStatFortitude = (int.Parse(clientMsg.bonusStatFortitude) + Fort).ToString();
            clientMsg.bonusStatArcana = (int.Parse(clientMsg.bonusStatArcana) + Arcana).ToString();
            if(clientMsg.BodyStyle == "Small"){
                clientMsg.bonusStatAgility = (int.Parse(clientMsg.bonusStatAgility) + 2).ToString();
                clientMsg.bonusStatArcana = (int.Parse(clientMsg.bonusStatArcana) + 8).ToString();
            }
            if(clientMsg.BodyStyle == "Average"){
                clientMsg.bonusStatFortitude = (int.Parse(clientMsg.bonusStatFortitude) + 1).ToString();
                clientMsg.bonusStatArcana = (int.Parse(clientMsg.bonusStatArcana) + 2).ToString();
                clientMsg.bonusStatStrength = (int.Parse(clientMsg.bonusStatStrength) + 2).ToString();
                clientMsg.bonusStatAgility = (int.Parse(clientMsg.bonusStatAgility) + 2).ToString();
            }
            if(clientMsg.BodyStyle == "Large"){
                clientMsg.bonusStatStrength = (int.Parse(clientMsg.bonusStatStrength) + 3).ToString();
                clientMsg.bonusStatFortitude = (int.Parse(clientMsg.bonusStatFortitude) + 3).ToString();
            }
            string armorBonus = "0";
            if(type == "Earth"){
                armorBonus = "1";
            }
            if(type == "Fire"){
                clientMsg.bonusStatArcana = (int.Parse(clientMsg.bonusStatArcana) + 5).ToString();
            }
            if(type == "Water"){
                clientMsg.bonusStatFortitude = (int.Parse(clientMsg.bonusStatFortitude) + 3).ToString();
            }
            if(type == "Air"){
                clientMsg.bonusStatAgility = (int.Parse(clientMsg.bonusStatAgility) + 5).ToString();
            }
            if(clientMsg.EyeColor == "Brown"){
                clientMsg.bonusStatStrength = (int.Parse(clientMsg.bonusStatStrength) + 1).ToString();
            }
            if(clientMsg.EyeColor == "Hazel"){
                clientMsg.bonusStatArcana = (int.Parse(clientMsg.bonusStatArcana) + 1).ToString();
            }
            if(clientMsg.EyeColor == "Blue"){
                clientMsg.bonusStatFortitude = (int.Parse(clientMsg.bonusStatFortitude) + 1).ToString();
            }
            if(clientMsg.EyeColor == "Green"){
                clientMsg.bonusStatAgility = (int.Parse(clientMsg.bonusStatAgility) + 1).ToString();
            }
            //add in all their info including the bonus and stuff to playfab so we can access on each login and add in to our stat page

            Dictionary<string, string> newPlayerData = new Dictionary<string, string>();
            newPlayerData.Add("TACTBUILDSTRING", clientMsg.BirthDate + "_" + zodiacSign + "_" +  clientMsg.EyeColor + "_" + clientMsg.BodyStyle + "_" + clientMsg.bonusStatStrength + "_" + clientMsg.bonusStatAgility + "_" + clientMsg.bonusStatFortitude + "_" + clientMsg.bonusStatArcana + "_" + armorBonus + 
            "_" + GiantRep.ToString() + "_" +  DragonRep.ToString() + "_" +  LizardRep.ToString() + "_" +  OrcRep.ToString() + "_" +  FaerieRep.ToString() + "_" +  ElvesRep.ToString() + "_" +  DwarvesRep.ToString() + "_" +  GnomesRep.ToString() + "_" + "0");
            PlayFabServerAPI.UpdateUserData(new UpdateUserDataRequest
            {
                PlayFabId = playerinfo.PlayFabId,
                Data = newPlayerData
            }, result =>
            {
                playerinfo.TactBuildString = clientMsg.BirthDate + "_" + zodiacSign + "_" +  clientMsg.EyeColor + "_" + clientMsg.BodyStyle + "_" + clientMsg.bonusStatStrength + "_" + clientMsg.bonusStatAgility + "_" + clientMsg.bonusStatFortitude + "_" + clientMsg.bonusStatArcana + "_" + armorBonus + 
            "_" + GiantRep.ToString() + "_" +  DragonRep.ToString() + "_" +  LizardRep.ToString() + "_" +  OrcRep.ToString() + "_" +  FaerieRep.ToString() + "_" +  ElvesRep.ToString() + "_" +  DwarvesRep.ToString() + "_" +  GnomesRep.ToString() + "_" + "0";
                playerinfo.PlayerSprite = clientMsg.Sprite;
                playerinfo.Energy = float.Parse("1500");
                nconn.authenticationData = playerinfo;
                OnServerAddPlayer(nconn);    
            }, error => {
            });
                         
        }
        #endif
        void VerifyNewPlayerData(NetworkConnectionToClient nconn, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR

            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {   
                print("Position 1");
                StartCoroutine(SetNewPlayerData(nconn, playerData));
                //GrantPlayerTokens(nconn, playerData, result.UserInfo.PlayFabId); 
            }, error =>{
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
            #endif
        }
        void OnDKPTransmuteRequest(NetworkConnectionToClient nconn, XummTransmute request){
#if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            //validate them now and dont send unless we can if we cant reject it send it back to the client and close their window give them a 10 min wait timer
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED OnDKPTransmuteRequest for amount: {request.amount}");
            DKPTOGOLDTRANSMUTE(nconn, playerData.PlayFabId, request.amount);
            #endif
        }
        void OnGOLDTransmuteRequest(NetworkConnectionToClient nconn, XRPLTransmute request){
#if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED OnGOLDTransmuteRequest for amount: {request.amount}");
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            TacticianFullDataMessage tactSheet = sPlayer.GetTacticianSheet();
            if(tactSheet.DKPCooldown == "0"){   
                long parsedAmount = long.Parse(request.amount);
                if(parsedAmount > 0 && parsedAmount <= sPlayer.Gold){
                    StartCoroutine(SubmitTransmuteRequest(nconn, parsedAmount));
                }
            }
            #endif
        }
#if UNITY_SERVER //|| UNITY_EDITOR

        IEnumerator SubmitTransmuteRequest(NetworkConnectionToClient nconn, long goldAmount){
            if(!CheckNullConnection(nconn)){
                yield break;
            }
        ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
        if(sPlayer == null){
            yield break;
        }
        PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
        string userId = playerData.PlayFabId;
        string walletAddress = sPlayer.GetTacticianSheet().Address;
        WWWForm form = new WWWForm();
        string id = EncryptString(userId);
        form.AddField("userId", id);
        form.AddField("walletAddress", walletAddress);
        form.AddField("goldAmount", goldAmount.ToString());
        if (string.IsNullOrEmpty(userId) || string.IsNullOrEmpty(walletAddress) || goldAmount <= 0)
        {
          // Log error or handle appropriately
          yield break;
        }

        using (UnityWebRequest www = UnityWebRequest.Post(_Heroku_URL + "/dkpsend", form))
        {
            www.SetRequestHeader("x-api-key", CONVO_KEY);

            yield return www.SendWebRequest();

            if (www.result == UnityWebRequest.Result.ConnectionError || www.result == UnityWebRequest.Result.ProtocolError)
            {
                Debug.Log(www.error);
            }
            else
            {
                ResponseObj response = JsonUtility.FromJson<ResponseObj>(www.downloadHandler.text);
                Debug.Log("Received JSON: " + www.downloadHandler.text);
                //print($"{response.success} was our success bool, {response.message} was our message and {response.details.userId} was our User ID, {response.details.goldAmount} was amount and {response.details.walletAddress} is our address");
                var jsonNode = JSON.Parse(www.downloadHandler.text);
                string _success = jsonNode["success"];
                string _message = jsonNode["message"];
                string _userId = jsonNode["details"]["userId"];
                string _id = DecryptString(_userId);
                string _goldAmount = jsonNode["details"]["goldAmount"];
                string _walletAddress = jsonNode["details"]["walletAddress"];
                string _XRPAMOUNT = jsonNode["details"]["xrpBalance"];
                string _DKPAMOUNT = jsonNode["details"]["dkpBalance"];

                
                Debug.Log("Success: " + _success);
                Debug.Log("Message: " + _message);
                Debug.Log("User ID: " + _id + " the encrypted id is " + _userId);
                Debug.Log("Gold Amount: " + _goldAmount);
                Debug.Log("Wallet Address: " + _walletAddress);
                Debug.Log("DKP Balance: " + _DKPAMOUNT);
                Debug.Log("XRP Balance: " + _XRPAMOUNT);

                if(_success == "true"){
                    sPlayer.Gold -= goldAmount;
                    Debug.Log("New Gold TOTAL: " + sPlayer.Gold);
                    float dkpBalancer = float.Parse(_DKPAMOUNT);
                    string dateTimeWithZone = DateTime.UtcNow.ToString("o");
                    //sPlayer.ServerSendDKPCD(dateTimeWithZone, _XRPAMOUNT, dkpBalancer.ToString("F2"));
                    StartCoroutine(NewDKPAmountTRANSMUTE(sPlayer, dkpBalancer, dateTimeWithZone));
                    var msg = new XRPLTransmute { code = "1", error = false };
                    nconn.Send(msg);
                    
                } else {
                    //its false
                    var msg = new XRPLTransmute { code = "0", error = true };
                    nconn.Send(msg);
                    print("Failed to make the swap");
                    
                }
                //if (response.success == "true")
                //{
                //    Debug.Log("Successfully completed transaction and removed gold");
                //    Debug.Log("User ID: " + response.details.userId);
                //    Debug.Log("Gold Amount: " + response.details.goldAmount);
                //    Debug.Log("Wallet Address: " + response.details.walletAddress);
                //}
                //else
                //{
                //    Debug.Log("Failed to complete transaction");
                //}
            }
        }
    }
     IEnumerator NewDKPAmountTRANSMUTE(ScenePlayer p, float dkpBalance, string CD){
            yield return new WaitForSeconds(.5f);
            p.ServerSendDKPCD(CD, p.GetTacticianSheet().XRPBalance, dkpBalance.ToString("F2"));
            //p.TargetWalletAwake();
        }
    #endif
        /*
        private IEnumerator GetBalancesNew(NetworkConnectionToClient nconn, PlayerInfo playerData, bool Dev, string wallet)
        {
            if(string.IsNullOrEmpty(wallet)){
                List<CharacterStatListItem> tacticianStats = new List<CharacterStatListItem>();
                CharacterStatListItem newLevelStat = (new CharacterStatListItem { Key = "LVL", Value = "1" });
                tacticianStats.Add(newLevelStat);
                CharacterStatListItem newEXPStat = (new CharacterStatListItem { Key = "EXP", Value = "0" });
                tacticianStats.Add(newEXPStat);
                CharacterStatListItem spriteStat = (new CharacterStatListItem { Key = "spriteTactician", Value = playerData.PlayerSprite });
                tacticianStats.Add(spriteStat);
                CharacterStatListItem newNameStat = (new CharacterStatListItem { Key = "TacticianName", Value = playerData.PlayerName });
                tacticianStats.Add(newNameStat);
                TacticianFullDataMessage fullTactMessage = (new TacticianFullDataMessage
                {
                    XRPBalance = "Not connected",
                    DKPBalance = "Not connected",
                    StashInventoryData = new List<CharacterInventoryListItem>(),
                    TacticianStatData = tacticianStats,
                    TacticianInventoryData = new List<CharacterInventoryListItem>()
                });
                StartCoroutone(SetNewPlayerInternalData(nconn, playerData, fullTactMessage, Dev, ( new NFTEQUIPMENT {NFTRINGOFTACTICIAN = true})));
                yield break;
            }
            string url = $"https://data.ripple.com/v2/accounts/{wallet}/balances";
            UnityWebRequest www = UnityWebRequest.Get(url);
            yield return www.SendWebRequest();

            if (www.result != UnityWebRequest.Result.Success)
            {
                Debug.Log(www.error);

            }
            else
            {
                string jsonResponse = www.downloadHandler.text;
                XRPLResponse response = JsonUtility.FromJson<XRPLResponse>(jsonResponse);

                string XRP = "";
                string DKP = "";

                foreach (Balance balance in response.balances)
                {
                    if (balance.currency == "XRP")
                    {
                        XRP = balance.value;
                    }
                    else if (balance.currency == "DKP")
                    {
                        DKP = balance.value;
                    }
                }
                List<CharacterStatListItem> tacticianStats = new List<CharacterStatListItem>();
                CharacterStatListItem newLevelStat = (new CharacterStatListItem { Key = "LVL", Value = "1" });
                tacticianStats.Add(newLevelStat);
                CharacterStatListItem newEXPStat = (new CharacterStatListItem { Key = "EXP", Value = "0" });
                tacticianStats.Add(newEXPStat);
                CharacterStatListItem spriteStat = (new CharacterStatListItem { Key = "spriteTactician", Value = playerData.PlayerSprite });
                tacticianStats.Add(spriteStat);
                CharacterStatListItem newNameStat = (new CharacterStatListItem { Key = "TacticianName", Value = playerData.PlayerName });
                tacticianStats.Add(newNameStat);
                TacticianFullDataMessage fullTactMessage = (new TacticianFullDataMessage
                {
                    XRPBalance = XRP,
                    DKPBalance = DKP,
                    StashInventoryData = new List<CharacterInventoryListItem>(),
                    TacticianStatData = tacticianStats,
                    TacticianInventoryData = new List<CharacterInventoryListItem>()
                });
                Dictionary<string, string> newPlayerData = new Dictionary<string, string>();
                newPlayerData.Add("Reset", "R");
            #if UNITY_SERVER //|| UNITY_EDITOR

                PlayFabServerAPI.UpdateUserData(new UpdateUserDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    Data = newPlayerData
                }, result =>
                {   
                    StartCoroutine(SetNewPlayerInternalData(nconn, playerData, fullTactMessage, Dev, ( new NFTEQUIPMENT {NFTRINGOFTACTICIAN = true})));
                }, error =>
                {
                    Debug.Log(error.ErrorMessage);
                });
            #endif
                // You can now parse the response JSON to get the balances.
                // Consider using a JSON library like SimpleJSON or JsonUtility to parse the response.
            }
        }
        */
        IEnumerator SetNewPlayerData(NetworkConnectionToClient nconn, PlayerInfo playerData){
            yield return new WaitForSeconds(.1f);
            #if UNITY_SERVER //|| UNITY_EDITOR
            bool Dev = false;
            string wallet = string.Empty;
            bool ResetItems = false;
            Dictionary<string, string> newPlayerData = new Dictionary<string, string>();
            newPlayerData.Add("NewAccount89", null);
            bool GotUserInfo = false;
            bool keyoneEmpty = true;
            bool keytwoEmpty = true;
            bool keythreeEmpty = true;
            bool keyfourEmpty = true;
            bool keyfiveEmpty = true;
            bool keysixEmpty = true;
            bool keysevenEmpty = true;
            GetUserDataResult resultPublic = null;
            GetUserDataResult result = null;
                print("Position 2");

            PlayFabServerAPI.GetUserData(new GetUserDataRequest
            {
                PlayFabId = playerData.PlayFabId,
            }, userData =>
            {
                resultPublic = userData;
                GotUserInfo = true;
                
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            while(!GotUserInfo){
                yield return null;
            }
                print("Position 3");
            //Get ledger address
            string ledgerAddress = string.Empty;
            if(resultPublic.Data.ContainsKey("PUBLICADDRESS")){
                ledgerAddress = resultPublic.Data["PUBLICADDRESS"].Value;
            }
                print("Position 3 1/2");
            if(resultPublic.Data.ContainsKey("Reset") && resultPublic.Data["Reset"].Value == "R"){
                ResetItems = true;
                newPlayerData.Add("Reset", null);
                Dictionary<string, string> internalDataOne = new Dictionary<string, string>();
                Dictionary<string, string> internalDataTwo = new Dictionary<string, string>();
                Dictionary<string, string> internalDataThree = new Dictionary<string, string>();
                Dictionary<string, string> internalDataFour = new Dictionary<string, string>();
                Dictionary<string, string> internalDataFive = new Dictionary<string, string>();
                Dictionary<string, string> internalDataSix = new Dictionary<string, string>();
                Dictionary<string, string> internalDataSeven = new Dictionary<string, string>();
                // Check for additional keys and add to the corresponding dictionary if found
                string[] keysOne = { "LVL", "LastScene", "lastLogin", "energy", "EXP" };
                string[] keysTwo = { "PartyMemberOne", "PartyMemberTwo", "PartyMemberThree", "PartyMemberZero", "PartyMemberFour" };
                string[] keysThree = { "spriteTactician", "PartyMemberFive" , "XY", "WorldMapDiscovery", "weaponCraftingSkill" };
                string[] keysFour = { "QuestProgress", "CompletedQuests" , "RepeatQuestCD", "armorCraftingSkill", "jewelCraftingSkill"};
                string[] keysFive = { "cookingSkill", "alchemySkill" , "refiningSkill", "weaponCraftingExp", "armorCraftingExp"};
                string[] keysSix = { "jewelCraftingExp", "cookingExp" , "alchemyExp", "refiningExp", "CraftingBuildBelt"};
                string[] keysSeven = { "tactSpellOne", "tactSpellTwo", "fullCooldownData", "PlayerTactAddress", "IdentifiedTargets"};
                bool GotUserInfoInternal = false;
                PlayFabServerAPI.GetUserInternalData(new GetUserDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                }, internDataResult =>
                {
                    result = internDataResult;
                    GotUserInfoInternal = true;
                // New dictionaries for the internal data update
                }, error => { Debug.Log(error.ErrorMessage); });
                while(!GotUserInfoInternal){
                    yield return null;
                }
                print("Position 4");
                foreach (string key in keysOne)
                {
                    if (result.Data.ContainsKey(key))
                    {
                        internalDataOne.Add(key, null);
                        keyoneEmpty = false;
                    }
                }
                print("Position 5");
                foreach (string key in keysTwo)
                {
                    if (result.Data.ContainsKey(key))
                    {
                        internalDataTwo.Add(key, null);
                        keytwoEmpty = false;
                    }
                }
                print("Position 6");
                foreach (string key in keysThree)
                {
                    if (result.Data.ContainsKey(key))
                    {
                        internalDataThree.Add(key, null);
                        keythreeEmpty = false;
                    }
                } 
                foreach (string key in keysFour)
                {
                    if (result.Data.ContainsKey(key))
                    {
                        internalDataFour.Add(key, null);
                        keyfourEmpty = false;
                    }
                } 
                
                foreach (string key in keysFive)
                {
                    if (result.Data.ContainsKey(key))
                    {
                        internalDataFive.Add(key, null);
                        keyfiveEmpty = false;
                    }
                } 
                foreach (string key in keysSix)
                {
                    if (result.Data.ContainsKey(key))
                    {
                        internalDataSix.Add(key, null);
                        keysixEmpty = false;
                    }
                } 
                foreach (string key in keysSeven)
                {
                    if (result.Data.ContainsKey(key))
                    {
                        internalDataSeven.Add(key, null);
                        keysevenEmpty = false;
                    }
                } 
                // Perform the internal data update
                if(!keyoneEmpty){
                    PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
                    {
                        PlayFabId = playerData.PlayFabId,
                        Data = internalDataOne
                    }, internalResulted => { 
                        keyoneEmpty = true;
                    
                    }, error => { Debug.Log(error.ErrorMessage); keyoneEmpty = true;});
                } else {
                    keyoneEmpty = true;
                }
                while(!keyoneEmpty){
                    yield return null;
                }
                if(!keytwoEmpty){
                PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    Data = internalDataTwo
                }, internalResulted => { keytwoEmpty = true; }, error => { Debug.Log(error.ErrorMessage); keytwoEmpty = true;});
                } else {
                    keytwoEmpty = true;
                }
                while(!keytwoEmpty){
                    yield return null;
                }
                print("Position 7");
                if(!keythreeEmpty){
            
                PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    Data = internalDataThree
                }, internalResulted => { keythreeEmpty = true; }, error => { Debug.Log(error.ErrorMessage); keythreeEmpty = true; });
                } else {
                    keythreeEmpty = true;
                }

                while(!keythreeEmpty){
                    yield return null;
                }
                if(!keyfourEmpty){
            
                PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    Data = internalDataFour
                }, internalResulted => { keyfourEmpty = true; }, error => { Debug.Log(error.ErrorMessage); keyfourEmpty = true;});
                } else {
                    keyfourEmpty = true;
                }

                while(!keyfourEmpty){
                    yield return null;
                }
                if(!keyfiveEmpty){
            
                PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    Data = internalDataFive
                }, internalResulted => { keyfiveEmpty = true; }, error => { Debug.Log(error.ErrorMessage); keyfiveEmpty = true;});
                } else {
                    keyfiveEmpty = true;
                }

                while(!keyfiveEmpty){
                    yield return null;
                }
                if(!keysixEmpty){
            
                PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    Data = internalDataSix
                }, internalResulted => { keysixEmpty = true; }, error => { Debug.Log(error.ErrorMessage); keysixEmpty = true;});
                } else {
                    keysixEmpty = true;
                }

                while(!keysixEmpty){
                    yield return null;
                }
                if(!keysevenEmpty){
            
                PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    Data = internalDataSeven
                }, internalResulted => { keysevenEmpty = true; }, error => { Debug.Log(error.ErrorMessage); keysevenEmpty = true;});
                } else {
                    keysevenEmpty = true;
                }

                while(!keysevenEmpty){
                    yield return null;
                }
                print("Position 8");
                bool charsReset = false;
                ListUsersCharactersResult characters = null;

                PlayFabServerAPI.GetAllUsersCharacters(new ListUsersCharactersRequest
                {
                    PlayFabId = playerData.PlayFabId
                }, charactersResult =>
                {
                    characters = charactersResult;
                    charsReset = true;
                }, error =>
                {
                    Debug.Log(error.ErrorMessage);
                });
                while(!charsReset){
                    yield return null;
                }
                print("Position 9");
                for(int j = 0; j < characters.Characters.Count; j++){
                    bool characterReset = false;
                    PlayFabServerAPI.DeleteCharacterFromUser(new DeleteCharacterFromUserRequest
                    {
                        PlayFabId = playerData.PlayFabId,
                        CharacterId = characters.Characters[j].CharacterId,
                        SaveCharacterInventory = false // Set this to false to not save character's inventory
                    }, deleteResult =>
                    {
                        characterReset = true;
                    }, error =>
                    {
                        Debug.Log(error.ErrorMessage);
                    });
                    while(!characterReset){
                        yield return null;
                    }
                }
            }
                    if(resultPublic.Data.ContainsKey("DEV") && resultPublic.Data["DEV"].Value == "KEY"){
                        Dev = true;
                    }
                print("Position After dev 1");

                    PlayFabServerAPI.UpdateUserData(new UpdateUserDataRequest
                    {
                        PlayFabId = playerData.PlayFabId,
                        Data = newPlayerData
                    }, UpdateInventoryResult =>
                    { 
                        if(ResetItems){
                print("Position After dev 2");
                            PlayFabServerAPI.GetUserInventory(new GetUserInventoryRequest
                            {
                                PlayFabId = playerData.PlayFabId
                            }, GetInventoryResult =>
                            {
                                //print("Made call LoginInventoryCheck");
                                // build tactician data we have everything we need now
                                
                                List<ItemInstance> inventory = GetInventoryResult.Inventory;
                                List<ItemSelectable> TacticianItems = new List<ItemSelectable>();
                                if(inventory.Count > 0 && inventory != null){
                                    for (int i = 0; i < inventory.Count; i++)
                                    {
                                        ServerRemoveItemOnUserResetting(nconn, inventory[i].ItemInstanceId);
                                    }
                                }
                                //GrantItemsToUserRequest GetInventoryRequest = new GrantItemsToUserRequest();
                                //GetInventoryRequest.CatalogVersion = "DragonKill_Characters_Bundles_Items";
                                //List<string> UToken = new List<string>();
                                //string token = "UniversalToken";
                                //UToken.Add(token);
                                //UToken.Add(token);
                                //UToken.Add(token);
                                //UToken.Add(token);
                                //UToken.Add(token);
                                //UToken.Add(token);
                                //UToken.Add(token);
                                //UToken.Add(token);
                                //GetInventoryRequest.ItemIds = UToken;
                                //GetInventoryRequest.PlayFabId = playerData.PlayFabId;
                                //PlayFabServerAPI.GrantItemsToUser(GetInventoryRequest, result => {
                                    //StartCoroutine(GetBalancesNew(nconn, playerData, Dev, address));
                                    List<CharacterStatListItem> tacticianStats = new List<CharacterStatListItem>();
                                    CharacterStatListItem newLevelStat = (new CharacterStatListItem { Key = "LVL", Value = "1" });
                                    tacticianStats.Add(newLevelStat);
                                    CharacterStatListItem newEXPStat = (new CharacterStatListItem { Key = "EXP", Value = "0" });
                                    tacticianStats.Add(newEXPStat);
                                    CharacterStatListItem spriteStat = (new CharacterStatListItem { Key = "spriteTactician", Value = playerData.PlayerSprite });
                                    tacticianStats.Add(spriteStat);
                                    CharacterStatListItem newNameStat = (new CharacterStatListItem { Key = "TacticianName", Value = playerData.PlayerName });
                                    tacticianStats.Add(newNameStat);
                                    List<TacticianSpellListItem> tactSpells =  new List<TacticianSpellListItem>();
                                    string zodiacSign = "Empty";
                                    string type = "Empty";
                                    TacticianExtractor tactData = ParseClientData(playerData.TactBuildString);

                                    (int selectedDay, int selectedMonth) = GetDate(tactData.BirthDate);
                                    if ((selectedMonth == 3 && selectedDay >= 21) || (selectedMonth == 4 && selectedDay <= 19))
                                        zodiacSign = "Aries";
                                    else if ((selectedMonth == 4 && selectedDay >= 20) || (selectedMonth == 5 && selectedDay <= 20))
                                        zodiacSign = "Taurus";
                                    else if ((selectedMonth == 5 && selectedDay >= 21) || (selectedMonth == 6 && selectedDay <= 21))
                                        zodiacSign = "Gemini";
                                    else if ((selectedMonth == 6 && selectedDay >= 22) || (selectedMonth == 7 && selectedDay <= 22))
                                        zodiacSign = "Cancer";
                                    else if ((selectedMonth == 7 && selectedDay >= 23) || (selectedMonth == 8 && selectedDay <= 22))
                                        zodiacSign = "Leo";
                                    else if ((selectedMonth == 8 && selectedDay >= 23) || (selectedMonth == 9 && selectedDay <= 22))
                                        zodiacSign = "Virgo";
                                    else if ((selectedMonth == 9 && selectedDay >= 23) || (selectedMonth == 10 && selectedDay <= 22))
                                        zodiacSign = "Libra";
                                    else if ((selectedMonth == 10 && selectedDay >= 23) || (selectedMonth == 11 && selectedDay <= 21))
                                        zodiacSign = "Scorpio";
                                    else if ((selectedMonth == 11 && selectedDay >= 22) || (selectedMonth == 12 && selectedDay <= 21))
                                        zodiacSign = "Sagittarius";
                                    else if ((selectedMonth == 12 && selectedDay >= 22) || (selectedMonth == 1 && selectedDay <= 19))
                                        zodiacSign = "Capricorn";
                                    else if ((selectedMonth == 1 && selectedDay >= 20) || (selectedMonth == 2 && selectedDay <= 18))
                                        zodiacSign = "Aquarius";
                                    else if ((selectedMonth == 2 && selectedDay >= 19) || (selectedMonth == 3 && selectedDay <= 20))
                                        zodiacSign = "Pisces";
                                    if (zodiacSign == "Aries") {
                                        type = "Fire";
                                    } else if (zodiacSign == "Taurus") {
                                        type = "Earth";
                                    } else if (zodiacSign == "Gemini") {
                                        type = "Air"; 
                                    } else if (zodiacSign == "Cancer") {
                                        type = "Water"; 
                                    } else if (zodiacSign == "Leo") {
                                        type = "Fire"; 
                                    } else if (zodiacSign == "Virgo") {
                                        type = "Earth"; 
                                    } else if (zodiacSign == "Libra") {
                                        type = "Air"; 
                                    } else if (zodiacSign == "Scorpio") {
                                        type = "Water"; 
                                    } else if (zodiacSign == "Sagittarius") {
                                        type = "Fire"; 
                                    } else if (zodiacSign == "Capricorn") {
                                        type = "Earth"; 
                                    } else if (zodiacSign == "Aquarius") {
                                        type = "Air"; 
                                    } else if (zodiacSign == "Pisces") {
                                        type = "Water"; 
                                    }
                                    string elementalSpell = "Empty";
                                    if(type == "Fire"){
                                        elementalSpell = "Ignite";
                                    }
                                    if(type == "Air"){
                                        elementalSpell = "Enthrall";
                                    }
                                    if(type == "Water"){
                                        elementalSpell = "Refresh";
                                    }
                                    if(type == "Earth"){
                                        elementalSpell = "Absorb";
                                    }
                                    TacticianSpellListItem elementalSpellData = new TacticianSpellListItem {
                                        Key = elementalSpell
                                    };
                                    TacticianSpellListItem moraleBoostData = new TacticianSpellListItem {
                                        Key = "Morale Boost"
                                    };
                                    tactSpells.Add(elementalSpellData);
                                    tactSpells.Add(moraleBoostData);
                                    TacticianFullDataMessage fullTactMessage = (new TacticianFullDataMessage
                                    {
                                        XRPBalance = "Not connected",
                                        DKPBalance = "Not connected",
                                        SpellOneEquipped = "Empty",
                                        SpellOneCooldown = "Empty",
                                        SpellTwoEquipped = "Empty",
                                        SpellTwoCooldown = "Empty",
                                        StashInventoryData = new List<CharacterInventoryListItem>(),
                                        TacticianStatData = tacticianStats,
                                        TacticianInventoryData = new List<CharacterInventoryListItem>(),
                                        CraftingItems = new List<CraftingListItem>(),
                                        TacticianSpellData = tactSpells,
                                        TacticianCooldownData = new List<CharacterCooldownListItem>()
                                    });
                                    StartCoroutine(SetNewPlayerInternalData(nconn, playerData, fullTactMessage, Dev, true, ledgerAddress));
                                    //SetPlayerVirtualCurrency(request.PlayFabId);
                                //}, error => {
                                //    Debug.Log(error.ErrorMessage);
                                //    Debug.Log(error.ErrorDetails);
                                //    Debug.Log(error.Error);
                                //});
                             }, error =>{
                                Debug.Log(error.ErrorMessage);
                            });
                            
                            //ServerRemoveItemOnUser
                        } else {
                            
                print("Position After dev 3");
                            //GrantItemsToUserRequest GetInventoryRequest = new GrantItemsToUserRequest();
                            //GetInventoryRequest.CatalogVersion = "DragonKill_Characters_Bundles_Items";
                            //List<string> UToken = new List<string>();
                            //string token = "UniversalToken";
                            //UToken.Add(token);
                            //UToken.Add(token);
                            //UToken.Add(token);
                            //UToken.Add(token);
                            //UToken.Add(token);
                            //UToken.Add(token);
                            //UToken.Add(token);
                            //UToken.Add(token);
                            //GetInventoryRequest.ItemIds = UToken;
                            //GetInventoryRequest.PlayFabId = playerData.PlayFabId;
                            //PlayFabServerAPI.GrantItemsToUser(GetInventoryRequest, result => {
                                //StartCoroutine(GetBalancesNew(nconn, playerData, Dev, address));
                                List<TacticianSpellListItem> tactSpells =  new List<TacticianSpellListItem>();
                                    string zodiacSign = "Empty";
                                    string type = "Empty";
                                    TacticianExtractor tactData = ParseClientData(playerData.TactBuildString);

                                    (int selectedDay, int selectedMonth) = GetDate(tactData.BirthDate);
                                    if ((selectedMonth == 3 && selectedDay >= 21) || (selectedMonth == 4 && selectedDay <= 19))
                                        zodiacSign = "Aries";
                                    else if ((selectedMonth == 4 && selectedDay >= 20) || (selectedMonth == 5 && selectedDay <= 20))
                                        zodiacSign = "Taurus";
                                    else if ((selectedMonth == 5 && selectedDay >= 21) || (selectedMonth == 6 && selectedDay <= 21))
                                        zodiacSign = "Gemini";
                                    else if ((selectedMonth == 6 && selectedDay >= 22) || (selectedMonth == 7 && selectedDay <= 22))
                                        zodiacSign = "Cancer";
                                    else if ((selectedMonth == 7 && selectedDay >= 23) || (selectedMonth == 8 && selectedDay <= 22))
                                        zodiacSign = "Leo";
                                    else if ((selectedMonth == 8 && selectedDay >= 23) || (selectedMonth == 9 && selectedDay <= 22))
                                        zodiacSign = "Virgo";
                                    else if ((selectedMonth == 9 && selectedDay >= 23) || (selectedMonth == 10 && selectedDay <= 22))
                                        zodiacSign = "Libra";
                                    else if ((selectedMonth == 10 && selectedDay >= 23) || (selectedMonth == 11 && selectedDay <= 21))
                                        zodiacSign = "Scorpio";
                                    else if ((selectedMonth == 11 && selectedDay >= 22) || (selectedMonth == 12 && selectedDay <= 21))
                                        zodiacSign = "Sagittarius";
                                    else if ((selectedMonth == 12 && selectedDay >= 22) || (selectedMonth == 1 && selectedDay <= 19))
                                        zodiacSign = "Capricorn";
                                    else if ((selectedMonth == 1 && selectedDay >= 20) || (selectedMonth == 2 && selectedDay <= 18))
                                        zodiacSign = "Aquarius";
                                    else if ((selectedMonth == 2 && selectedDay >= 19) || (selectedMonth == 3 && selectedDay <= 20))
                                        zodiacSign = "Pisces";
                                    if (zodiacSign == "Aries") {
                                        type = "Fire";
                                    } else if (zodiacSign == "Taurus") {
                                        type = "Earth";
                                    } else if (zodiacSign == "Gemini") {
                                        type = "Air"; 
                                    } else if (zodiacSign == "Cancer") {
                                        type = "Water"; 
                                    } else if (zodiacSign == "Leo") {
                                        type = "Fire"; 
                                    } else if (zodiacSign == "Virgo") {
                                        type = "Earth"; 
                                    } else if (zodiacSign == "Libra") {
                                        type = "Air"; 
                                    } else if (zodiacSign == "Scorpio") {
                                        type = "Water"; 
                                    } else if (zodiacSign == "Sagittarius") {
                                        type = "Fire"; 
                                    } else if (zodiacSign == "Capricorn") {
                                        type = "Earth"; 
                                    } else if (zodiacSign == "Aquarius") {
                                        type = "Air"; 
                                    } else if (zodiacSign == "Pisces") {
                                        type = "Water"; 
                                    }
                                    string elementalSpell = "Empty";
                                    if(type == "Fire"){
                                        elementalSpell = "Ignite";
                                    }
                                    if(type == "Air"){
                                        elementalSpell = "Enthrall";
                                    }
                                    if(type == "Water"){
                                        elementalSpell = "Refresh";
                                    }
                                    if(type == "Earth"){
                                        elementalSpell = "Absorb";
                                    }
                                    TacticianSpellListItem elementalSpellData = new TacticianSpellListItem {
                                        Key = elementalSpell
                                    };
                                    TacticianSpellListItem moraleBoostData = new TacticianSpellListItem {
                                        Key = "Morale Boost"
                                    };
                                    tactSpells.Add(elementalSpellData);
                                    tactSpells.Add(moraleBoostData);
                                List<CharacterStatListItem> tacticianStats = new List<CharacterStatListItem>();
                                CharacterStatListItem newLevelStat = (new CharacterStatListItem { Key = "LVL", Value = "1" });
                                tacticianStats.Add(newLevelStat);
                                CharacterStatListItem newEXPStat = (new CharacterStatListItem { Key = "EXP", Value = "0" });
                                tacticianStats.Add(newEXPStat);
                                CharacterStatListItem spriteStat = (new CharacterStatListItem { Key = "spriteTactician", Value = playerData.PlayerSprite });
                                tacticianStats.Add(spriteStat);
                                CharacterStatListItem newNameStat = (new CharacterStatListItem { Key = "TacticianName", Value = playerData.PlayerName });
                                tacticianStats.Add(newNameStat);
                                TacticianFullDataMessage fullTactMessage = (new TacticianFullDataMessage
                                {
                                    XRPBalance = "Not connected",
                                    DKPBalance = "Not connected",
                                    StashInventoryData = new List<CharacterInventoryListItem>(),
                                    TacticianStatData = tacticianStats,
                                    TacticianInventoryData = new List<CharacterInventoryListItem>(),
                                    CraftingItems = new List<CraftingListItem>(),
                                    TacticianSpellData = tactSpells,
                                    TacticianCooldownData = new List<CharacterCooldownListItem>()
                                });
                                StartCoroutine(SetNewPlayerInternalData(nconn, playerData, fullTactMessage, Dev, false, ledgerAddress));
                            //}, error => {
                            //    Debug.Log(error.ErrorMessage);
                            //    Debug.Log(error.ErrorDetails);
                            //    Debug.Log(error.Error);
                            //});
                        }
                        
                    }, error =>{
                        Debug.Log(error.ErrorMessage);
                    });

            #endif
        }
        
        #if UNITY_SERVER //|| UNITY_EDITOR
    public void GetPlayerVirtualCurrency(string playFabId){
        PlayFabServerAPI.GetUserInventory(new GetUserInventoryRequest(){
            PlayFabId = playFabId,
        }, result => {
            int currentBalance = result.VirtualCurrency.ContainsKey("DK") ? result.VirtualCurrency["DK"] : 0;
        }, error => Debug.LogError("Could not get player inventory: " + error.GenerateErrorReport()));
    }
    public void SetPlayerVirtualCurrency(string playFabId)
{
PlayFabServerAPI.GetUserInventory(new GetUserInventoryRequest()
{
    PlayFabId = playFabId,
},
result => {
    int currentBalance = result.VirtualCurrency.ContainsKey("DK") ? result.VirtualCurrency["DK"] : 0;
    int difference = 1000000 - currentBalance;

    if (difference > 0) {
        // Add the difference
        PlayFabServerAPI.AddUserVirtualCurrency(new AddUserVirtualCurrencyRequest()
        {
            PlayFabId = playFabId,
            VirtualCurrency = "DK",
            Amount = difference
        },
        addResult => Debug.Log("Successfully set player's DK virtual currency to 1000000."),
        error => Debug.LogError("Could not add to player's DK virtual currency: " + error.GenerateErrorReport()));
    } else if (difference < 0) {
        // Subtract the absolute value of the difference
        PlayFabServerAPI.SubtractUserVirtualCurrency(new SubtractUserVirtualCurrencyRequest()
        {
            PlayFabId = playFabId,
            VirtualCurrency = "DK",
            Amount = Math.Abs(difference)
        },
        subtractResult => Debug.Log("Successfully set player's DK virtual currency to 1000000."),
        error => Debug.LogError("Could not subtract from player's DK virtual currency: " + error.GenerateErrorReport()));
    }
},
error => Debug.LogError("Could not get player inventory: " + error.GenerateErrorReport()));
}
        #endif
    //SetNewPlayerData Here  
        #if UNITY_SERVER //|| UNITY_EDITOR

    IEnumerator SetNewPlayerInternalData(NetworkConnectionToClient nconn, PlayerInfo playerData, TacticianFullDataMessage fullTactMessage, bool Dev, bool reset, string ledgerAddress){
        print("Starting coroutine for setnew player internal data");
        string XRP = "0";
        string DKP = "0";
        //string url = $"https://data.ripple.com/v2/accounts/{ledgerAddress}/balances"; // old api this no longer exists
        print(xrpscanAPI + ledgerAddress + "/balances");
       
    // Process the response to extract balance information
        //Dictionary<string, string> NFTIDs = new Dictionary<string, string>();
        List<string> NFTIDs = new List<string>();

        bool xrpscanCompleted = false;
        if(!string.IsNullOrEmpty(ledgerAddress)){
            UnityWebRequest www = UnityWebRequest.Get(xrpscanAPI + ledgerAddress + "/balances");
        yield return www.SendWebRequest();
        if (www.result != UnityWebRequest.Result.Success)
        {
            Debug.Log(www.error);
            xrpscanCompleted = true;
        }
        else
        {
            string jsonResponse = www.downloadHandler.text;
            CurrencyBase[] currencies = JsonHelper.FromJson<CurrencyBase>(jsonResponse);
            foreach (var currency in currencies)
            {
                // Handle the basic currency object
                if (currency.currency == "DKP")
                {
                    DKP = currency.value;
                    Debug.Log($"Currency: {currency.currency}, Value: {currency.value}");
                }
                if (currency.currency == "XRP")
                {
                    XRP = currency.value;
                    Debug.Log($"Currency: {currency.currency}, Value: {currency.value}");
                }
            }
            xrpscanCompleted = true;
        }
        while(!xrpscanCompleted){
            yield return new WaitForSeconds(.1f);
        }
        bool nftList = false;
        if(!string.IsNullOrEmpty(ledgerAddress)){
            UnityWebRequest nftListRequest = UnityWebRequest.Get(xrpscanAPI + ledgerAddress + "/nfts");
            yield return nftListRequest.SendWebRequest();
            if (nftListRequest.result != UnityWebRequest.Result.Success)
            {
                Debug.Log(nftListRequest.error);
            }
            else
            {
                string nftJson = nftListRequest.downloadHandler.text;
                NFTData[] nftDataArray = JsonHelper.FromJson<NFTData>(nftJson);
                if(nftDataArray != null){
                    foreach (NFTData nftData in nftDataArray)
                    {
                        //bool nftInfo = false;
                        if (nftData.Issuer == "rhB7i1DDJAmw1A3sVi6nR89GWcUkNPo6KJ")  
                        {
                            string metadataURI = nftData.URI;  // This URI can now be used in your subsequent requests
                            string metadataNFTID = nftData.NFTokenID;
                            if(!string.IsNullOrEmpty(metadataNFTID)){
                                print($"NFT ID = {metadataNFTID}");
                                NFTIDs.Add(metadataNFTID);
                            }
                            /*
                            UnityWebRequest NFTURI = UnityWebRequest.Get(metadataURI);
                            yield return NFTURI.SendWebRequest();
                            if (NFTURI.result != UnityWebRequest.Result.Success)
                            {
                                Debug.Log(NFTURI.error);
                            }
                            else
                            {
                                string metadataJson = NFTURI.downloadHandler.text;
                                NFTMetadata metadata = JsonUtility.FromJson<NFTMetadata>(metadataJson);
                                string md5hash = metadata.md5hash;
                                NFTIDs.Add(md5hash, metadataNFTID);//md5hash is how we ciper which nft type it is, ID is singularity
                                string NFTName = metadata.name;
                                Debug.Log("MD5 Hash: " + md5hash);
                                Debug.Log("NFT: " + NFTName);
                                Debug.Log("Issuer: " + nftData.Issuer);
                                nftInfo = true;
                                // Perform your checks or operations here
                            }
                            */
                        } else {
                            //nftInfo = true;
                        }
                        //while(!nftInfo){
                        //    yield return new WaitForSeconds(.1f);
                        //}
                    }
                }
                nftList = true;
            }
        }
        while(!nftList){
            yield return new WaitForSeconds(.1f);
        }   
        }
        
        if(Dev){
            foreach(var item in ItemDataStorage.Instance.GetnftIDsReference()){
                if(!NFTIDs.Contains(item)){
                    NFTIDs.Add(item);
                    //print($"Adding this item {item}");
                }
            }
            NFTIDs.Add("NFT_BowOfPower");
            NFTIDs.Add("NFT_GreatspearOfDragonslaying");
            NFTIDs.Add("NFT_AcidicAxe");
            NFTIDs.Add("NFT_MaceOfHealing");
            NFTIDs.Add("NFT_SpearOfDragonslaying");
            NFTIDs.Add("NFT_StaffOfProtection");
            NFTIDs.Add("NFT_SwordOfFire");
            NFTIDs.Add("NFT_ThunderInfusedGreathammer");
            NFTIDs.Add("NFT_VampiricDagger");
            NFTIDs.Add("NFT_VenomousGreataxe");
            NFTIDs.Add("NFT_FrozenGreatsword");
        } 
        print("Got balances");
        
        string startEnergy = "1500";
        float xrpfloat = float.Parse(XRP);
        float dkpfloat = float.Parse(DKP);
        if(string.IsNullOrEmpty(ledgerAddress)){
            ledgerAddress = "Empty";
        }
        print("Parsed and calling update user");

        PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                Data = new Dictionary<string, string>
                {
                    {"spriteTactician", playerData.PlayerSprite},
                    {"energy", startEnergy}, {"EXP", "0"}, {"LVL", "1"}, 
                }
            }, result =>
            { 

                playerData.Energy = float.Parse(startEnergy);
                playerData.XRPLPUBLIC = ledgerAddress;
                nconn.authenticationData = playerData;
                ScenePlayer q = nconn.identity.gameObject.GetComponent<ScenePlayer>();
                TacticianExtractor tactData = ParseClientData(playerData.TactBuildString);
                fullTactMessage.DKPBalance = dkpfloat.ToString("F2");
                fullTactMessage.XRPBalance = xrpfloat.ToString("F2");
                fullTactMessage.Address = playerData.XRPLPUBLIC;
                fullTactMessage.TacticianAddress = "Slum Dwelling";
                fullTactMessage.tactBuild = playerData.TactBuildString;
                fullTactMessage.StrengthBonus = tactData.BonusStatStrength;
                fullTactMessage.AgilityBonus = tactData.BonusStatAgility;
                fullTactMessage.ArcanaBonus = tactData.BonusStatArcana;
                fullTactMessage.FortitudeBonus = tactData.BonusStatFortitude;
                fullTactMessage.ArmorBonus = tactData.BonusStatArmor;
                fullTactMessage.EyeColor = tactData.EyeColor;
                fullTactMessage.BodyStyle = tactData.BodyStyle;
                fullTactMessage.Birthdate = tactData.BirthDate;
                fullTactMessage.DKPCooldown = tactData.DKPCooldown;
                fullTactMessage.weaponCraftingSkill = 1;
                fullTactMessage.armorCraftingSkill = 1;
                fullTactMessage.jewelCraftingSkill = 1;
                fullTactMessage.cookingSkill = 1;
                fullTactMessage.alchemySkill = 1;
                fullTactMessage.refiningSkill = 1;
                fullTactMessage.weaponCraftingExp = 1f;
                fullTactMessage.armorCraftingExp = 1f;
                fullTactMessage.jewelCraftingExp = 1f;
                fullTactMessage.cookingExp = 1f;
                fullTactMessage.alchemyExp = 1f;
                fullTactMessage.refiningExp = 1f;
                CharacterStatListItem GiantRepStat = (new CharacterStatListItem { Key = "GiantRep", Value = tactData.GiantRep});
                fullTactMessage.TacticianStatData.Add(GiantRepStat);
                CharacterStatListItem DragonRepStat = (new CharacterStatListItem { Key = "DragonRep", Value = tactData.DragonRep });
                fullTactMessage.TacticianStatData.Add(DragonRepStat);
                CharacterStatListItem LizardRepStat = (new CharacterStatListItem { Key = "LizardRep", Value = tactData.LizardRep });
                fullTactMessage.TacticianStatData.Add(LizardRepStat);
                CharacterStatListItem OrcRepStat = (new CharacterStatListItem { Key = "OrcRep", Value = tactData.OrcRep });
                fullTactMessage.TacticianStatData.Add(OrcRepStat);
                CharacterStatListItem FaerieStat = (new CharacterStatListItem { Key = "FaerieRep", Value = tactData.FaerieRep });
                fullTactMessage.TacticianStatData.Add(FaerieStat);
                CharacterStatListItem ElfRepStat = (new CharacterStatListItem { Key = "ElfRep", Value = tactData.ElvesRep });
                fullTactMessage.TacticianStatData.Add(ElfRepStat);
                CharacterStatListItem DwarfRepStat = (new CharacterStatListItem { Key = "DwarfRep", Value = tactData.DwarvesRep });
                fullTactMessage.TacticianStatData.Add(DwarfRepStat);
                CharacterStatListItem GnomeRepStat = (new CharacterStatListItem { Key = "GnomeRep", Value = tactData.GnomesRep });
                fullTactMessage.TacticianStatData.Add(GnomeRepStat);
                CharacterStatListItem IdTargets = (new CharacterStatListItem { Key = "IdentifiedTargets", Value = "None" });
                fullTactMessage.TacticianStatData.Add(IdTargets);
                fullTactMessage.tactString = playerData.PlayerSprite;
                print("Calling StartNewPlayerClientUnit");
                StartCoroutine(StartNewPlayerClient(nconn, playerData, fullTactMessage, Dev, reset, NFTIDs));
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
    }
    IEnumerator StartNewPlayerClient(NetworkConnectionToClient nconn, PlayerInfo playerData, TacticianFullDataMessage fullTactMessage, bool Dev, bool reset, List<string> NFTIDs){
        ScenePlayer q = nconn.identity.gameObject.GetComponent<ScenePlayer>();
        string zodiacSign = "Empty";
                string elementalType = "Empty";
                (int selectedDay, int selectedMonth) = GetDate(fullTactMessage.Birthdate);
                if ((selectedMonth == 3 && selectedDay >= 21) || (selectedMonth == 4 && selectedDay <= 19))
                    zodiacSign = "Aries";
                else if ((selectedMonth == 4 && selectedDay >= 20) || (selectedMonth == 5 && selectedDay <= 20))
                    zodiacSign = "Taurus";
                else if ((selectedMonth == 5 && selectedDay >= 21) || (selectedMonth == 6 && selectedDay <= 21))
                    zodiacSign = "Gemini";
                else if ((selectedMonth == 6 && selectedDay >= 22) || (selectedMonth == 7 && selectedDay <= 22))
                    zodiacSign = "Cancer";
                else if ((selectedMonth == 7 && selectedDay >= 23) || (selectedMonth == 8 && selectedDay <= 22))
                    zodiacSign = "Leo";
                else if ((selectedMonth == 8 && selectedDay >= 23) || (selectedMonth == 9 && selectedDay <= 22))
                    zodiacSign = "Virgo";
                else if ((selectedMonth == 9 && selectedDay >= 23) || (selectedMonth == 10 && selectedDay <= 22))
                    zodiacSign = "Libra";
                else if ((selectedMonth == 10 && selectedDay >= 23) || (selectedMonth == 11 && selectedDay <= 21))
                    zodiacSign = "Scorpio";
                else if ((selectedMonth == 11 && selectedDay >= 22) || (selectedMonth == 12 && selectedDay <= 21))
                    zodiacSign = "Sagittarius";
                else if ((selectedMonth == 12 && selectedDay >= 22) || (selectedMonth == 1 && selectedDay <= 19))
                    zodiacSign = "Capricorn";
                else if ((selectedMonth == 1 && selectedDay >= 20) || (selectedMonth == 2 && selectedDay <= 18))
                    zodiacSign = "Aquarius";
                else if ((selectedMonth == 2 && selectedDay >= 19) || (selectedMonth == 3 && selectedDay <= 20))
                    zodiacSign = "Pisces";
                if (zodiacSign == "Aries") {
                    elementalType = "Fire";
                } else if (zodiacSign == "Taurus") {
                    elementalType = "Earth";
                } else if (zodiacSign == "Gemini") {
                    elementalType = "Air"; 
                } else if (zodiacSign == "Cancer") {
                    elementalType = "Water"; 
                } else if (zodiacSign == "Leo") {
                    elementalType = "Fire"; 
                } else if (zodiacSign == "Virgo") {
                    elementalType = "Earth"; 
                } else if (zodiacSign == "Libra") {
                    elementalType = "Air"; 
                } else if (zodiacSign == "Scorpio") {
                    elementalType = "Water"; 
                } else if (zodiacSign == "Sagittarius") {
                    elementalType = "Fire"; 
                } else if (zodiacSign == "Capricorn") {
                    elementalType = "Earth"; 
                } else if (zodiacSign == "Aquarius") {
                    elementalType = "Air"; 
                } else if (zodiacSign == "Pisces") {
                    elementalType = "Water"; 
                }
                string elementalSpell = "Empty";
                if(elementalType == "Fire"){
                    elementalSpell = "Ignite";
                }
                if(elementalType == "Air"){
                    elementalSpell = "Enthrall";
                }
                if(elementalType == "Water"){
                    elementalSpell = "Refresh";
                }
                if(elementalType == "Earth"){
                    elementalSpell = "Absorb";
                }
                q.SpellOne = elementalSpell;
                q.SpellTwo = "Morale Boost";

        bool readyWGold = false;
        int currentBalance = 0;
        if(reset){
            PlayFabServerAPI.GetUserInventory(new GetUserInventoryRequest(){
                PlayFabId = playerData.PlayFabId,
            }, result => {
                currentBalance = result.VirtualCurrency.ContainsKey("DK") ? result.VirtualCurrency["DK"] : 0;
                readyWGold = true;
            }, error =>{
                readyWGold = true;
                Debug.LogError("Could not get player inventory: " + error.GenerateErrorReport());
            });
        } else {
            readyWGold = true;
        }
        while(!readyWGold){
            yield return null;
        }
        if(Dev){
            q.GameMaster = true;
        }
        q.GetFullTacticianData(fullTactMessage);
        q.SetPlayerData(playerData);
        //q.TargetToggleSprite(false, q.loadSprite);
        q.TargetOpenUI("TOWNOFARUDINE");
        q.TargetCharge(1500);
        
        if (NFTIDs.Count > 0)
        {
            StartCoroutine(SpawnNewNFTS(NFTIDs, playerData, nconn, q.playerName));
        }
        //if(Dev){
        //    StartCoroutine(GetAllItemsInDragonKill(nconn, playerData));
        //}
        q.Gold = (long)currentBalance;
        ClientRequestLoadScene dummy = new ClientRequestLoadScene {
            oldScene = "Container",
            newScene = TOWNOFARUDINE,
            login = true
        };
        GetCleanedSceneName(nconn, dummy);
        StartCoroutine(ReChargeEnergy(nconn));
        yield return new WaitForSeconds(1f);
        q.TargetWalletAwake();
        q.TargetStartTokenUpdate();
    }
    void SpawnTestNFT(List<string> NFTIDs, PlayerInfo playerData, NetworkConnectionToClient nconn, string owner){
        StartCoroutine(SpawnNewNFTS(NFTIDs, playerData, nconn, owner));
    }
    IEnumerator SpawnNewNFTS(List<string> NFTIDs, PlayerInfo playerData, NetworkConnectionToClient nconn, string owner){
        //NFTIDs.Add("aba2af3c46490ef57e6499cc6bb5a14a", "000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD9C2CFAD600000012");
        if (NFTIDs.Count > 0){
            Dictionary<string, string> nfts = GetNFTList(NFTIDs); //keys from this are the item ID, values are the nft ID token
            foreach(var nft in nfts){
                print($"NFT ID = {nft.Key} and its value ID is {nft.Value}");
            }
            int itemsPerRequest = 5; // Set to 5 NFTs at a time
            if(nfts.Count < itemsPerRequest){
                itemsPerRequest = nfts.Count;
            }
            int maxBatchBeforeCooldown = 5; // After 5 batches, cooldown
            int currentBatch = 0;
            for (int i = 0; i < nfts.Count; )
            {
                bool finishedOne = false; // Reset the flag for the new batch
                List<string> itemsIDForThisRequest = nfts.Keys.Skip(i).Take(itemsPerRequest).ToList();
                List<string> itemsForThisRequest = nfts.Values.Skip(i).Take(itemsPerRequest).ToList();
                Dictionary<string, string> batchNFTs = itemsIDForThisRequest.Zip(itemsForThisRequest, (k, v) => new { k, v }).ToDictionary(x => x.k, x => x.v);
                if(batchNFTs == null){
                    print("WARNING NFT BATCH IS NULL FOR SOME REASON***********************");
                } else {
                    foreach(var nftItem in batchNFTs){
                        TransformItemIntoDragonKill(nconn, playerData, nftItem.Value, "Stash", "NFT", 1, true, false, nftItem.Key, false, owner, false);
                    }
                }
                // Increment your loop counter
                i += itemsPerRequest;
                // Increment the batch count
                currentBatch++;
                if (currentBatch >= maxBatchBeforeCooldown)
                {
                    // Cooldown for 15 seconds
                    yield return new WaitForSeconds(15f);
                    currentBatch = 0; // Reset the batch counter
                }
                else
                {
                    // Wait 1 second before next batch
                    yield return new WaitForSeconds(1f);
                }
            }
        }
    }
    
    Dictionary<string, string> GetNFTList(List<string> NFTList){
        //the key is the md5hash we need to figure out which, the value is going to be the nftID\
        
        Dictionary<string, string> OwnedNFTs = new Dictionary<string, string>();// modify this list to be the nft tokens not the md5hash crap the nft token id itself for each one
        foreach(var NFTID in NFTList){
            //Tactician
            //ring of tactician
            print($"Our NFTList ID item is {NFTID}");
            string itemID = ItemDataStorage.Instance.GetIssuedNFTName(NFTID);
            print($"Our itemID is {itemID}");
            if(string.IsNullOrEmpty(itemID)){
                continue;
            }
            if(itemID == "Unknown NFT"){
                continue;
            }
            if(ItemDataStorage.Instance.GetnftIDsReference().Contains(NFTID)){
                if(!OwnedNFTs.ContainsKey(NFTID))
                OwnedNFTs.Add(NFTID, itemID);
            } else if(nftIDsNotInGame.Contains(NFTID)){
                if(!OwnedNFTs.ContainsKey(NFTID))
                OwnedNFTs.Add(NFTID, itemID);
            }
        }
        return OwnedNFTs;
    }
        #endif
        //Login w/ existing account
            #if UNITY_SERVER //|| UNITY_EDITOR

        IEnumerator GetPlayerData(string playFabID, NetworkConnectionToClient nconn, string tacticianNamePlayFab, string ticket, PlayerInfo netMsg, string publicAddress, string tactbuildString){
            string XRP = "0";
            string DKP = "0";
            string url = $"https://data.ripple.com/v2/accounts/{publicAddress}/balances";
            List<int> segments = new List<int>( 66 );
            bool xrpscanCompleted = false;
            if(publicAddress != "Empty"){
                UnityWebRequest www = UnityWebRequest.Get(xrpscanAPI + publicAddress + "/balances");
                yield return www.SendWebRequest();
                if (www.result != UnityWebRequest.Result.Success)
                {
                    Debug.Log(www.error);
                    xrpscanCompleted = true;
                }
                else
                {
                    string jsonResponse = www.downloadHandler.text;
                    CurrencyBase[] currencies = JsonHelper.FromJson<CurrencyBase>(jsonResponse);
                    foreach (var currency in currencies)
                    {
                        // Handle the basic currency object
                        if (currency.currency == "DKP")
                        {
                            Debug.Log($"Currency: {currency.currency}, Value: {currency.value}");
                            DKP = currency.value;
                        }
                        if (currency.currency == "XRP")
                        {
                            XRP = currency.value;
                            Debug.Log($"Currency: {currency.currency}, Value: {currency.value}");
                        }
                    }
                    xrpscanCompleted = true;
                }
                while(!xrpscanCompleted){
                    yield return new WaitForSeconds(.1f);
                }
            }
            
            bool nftList = false;
            List<string> md5HashList = new List<string>();
            List<string> nftIDs = new List<string>();
            

            if(!string.IsNullOrEmpty(publicAddress) && publicAddress != "Empty"){
                UnityWebRequest nftListRequest = UnityWebRequest.Get(xrpscanAPI + publicAddress + "/nfts");
                yield return nftListRequest.SendWebRequest();
                if (nftListRequest.result != UnityWebRequest.Result.Success)
                {
                    Debug.Log(nftListRequest.error);
                }
                else
                {
                    string nftJson = nftListRequest.downloadHandler.text;
                    NFTData[] nftDataArray = JsonHelper.FromJson<NFTData>(nftJson);
                    if(nftDataArray != null){
                        foreach (NFTData nftData in nftDataArray)
                        {
                            //bool nftInfo = false;
                            if (nftData.Issuer == "rhB7i1DDJAmw1A3sVi6nR89GWcUkNPo6KJ")  
                            {
                                string metadataURI = nftData.URI;  // This URI can now be used in your subsequent requests
                                string metadataNFTID = nftData.NFTokenID;
                                if(!string.IsNullOrEmpty(metadataNFTID)){
                                    print($"NFT ID = {metadataNFTID}");
                                    nftIDs.Add(metadataNFTID);

                                }
                                /*
                                    print($"Starting NFT URI {metadataURI}");

                                UnityWebRequest NFTURI = UnityWebRequest.Get(metadataURI);
                                yield return NFTURI.SendWebRequest();
                                if (NFTURI.result != UnityWebRequest.Result.Success)
                                {
                                    Debug.Log(NFTURI.error);
                                    nftInfo = true;

                                }
                                else
                                {
                                    string metadataJson = NFTURI.downloadHandler.text;
                                    NFTMetadata metadata = JsonUtility.FromJson<NFTMetadata>(metadataJson);
                                    string md5hash = metadata.md5hash;
                                    //NFTIDs.Add(md5hash, metadataNFTID);//md5hash is how we ciper which nft type it is, ID is singularity
                                    md5HashList.Add(md5hash);
                                    nftIDs.Add(metadataNFTID);
                                    string NFTName = metadata.name;
                                    Debug.Log("MD5 Hash: " + md5hash);
                                    Debug.Log("NFT: " + NFTName);
                                    Debug.Log("Issuer: " + nftData.Issuer);
                                    nftInfo = true;
                                    // Perform your checks or operations here
                                }
                                */
                            } else {
                               //nftInfo = true;
                            }
                            //while(!nftInfo){
                            //    yield return new WaitForSeconds(.1f);
                            //}
                        }
                    }
                    nftList = true;
                }
                while(!nftList){
                    yield return new WaitForSeconds(.1f);
                }
            }
            
            bool GotUserInfo = false;
            bool GameMaster = false;
            PlayFabServerAPI.GetUserData(new GetUserDataRequest
            {
                PlayFabId = playFabID,
            }, userData =>
            {
                if(userData.Data.ContainsKey("DEV") && userData.Data["DEV"].Value == "KEY"){
                    GameMaster = true;
                }
                GotUserInfo = true;
            }, error =>{
                GotUserInfo = true;
                Debug.Log(error.ErrorMessage);
            });
            while(!GotUserInfo){
                yield return new WaitForSeconds(.1f);
            }
            print("Starting GetPlayerData from prior logout");
            PlayFabServerAPI.GetUserInternalData(new GetUserDataRequest
            {
                PlayFabId = playFabID,
                
            }, result =>
            {
                //print("Made call in getPlayer Data");
                List<string> Party = new List<string>();
                string PartyMemberZero = null;
                string PartyMemberOne = null;
                string PartyMemberTwo = null;
                string PartyMemberThree = null;
                string PartyMemberFour = null;
                string PartyMemberFive = null;
                if(result.Data.ContainsKey("PartyMemberZero")){
                    PartyMemberZero = result.Data["PartyMemberZero"].Value;
                    Party.Add(PartyMemberZero);
                }
                if(result.Data.ContainsKey("PartyMemberOne")){
                    PartyMemberOne = result.Data["PartyMemberOne"].Value;
                    Party.Add(PartyMemberOne);
                }
                if(result.Data.ContainsKey("PartyMemberTwo")){
                    PartyMemberTwo = result.Data["PartyMemberTwo"].Value;
                    Party.Add(PartyMemberTwo);
                }
                if(result.Data.ContainsKey("PartyMemberThree")){
                    PartyMemberThree = result.Data["PartyMemberThree"].Value;
                    Party.Add(PartyMemberThree);
                }
                if(result.Data.ContainsKey("PartyMemberFour")){
                    PartyMemberFour = result.Data["PartyMemberFour"].Value;
                    Party.Add(PartyMemberFour);
                }
                if(result.Data.ContainsKey("PartyMemberFive")){
                    PartyMemberFive = result.Data["PartyMemberFive"].Value;
                    Party.Add(PartyMemberFive);
                }
                if (result.Data.ContainsKey("WorldMapDiscovery"))
                {
                    string jsonSegmentList = result.Data["WorldMapDiscovery"].Value;
                    // Now deserialize the JSON string back to your list object
                    SegmentListSaveData segmentListData = JsonUtility.FromJson<SegmentListSaveData>(jsonSegmentList);
                    segments = segmentListData.segments; // Here you have your List<int>
                }
                // save value as character ID!! will ensure its the proper character in battle
                float currentEnergy = 1500f;
                string LastLogin = null;
                if(result.Data.ContainsKey("lastLogin")){
                    LastLogin = result.Data["lastLogin"].Value;
                    currentEnergy = 0f;
                    DateTime datePrior = DateTime.Parse(LastLogin);
                    string dateTimeWithZone = DateTime.UtcNow.ToString("o");
                    DateTime dateCurrent = DateTime.Parse(dateTimeWithZone);
                    float fastChargeRate = 3000f / (24f * 60f); // 3000 energy per day, converted to per minute
                    float normalChargeRate = 1000f / (24f * 60f); // 1000 energy per day, converted to per minute
                    float maxEnergy = 10000f;
                    float lowEnergy = 3000f;
                    float oldEnergy = float.Parse(result.Data["energy"].Value);
                    double elapsedMinutes = (dateCurrent - datePrior).TotalMinutes;

                    if(oldEnergy < lowEnergy){
                        double minutesToReachLowEnergy = (lowEnergy - oldEnergy) / fastChargeRate;

                        if(elapsedMinutes <= minutesToReachLowEnergy){
                            currentEnergy = oldEnergy + (float)(elapsedMinutes * fastChargeRate);
                        }else{
                            double fastChargedEnergy = (minutesToReachLowEnergy * fastChargeRate) + oldEnergy;
                            double remainingMinutes = elapsedMinutes - minutesToReachLowEnergy;
                            double finalEnergy = fastChargedEnergy + (remainingMinutes * normalChargeRate);
                            currentEnergy = (float)(finalEnergy > maxEnergy ? maxEnergy : finalEnergy);
                        }
                    }else{
                        double additionalEnergy = elapsedMinutes * normalChargeRate;
                        currentEnergy = (float)((oldEnergy + additionalEnergy > maxEnergy) ? maxEnergy : oldEnergy + additionalEnergy);
                    }
                }
                string LastScene = "TOWNOFARUDINE";
                if(result.Data.ContainsKey("LastScene")){
                    LastScene = result.Data["LastScene"].Value;
                }
                if(LastScene != "TOWNOFARUDINE"){
                    if(!LastScene.Contains("Random")){
                        if(LastScene.Contains("Sewers")){

                        } else {
                            if(LastScene == "ArenaDuelArea"){
                                LastScene = "TOWNOFARUDINE";
                            } else {
                                LastScene = "OVM";
                            }
                        }
                    }
                }
                string x = string.Empty;
                string y = string.Empty;
                if(result.Data.ContainsKey("XY")){
                    string[] coordinates = result.Data["XY"].Value.Split('_');
                    if (coordinates.Length == 2) {
                        x = coordinates[0];
                        y = coordinates[1];
                        // Do something with x and y
                    } 
                } else {
                    x = "-36.5";
                    y = "-8.5";
                }
                print($"Starting X is {x}, and y is {y} to start");

                //string savedNode = string.Empty;
                //if(result.Data.ContainsKey("savedNode")){
                //    savedNode = result.Data["savedNode"].Value;
                //} else {
                //    savedNode = "TOWNOFARUDINE";
                //}
                //LastScene = (savedNode == "TOWNOFARUDINE") ? "TOWNOFARUDINE" : "OVM";

            List<string> QuestProgressList = new List<string>();
            List<string> CompletedQuestsList = new List<string>();
            List<string> RepeatQuestCDList = new List<string>();

                if (result.Data.ContainsKey("QuestProgress"))
                {
                    string jsonQuestData = result.Data["QuestProgress"].Value;
                    // Now deserialize the JSON string back to your list object
                    CurrentQuestListSaveData QuestProgressListData = JsonUtility.FromJson<CurrentQuestListSaveData>(jsonQuestData);
                    QuestProgressList = QuestProgressListData.CurrentQuests; // Here you have your List<int>
                }
                if (result.Data.ContainsKey("CompletedQuests"))
                {
                    string jsonQuestData = result.Data["CompletedQuests"].Value;
                    // Now deserialize the JSON string back to your list object
                    CompletedQuestListSaveData completedQuestListSaveData = JsonUtility.FromJson<CompletedQuestListSaveData>(jsonQuestData);
                    CompletedQuestsList = completedQuestListSaveData.CompletedQuests; // Here you have your List<int>
                }
                if (result.Data.ContainsKey("RepeatQuestCD"))
                {
                    string jsonQuestData = result.Data["RepeatQuestCD"].Value;
                    // Now deserialize the JSON string back to your list object
                    RepeatQuestListSaveData segmentListData = JsonUtility.FromJson<RepeatQuestListSaveData>(jsonQuestData);
                    RepeatQuestCDList = segmentListData.CompletedQuests; // Here you have your List<int>
                }
                int weaponCraftingSkill = 1;
                int armorCraftingSkill = 1;
                int jewelCraftingSkill = 1;
                int cookingSkill = 1;
                int alchemySkill = 1;
                int refiningSkill = 1;
                float weaponCraftingExp = 1f;
                float armorCraftingExp = 1f;
                float jewelCraftingExp = 1f;
                float cookingExp = 1f;
                float alchemyExp = 1f;
                float refiningExp = 1f;
                string tactSpellOne = "Empty";
                string tactSpellTwo = "Empty";
                string fullCD = string.Empty;
                string pSprite = "Male";
                string pLvl = "1";
                string pExp = "0";
                string tactAddy = "Slum Dwelling";// (Basic tier)
                //Get guild

               
                //Slum Dwelling (Basic tier)
                //Slum Shelter (Intermediate tier)
                //Slum Residence (Advanced tier)
                /*
                PlayerSprite = result.Data["spriteTactician"].Value,
                PlayerLevel = result.Data["LVL"].Value,
                PlayerExperience = result.Data["EXP"].Value,
                */
                string identityKey = "None";
                if (result.Data.ContainsKey("IdentifiedTargets")){
                    identityKey = result.Data["IdentifiedTargets"].Value;
                }
                if (result.Data.ContainsKey("PlayerTactAddress")){
                    tactAddy = result.Data["PlayerTactAddress"].Value;
                }
                if (result.Data.ContainsKey("LVL")){
                    pLvl = result.Data["LVL"].Value;
                }
                if (result.Data.ContainsKey("EXP")){
                    pExp = result.Data["EXP"].Value;
                }
                if (result.Data.ContainsKey("spriteTactician")){
                    pSprite = result.Data["spriteTactician"].Value;
                }
                if (result.Data.ContainsKey("weaponCraftingSkill")){
                    weaponCraftingSkill = int.Parse(result.Data["weaponCraftingSkill"].Value);
                }
                if (result.Data.ContainsKey("armorCraftingSkill")){
                    armorCraftingSkill = int.Parse(result.Data["armorCraftingSkill"].Value);
                }
                if (result.Data.ContainsKey("jewelCraftingSkill")){
                    jewelCraftingSkill = int.Parse(result.Data["jewelCraftingSkill"].Value);
                }
                if (result.Data.ContainsKey("cookingSkill")){
                    cookingSkill = int.Parse(result.Data["cookingSkill"].Value);
                }
                if (result.Data.ContainsKey("alchemySkill")){
                    alchemySkill = int.Parse(result.Data["alchemySkill"].Value);
                }
                if (result.Data.ContainsKey("refiningSkill")){
                    refiningSkill = int.Parse(result.Data["refiningSkill"].Value);
                }
                if (result.Data.ContainsKey("weaponCraftingExp")){
                    weaponCraftingExp = float.Parse(result.Data["weaponCraftingExp"].Value);
                }
                if (result.Data.ContainsKey("armorCraftingExp")){
                    armorCraftingExp = float.Parse(result.Data["armorCraftingExp"].Value);
                }
                if (result.Data.ContainsKey("jewelCraftingExp")){
                    jewelCraftingExp = float.Parse(result.Data["jewelCraftingExp"].Value);
                }
                if (result.Data.ContainsKey("cookingExp")){
                    cookingExp = float.Parse(result.Data["cookingExp"].Value);
                }
                if (result.Data.ContainsKey("alchemyExp")){
                    alchemyExp = float.Parse(result.Data["alchemyExp"].Value);
                }
                if (result.Data.ContainsKey("refiningExp")){
                    refiningExp = float.Parse(result.Data["refiningExp"].Value);
                }
                string CraftingString = string.Empty;
                if (result.Data.ContainsKey("CraftingBuildBelt")){
                    CraftingString = result.Data["CraftingBuildBelt"].Value;
                }
                if (result.Data.ContainsKey("tactSpellOne")){
                    tactSpellOne = result.Data["tactSpellOne"].Value;
                }
                if (result.Data.ContainsKey("tactSpellTwo")){
                    tactSpellTwo = result.Data["tactSpellTwo"].Value;
                }
                if (result.Data.ContainsKey("fullCooldownData")){
                    fullCD = result.Data["fullCooldownData"].Value;
                }
                print($"{CraftingString} is our crafting string for login before mod! *****************");
                List<string> pulledCraftingItems = new List<string>();
                if (!string.IsNullOrEmpty(CraftingString)) {
                    // Assuming "|" was used to separate each crafting item
                    if(CraftingString != "0"){
                        if (CraftingString.Contains("|")) {
                            // If yes, split by "|"
                            pulledCraftingItems = CraftingString.Split('|').ToList();
                        } else {
                            // If no separator is found, assume it's a single item and add it directly
                            pulledCraftingItems.Add(CraftingString);
                        }
                    }
                    
                }
                //print($"{CraftingString} is our crafting string for login after mod! *****************");
                //print($"{pulledCraftingItems.Count} is our count for crafting builds still we need to build going into PLAYERINFO");
                if(GameMaster){
                    foreach(var item in ItemDataStorage.Instance.GetnftIDsReference()){
                        if(!nftIDs.Contains(item)){
                            nftIDs.Add(item);
                            //print($"Adding this item {item}");
                        }
                    }
                    nftIDs.Add("NFT_BowOfPower");
                    nftIDs.Add("NFT_GreatspearOfDragonslaying");
                    nftIDs.Add("NFT_AcidicAxe");
                    nftIDs.Add("NFT_MaceOfHealing");
                    nftIDs.Add("NFT_SpearOfDragonslaying");
                    nftIDs.Add("NFT_StaffOfProtection");
                    nftIDs.Add("NFT_SwordOfFire");
                    nftIDs.Add("NFT_ThunderInfusedGreathammer");
                    nftIDs.Add("NFT_VampiricDagger");
                    nftIDs.Add("NFT_VenomousGreataxe");
                    nftIDs.Add("NFT_FrozenGreatsword");

                }
            /*
            md5HashList.Add("0b887ab70ddba6465dbfd0fe57ffbcde");
            nftIDs.Add("0008138822E3CB09ED45B21B8729A283BA72BD5137ACBFBDE4F8C9070000000A");
            md5HashList.Add("aba2af3c46490ef57e6499cc6bb5a14a");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD9C2CFAD600000012");
            md5HashList.Add("7b89047acef4258560e61ae3d840214b");
            nftIDs.Add("000A271022E3CB09ED45B21B8729A283BA72BD5137ACBFBD931D4B84040D9215");
            md5HashList.Add("354463361aa3811371cb1fb04fb95c89");
            nftIDs.Add("000A271022E3CB09ED45B21B8729A283BA72BD5137ACBFBDEEB58F8C040D9219");
            md5HashList.Add("02fa6c02a8d3114f5f98baab5ad12546");
            nftIDs.Add("000A271022E3CB09ED45B21B8729A283BA72BD5137ACBFBD654A959C040D9213");
            md5HashList.Add("fed3e7d1a867676f6f073578476cf8c3");
            nftIDs.Add("0008271022E3CB09ED45B21B8729A283BA72BD5137ACBFBD20982084040D9210");
            md5HashList.Add("01d1155876809e3cb1e314b42c7ccd16");
            nftIDs.Add("0008271022E3CB09ED45B21B8729A283BA72BD5137ACBFBD4E6CC69C040D9212");
            md5HashList.Add("f68c40f0c741c534b58743cdb8cd5aca");
            nftIDs.Add("000A271022E3CB09ED45B21B8729A283BA72BD5137ACBFBD09B25184040D920F");
            md5HashList.Add("d4f69eea20f369ce300586c2f02ede23");
            nftIDs.Add("000A271022E3CB09ED45B21B8729A283BA72BD5137ACBFBD05925E8C040D921A");
            md5HashList.Add("589ef11ff0524dc067287a010c771d38");
            nftIDs.Add("000A271022E3CB09ED45B21B8729A283BA72BD5137ACBFBDC0E1E984040D9217");
            md5HashList.Add("348e70c7c5f0276de81fffcae9572eca");
            nftIDs.Add("000A271022E3CB09ED45B21B8729A283BA72BD5137ACBFBDA9FB1A84040D9216");
            md5HashList.Add("354da199096299319e3972ac02e31a6d");
            nftIDs.Add("000A271022E3CB09ED45B21B8729A283BA72BD5137ACBFBDD7CFB884040D9218");
            md5HashList.Add("e08518d24bd21cb17d9c27735b1a81fa");
            nftIDs.Add("0008271022E3CB09ED45B21B8729A283BA72BD5137ACBFBD3786F79C040D9211");
            md5HashList.Add("447ed1e049b6365e834d4a191b455cad");
            nftIDs.Add("000A271022E3CB09ED45B21B8729A283BA72BD5137ACBFBD7C37649C040D9214");
            md5HashList.Add("8abc8b74239115f2d8daf6de3ebc71a1");
            nftIDs.Add("0008138822E3CB09ED45B21B8729A283BA72BD5137ACBFBD0002F16D00000000"); //Arudine guild plot
            
            md5HashList.Add("523819ad5decced3d0d47a973ae921c6");
            nftIDs.Add("0008138822E3CB09ED45B21B8729A283BA72BD5137ACBFBD727FE54400000005"); //arudine property (house)

            md5HashList.Add("1e6e6632b80dee5b32dc963e0f95451f");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD3015E9E20000003A"); //Polished Belt

            md5HashList.Add("b4965b4fc0596fa3d435d08ef8bcc643");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBDAACA08C400000029"); //Polished Shoulders

            md5HashList.Add("475d0d0b3559491e342f3bf4c4c7cf0a");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBDEF7B7FE50000002C"); //Polished Vambraces

            md5HashList.Add("b76bb92c57cd2123ffe188d059f4a7e7");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD78E651E000000032"); //Polished Gauntlets

            md5HashList.Add("0f8c4777b63e3bd12df0921c06fb7209");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD02414BE700000038"); //Polished Leggings

            md5HashList.Add("37ab2c7db9b48920c6e6c846a80ba0da");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD06614CEB0000002D"); //Polished Helmet

            md5HashList.Add("b7242dbeaf65c574448e9a55ec5c9433");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD0EA1597E00000017"); //Polished Breastplate

            md5HashList.Add("394d7a352a495671510ac72664592534");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD3855E44800000024"); //Polished Bracer

            md5HashList.Add("f216d972356ad6d2b70ab260d5529958");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD6A399D510000001B"); //Polished Boots

            md5HashList.Add("a120b4707c1b541982bdce8ec1457a26");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD216F154800000023"); //Cured Sleeves

            md5HashList.Add("7e03a71b9a94210c80aa7d077185fecc");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBDC1B0D9DE0000002A"); //Cured Shoulders

            md5HashList.Add("d3db61752bdeabdc1ae7b47884185223");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBDD89EAEDB0000002B"); //Cured Cap

            md5HashList.Add("50b0690206aeb6e41b97c3a2c723fba9");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD46F3BEEE0000003B"); //Cured Belt
            //md5HashList.Add("50b0690206aeb6e41b97c3a2c723fba9");
            //nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBDDCBEA04800000020"); //Cured Boots

            md5HashList.Add("cf9595bfda5b674686c103a6be348536");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD3C75FB7A00000019"); //Cured Chest

            md5HashList.Add("a30bf1392362ce7fd251ef4f1b126567");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD4B13B3E200000030"); //Cured Leggings

            md5HashList.Add("1c09c38e2e022baa93df78ea2c6d28f6");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD8FCC26E100000033"); //Cured Hands

            //md5HashList.Add("50b0690206aeb6e41b97c3a2c723fba9");
            //nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBDAEEA0E480000001E"); //Cured Wrists

            md5HashList.Add("fe6181655cc440b65317d711f92c8924");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBDBD90C4E100000035"); //Reinforced Pants

            md5HashList.Add("ca5fcc437da8ba14be63cc6058037f9a");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBDEB5B7AE100000037"); //Reinforced Hood

            md5HashList.Add("6d8f89f16bad5b606eb398075e1f6dd9");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD192F18E200000039"); //Reinforced Belt

            md5HashList.Add("dfe6ec87e4e7e313f4542a3724eb9190");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD258F287E00000018"); //Reinforced Robe

            md5HashList.Add("7720a1b4ba10f54341c0e513e13197b4");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD7D06693800000027"); //Reinforced Cloak

            md5HashList.Add("feebe1c9f2933312d88f21b3cd9a9bc3");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD0A81424800000022"); //Reinforced Sleeves

            md5HashList.Add("e93eb9c4337afc4be16e8b0ace792044");
            nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBDD47E95E300000036"); //Reinforced Gloves

            //md5HashList.Add("e93eb9c4337afc4be16e8b0ace792044");
            //nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBDC5D0D1480000001F"); //Reinforced Shoes
            //
            //md5HashList.Add("e93eb9c4337afc4be16e8b0ace792044");
            //nftIDs.Add("000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD980C3F570000001D"); //Reinforced Wrist
            */

            /* Adapter for nfts
           
            */
                PlayerInfo playerinfo = new PlayerInfo {
                    GM = GameMaster,
                    tactAddress = tactAddy,
                    identifyEnemyKey = identityKey,
                    weaponCraftingSkill = weaponCraftingSkill,
                    armorCraftingSkill = armorCraftingSkill,
                    jewelCraftingSkill = jewelCraftingSkill,
                    FullCooldownData = fullCD,
                    spellOne = tactSpellOne,
                    spellTwo = tactSpellTwo,
                    cookingSkill = cookingSkill,
                    alchemySkill = alchemySkill,
                    refiningSkill = refiningSkill,
                    weaponCraftingExp = weaponCraftingExp,
                    armorCraftingExp = armorCraftingExp,
                    jewelCraftingExp = jewelCraftingExp,
                    cookingExp = cookingExp,
                    alchemyExp = alchemyExp,
                    refiningExp = refiningExp,
                    KnownWorldSegments = segments,
                    RepeatQuestCompleted = RepeatQuestCDList,
                    QuestInProgress = QuestProgressList,
                    QuestCompleted = CompletedQuestsList,
                    CraftingItems = pulledCraftingItems,
                    //Get the quests we need and also achievements from the objects we need to build for players
                    Energy = currentEnergy,
                    newPlayer = false, 
                    PlayFabId = playFabID,
                    PlayerName = tacticianNamePlayFab,
                    //SavedNode = savedNode,
                    SessionTicket = ticket,
                    PlayerSprite = pSprite,
                    CurrentScene = LastScene,
                    PartyIDs = Party,
                    PlayerLevel = pLvl,
                    PlayerExperience = pExp,
                    XRPLPUBLIC = publicAddress,
                    NFTIDS = nftIDs,
                    //NFTMD5Hash = md5HashList,
                    XRP = XRP,
                    DKP = DKP,
                    lastLogin = LastLogin,
                    TactBuildString = tactbuildString,
                    XStart = x,
                    YStart = y
                };
                nconn.authenticationData = playerinfo;
                //print($"{playerinfo.Energy} is energy, {playerinfo.PlayFabId} is PlayFabId, {playerinfo.PlayerName} is PlayerName, {playerinfo.PlayerSprite} is PlayerSprite, ");
                base.OnServerConnect(nconn);   
                StartCoroutine(WaitSeconds(nconn));
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
        }
        void CastGuildBuild(NetworkConnectionToClient nconn, string guildName){
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            string ticket = playerData.SessionTicket;
            string id = Guid.NewGuid().ToString();
            print("Create guild is currently disabled until further notice");
            //AuthenticateServer(ticket, id, guildName);
        }
        public void AuthenticateServer(string ticket, string guildId, string guildName)
    {
        var request = new AuthenticateSessionTicketRequest
        {
            SessionTicket = ticket  
        };

        PlayFabServerAPI.AuthenticateSessionTicket(request, 
            result => OnAuthenticateSuccess(result, ticket, guildId, guildName), 
            OnAuthenticateFailure);
    }

    private void OnAuthenticateSuccess(AuthenticateSessionTicketResult result, string ticket, string guildId, string guildName)
    {
        Debug.Log("Server authenticated successfully!");
        // Now you can create a guild or perform other operations
        string playerEntityId = result.UserInfo.TitleInfo.TitlePlayerAccount.Id;
        string playerEntityType = "title_player_account";
        CreateGuild(guildId, guildName, ticket, playerEntityId, playerEntityType);
    }

    private void OnAuthenticateFailure(PlayFabError error)
    {
        Debug.LogError("Error authenticating server: " + error.GenerateErrorReport());
    }
        public void CreateGuild(string guildId, string guildName, string ticket, string playerID, string entityType)
{
    var entityKey = new PlayFab.DataModels.EntityKey
    {
        Id = playerID,  // Replace with the appropriate entity ID
        Type = entityType  // You can also use "player" or other entity types
    };

    var objectData = new Dictionary<string, object>
    {
        { "GuildId", guildId },
        { "GuildName", guildName }
    };

    var setObjectRequest = new SetObjectsRequest
    {
        Entity = entityKey,
        Objects = new List<SetObject>
        {
            new SetObject
            {
                ObjectName = guildId,
                DataObject = objectData
            }
        }
    };

    PlayFabDataAPI.SetObjects(setObjectRequest, 
        result => Debug.Log("Guild created successfully."), 
        error => Debug.LogError("Error creating guild: " + error.GenerateErrorReport()));
}
            #endif

        IEnumerator WaitSeconds(NetworkConnectionToClient nconn){
            yield return new WaitForSeconds(3f);
            OnServerAddPlayer(nconn);
        }
        void LoginInventoryCheck(NetworkConnectionToClient nconn, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            
            PlayFabServerAPI.GetUserInventory(new GetUserInventoryRequest
            {
                PlayFabId = playerData.PlayFabId
            }, result =>
            {
                //print("Made call LoginInventoryCheck");
                // build tactician data we have everything we need now
                int gold = 0;
                Dictionary<string, int> currencies = result.VirtualCurrency;
                foreach(var key in currencies){
                    if(key.Key == "DK"){
                        gold = key.Value;
                        //print(gold);
                    }
                }
                nconn.authenticationData = playerData;
                List<ItemInstance> inventory = result.Inventory;
                string id = string.Empty;
                int tokens = 0;
                List<ItemSelectable> TacticianItems = new List<ItemSelectable>();
                List<string> NFTDictionary = new List<string>();
                if(inventory.Count > 0 && inventory != null){
                    for (int i = 0; i < inventory.Count; i++)
                    {
                        if(inventory[i].ItemId == "UniversalToken"){
                            id = inventory[i].ItemInstanceId; 
                            int? TokenQuant = inventory[i].RemainingUses;
                            if(TokenQuant.HasValue){
                                tokens = TokenQuant.Value;
                            }
                            continue;
                        }
                        bool tInv = false;
                        bool tEquip = false;
                        bool tBelt = false;
                        string Durability_item = "100";
                        string Quality_item = "Plain";
                        string equippedslot = "0";
                        int quantity = 1;
                        string OWNERID = "Tactician";
                        string NFTID = "NotNFT";
                        string engraving = "Plain";
                        foreach(var stat in inventory[i].CustomData){
                            if(stat.Key == "Engraving"){
                                engraving = stat.Value;
                            }
                            if(stat.Key == "Amount"){
                                quantity = int.Parse(stat.Value);
                            }
                            if(stat.Key == "NFTID"){
                                NFTID = stat.Value;
                            }
                            if(stat.Key == "Durability_item"){
                                Durability_item = stat.Value;
                            }
                            if(stat.Key == "Quality_item"){
                                Quality_item = stat.Value;
                            }
                            if(stat.Key == "EquippedSlot"){
                                equippedslot = stat.Value;
                                if(stat.Value != "0" && stat.Value != "Unequipped"){
                                    tEquip = true;
                                }
                            }
                            if(stat.Key == "TactInventory"){
                                string tactInv = null;
                                tactInv = stat.Value;
                                if(tactInv != null && tactInv == "InventoryItem" ){
                                    tInv = true;
                                }
                            }
                            if(stat.Key == "TactStash"){
                                string tactStash = null;
                                tactStash = stat.Value;
                                if(tactStash != null && tactStash == "Stashed" ){
                                    OWNERID = "Stash";
                                }
                            }
                            if(stat.Key == "TactBelt"){
                                string tactBelt = null;
                                tactBelt = stat.Value;
                                if(tactBelt != null && tactBelt == "Belted" ){
                                    tBelt = true;
                                }
                            }
                        }
                        if(tBelt || tInv || OWNERID == "Stash"){
                            tEquip = false;
                        }
                        ItemSelectable itemAdded = ItemDataStorage.Instance.BuildItemSelectable(OWNERID, Quality_item, quantity, NFTID, false, engraving, inventory[i].DisplayName, inventory[i].ItemInstanceId, inventory[i].ItemId, equippedslot, tBelt, tEquip, tInv, false, false, Durability_item, true, false);
                        if(NFTID != "NotNFT"){
                            NFTDictionary.Add(NFTID);
                        }
                        TacticianItems.Add(itemAdded);
                    }  
                }
                TacticianExtractor tactData = ParseClientData(playerData.TactBuildString);
                List<CharacterInventoryListItem> stash = new List<CharacterInventoryListItem>();
                List<CharacterInventoryListItem> tactInventory = new List<CharacterInventoryListItem>();
                foreach(var item in TacticianItems){
                    CharacterInventoryListItem newListItem = (new CharacterInventoryListItem { Key = item.GetInstanceID(), Value = item });
                    if(item.GetTacticianStash()){
                        stash.Add(newListItem);
                    } else {
                        tactInventory.Add(newListItem);
                    }
                }
                List<CharacterStatListItem> tacticianStats = new List<CharacterStatListItem>();
                CharacterStatListItem newLevelStat = (new CharacterStatListItem { Key = "LVL", Value = playerData.PlayerLevel });
                tacticianStats.Add(newLevelStat);
                CharacterStatListItem newEXPStat = (new CharacterStatListItem { Key = "EXP", Value = playerData.PlayerExperience });
                tacticianStats.Add(newEXPStat);
                CharacterStatListItem spriteStat = (new CharacterStatListItem { Key = "spriteTactician", Value = playerData.PlayerSprite });
                tacticianStats.Add(spriteStat);
                CharacterStatListItem newNameStat = (new CharacterStatListItem { Key = "TacticianName", Value = playerData.PlayerName });
                tacticianStats.Add(newNameStat);
                CharacterStatListItem GiantRepStat = (new CharacterStatListItem { Key = "GiantRep", Value = tactData.GiantRep});
                tacticianStats.Add(GiantRepStat);
                CharacterStatListItem DragonRepStat = (new CharacterStatListItem { Key = "DragonRep", Value = tactData.DragonRep });
                tacticianStats.Add(DragonRepStat);
                CharacterStatListItem LizardRepStat = (new CharacterStatListItem { Key = "LizardRep", Value = tactData.LizardRep });
                tacticianStats.Add(LizardRepStat);
                CharacterStatListItem OrcRepStat = (new CharacterStatListItem { Key = "OrcRep", Value = tactData.OrcRep });
                tacticianStats.Add(OrcRepStat);
                CharacterStatListItem FaerieStat = (new CharacterStatListItem { Key = "FaerieRep", Value = tactData.FaerieRep });
                tacticianStats.Add(FaerieStat);
                CharacterStatListItem ElfRepStat = (new CharacterStatListItem { Key = "ElfRep", Value = tactData.ElvesRep });
                tacticianStats.Add(ElfRepStat);
                CharacterStatListItem DwarfRepStat = (new CharacterStatListItem { Key = "DwarfRep", Value = tactData.DwarvesRep });
                tacticianStats.Add(DwarfRepStat);
                CharacterStatListItem GnomeRepStat = (new CharacterStatListItem { Key = "GnomeRep", Value = tactData.GnomesRep });
                tacticianStats.Add(GnomeRepStat);
                CharacterStatListItem idData = (new CharacterStatListItem { Key = "IdentifiedTargets", Value = playerData.identifyEnemyKey });
                tacticianStats.Add(idData);
                string dkpcd = tactData.DKPCooldown;
                if(tactData.DKPCooldown != "0"){
                    DateTime cdTime = DateTime.Parse(tactData.DKPCooldown);
                    DateTime timeNow = DateTime.Now;
                    TimeSpan timeSpan = timeNow - cdTime;
                    if(timeSpan.TotalHours >= 24){
                        dkpcd = "0";
                    }
                }
                float xrpfloat = float.Parse(playerData.XRP);
                float dkpfloat = float.Parse(playerData.DKP);
                List<CraftingListItem> craftingItems = new List<CraftingListItem>();
                print($"{playerData.CraftingItems.Count} is our count for crafting builds still we need to build");
                if(playerData.CraftingItems.Count > 0){
                    foreach(var craftString in playerData.CraftingItems){
                    print($"{craftString} is what we are building in craft table");
                        string[] parts = craftString.Split(';');
                        //craftingItem.OwnerName + ";" + DropString + ";" + craftingItem.Quality
                        if(parts.Length == 6){ 
                            bool dropBool = false;
                            if(parts[4] == "true"){
                                dropBool = true;
                            }
                            CraftingListItem CraftingItem = (new CraftingListItem{
                                ItemName = parts[0],
                                Time = parts[1],
                                Quant = int.Parse(parts[2]),
                                OwnerName = parts[3],
                                PriorQuality = parts[5],
                                Dropped = dropBool,
                                Finished = false,
                            });
                            (string itemID, int exp, int energy, int reqSkill, int craftTime, int craftMode, int maxStack) = CraftingRef.Instance.GetCraftingCosts(CraftingItem.ItemName);
                            string craftingMode = string.Empty;
                            if(craftMode == 1){
                                craftingMode = "weaponCraftingSkill";
                            }
                            if(craftMode == 2){
                                craftingMode = "armorCraftingSkill";
                            }
                            if(craftMode == 3){
                                craftingMode = "jewelCraftingSkill";
                            }
                            if(craftMode == 4){
                                craftingMode = "cookingSkill";
                            }
                            if(craftMode == 5){
                                craftingMode = "alchemySkill";
                            }
                            if(craftMode == 6){
                                craftingMode = "refiningSkill";
                            }
                            if(craftMode == 0){
                                craftingMode = "transmuting";
                            }
                            CraftingItem.Mode = craftingMode;
                            CraftingItem.reqSkill = reqSkill;
                            CraftingItem.exp = exp;
                            CraftingItem.energy = energy;
                            CraftingItem.ItemID = itemID;   
                            craftingItems.Add(CraftingItem);
                        }
                    }
                }
                string spellOneTact = "Empty";
                string spellOneCooldownTact = "Empty";
                string spellTwoTact = "Empty";
                string spellTwoCooldownTact = "Empty";
                if(playerData.spellOne != "Empty"){
                    string[] parts = playerData.spellOne.Split('_');
                    if(parts[0] != "Empty"){
                        spellOneTact = parts[0];
                    }
                    if(parts[1] != "Empty"){
                        spellOneCooldownTact = parts[1];
                    }
                }
                if(playerData.spellTwo != "Empty"){
                    string[] parts = playerData.spellTwo.Split('_');
                    if(parts[0] != "Empty"){
                        spellTwoTact = parts[0];
                    }
                    if(parts[1] != "Empty"){
                        spellTwoCooldownTact = parts[1];
                    }
                }
                List<CharacterCooldownListItem> tactCooldowns =  new List<CharacterCooldownListItem>();
                
                if(!string.IsNullOrEmpty(playerData.FullCooldownData)){
                    string[] CDparts = playerData.FullCooldownData.Split('|');
                    foreach(var part in CDparts){
                        string[] separatedParts = part.Split('_');
                        string cooldownTime = separatedParts[0];
                        string spellName = separatedParts[1];
                        CharacterCooldownListItem cooldownData = new CharacterCooldownListItem {
                            //PKey = spellName,
                            Value = cooldownTime,
                            SpellnameFull = spellName
                        };
                        print($"Adding {cooldownTime} to our cooldown {spellName} at beginning of the login process");
                        tactCooldowns.Add(cooldownData);
                    }
                }
                        print($"Made it to zodiac login");
                List<TacticianSpellListItem> tactSpells =  new List<TacticianSpellListItem>();
                string zodiacSign = "Empty";
                string elementalType = "Empty";
                (int selectedDay, int selectedMonth) = GetDate(tactData.BirthDate);
                if ((selectedMonth == 3 && selectedDay >= 21) || (selectedMonth == 4 && selectedDay <= 19))
                    zodiacSign = "Aries";
                else if ((selectedMonth == 4 && selectedDay >= 20) || (selectedMonth == 5 && selectedDay <= 20))
                    zodiacSign = "Taurus";
                else if ((selectedMonth == 5 && selectedDay >= 21) || (selectedMonth == 6 && selectedDay <= 21))
                    zodiacSign = "Gemini";
                else if ((selectedMonth == 6 && selectedDay >= 22) || (selectedMonth == 7 && selectedDay <= 22))
                    zodiacSign = "Cancer";
                else if ((selectedMonth == 7 && selectedDay >= 23) || (selectedMonth == 8 && selectedDay <= 22))
                    zodiacSign = "Leo";
                else if ((selectedMonth == 8 && selectedDay >= 23) || (selectedMonth == 9 && selectedDay <= 22))
                    zodiacSign = "Virgo";
                else if ((selectedMonth == 9 && selectedDay >= 23) || (selectedMonth == 10 && selectedDay <= 22))
                    zodiacSign = "Libra";
                else if ((selectedMonth == 10 && selectedDay >= 23) || (selectedMonth == 11 && selectedDay <= 21))
                    zodiacSign = "Scorpio";
                else if ((selectedMonth == 11 && selectedDay >= 22) || (selectedMonth == 12 && selectedDay <= 21))
                    zodiacSign = "Sagittarius";
                else if ((selectedMonth == 12 && selectedDay >= 22) || (selectedMonth == 1 && selectedDay <= 19))
                    zodiacSign = "Capricorn";
                else if ((selectedMonth == 1 && selectedDay >= 20) || (selectedMonth == 2 && selectedDay <= 18))
                    zodiacSign = "Aquarius";
                else if ((selectedMonth == 2 && selectedDay >= 19) || (selectedMonth == 3 && selectedDay <= 20))
                    zodiacSign = "Pisces";
                if (zodiacSign == "Aries") {
                    elementalType = "Fire";
                } else if (zodiacSign == "Taurus") {
                    elementalType = "Earth";
                } else if (zodiacSign == "Gemini") {
                    elementalType = "Air"; 
                } else if (zodiacSign == "Cancer") {
                    elementalType = "Water"; 
                } else if (zodiacSign == "Leo") {
                    elementalType = "Fire"; 
                } else if (zodiacSign == "Virgo") {
                    elementalType = "Earth"; 
                } else if (zodiacSign == "Libra") {
                    elementalType = "Air"; 
                } else if (zodiacSign == "Scorpio") {
                    elementalType = "Water"; 
                } else if (zodiacSign == "Sagittarius") {
                    elementalType = "Fire"; 
                } else if (zodiacSign == "Capricorn") {
                    elementalType = "Earth"; 
                } else if (zodiacSign == "Aquarius") {
                    elementalType = "Air"; 
                } else if (zodiacSign == "Pisces") {
                    elementalType = "Water"; 
                }
                string elementalSpell = "Empty";
                if(elementalType == "Fire"){
                    elementalSpell = "Ignite";
                }
                if(elementalType == "Air"){
                    elementalSpell = "Enthrall";
                }
                if(elementalType == "Water"){
                    elementalSpell = "Refresh";
                }
                if(elementalType == "Earth"){
                    elementalSpell = "Absorb";
                }
                TacticianSpellListItem elementalSpellData = new TacticianSpellListItem {
                    Key = elementalSpell
                };
                tactSpells.Add(elementalSpellData);
                //add spells here to give to tactician
                int playerLevel = int.Parse(playerData.PlayerLevel);
                Dictionary<int, string> spellsByLevel = new Dictionary<int, string>
                {
                    {1, "Morale Boost"},
                    {2, "Lightning Bolt"},
                    {3, "Repel"},
                    {4, "Mend"},
                    {5, "Light"},
                    {6, "Stun"},
                    {7, "Antidote"},
                    {8, "Fortification"},
                    {9, "Focus"},
                    {10, "Evacuate"},
                    {11, "Chain Lightning"},
                    {12, "Far Sight"},
                    {13, "Group Mend"},
                    {14, "Harvest Boost"},
                    {15, "Fertile Soil"},
                    {16, "Alliance"},
                    {17, "Growth"},
                    {18, "Return"},
                    {19, "Divine Resurrection"},
                    {20, "Rest"}
                };
                // Ensure we don't add duplicates if the method is called multiple times
                var existingSpells = new HashSet<string>(tactSpells.Select(spell => spell.Key));
                for (int level = 1; level <= playerLevel; level++)
                {
                    if (spellsByLevel.TryGetValue(level, out string spellName) && !existingSpells.Contains(spellName))
                    {
                        TacticianSpellListItem newSpell = new TacticianSpellListItem
                        {
                            Key = spellName
                        };
                        tactSpells.Add(newSpell);
                        existingSpells.Add(spellName); // Update existing spells to include the newly added spell
                    }
                }
                        print($"Elemental added, about to add our balance");

                TacticianFullDataMessage TacticianInfoSheet = (new TacticianFullDataMessage{
                    XRPBalance = xrpfloat.ToString("F2"),
                    DKPBalance = dkpfloat.ToString("F2"),
                    Address = playerData.XRPLPUBLIC,
                    TacticianAddress = playerData.tactAddress,
                    SpellOneEquipped = spellOneTact,
                    SpellOneCooldown = spellOneCooldownTact,
                    SpellTwoEquipped = spellTwoTact,
                    SpellTwoCooldown = spellTwoCooldownTact,
                    StashInventoryData = stash,
                    TacticianInventoryData = tactInventory,
                    TacticianStatData = tacticianStats,
                    TacticianSpellData = tactSpells,
                    TacticianCooldownData = tactCooldowns,
                    CraftingItems = craftingItems,
                    StrengthBonus = tactData.BonusStatStrength,
                    AgilityBonus = tactData.BonusStatAgility,
                    ArcanaBonus = tactData.BonusStatArcana,
                    FortitudeBonus = tactData.BonusStatFortitude,
                    ArmorBonus = tactData.BonusStatArmor,
                    EyeColor = tactData.EyeColor,
                    BodyStyle = tactData.BodyStyle,
                    Birthdate = tactData.BirthDate,
                    DKPCooldown = dkpcd,
                    tactString = playerData.PlayerSprite,
                    weaponCraftingSkill = playerData.weaponCraftingSkill,
                    armorCraftingSkill = playerData.armorCraftingSkill,
                    jewelCraftingSkill = playerData.jewelCraftingSkill,
                    cookingSkill = playerData.cookingSkill,
                    alchemySkill = playerData.alchemySkill,
                    refiningSkill = playerData.refiningSkill,
                    weaponCraftingExp = playerData.weaponCraftingExp,
                    armorCraftingExp = playerData.armorCraftingExp,
                    jewelCraftingExp = playerData.jewelCraftingExp,
                    cookingExp = playerData.cookingExp,
                    alchemyExp = playerData.alchemyExp,
                    refiningExp = playerData.refiningExp
                });
                ////print("Calling GetBalances");
                //StartCoroutine(GetBalances(nconn, playerData, tokens, TacticianInfoSheet, gold));
                        print($"GetCharacterList just before this method is last print outs");
                StartCoroutine(GetCharacterList(nconn, playerData, tokens, TacticianInfoSheet, gold, NFTDictionary)); 

                
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        public TacticianExtractor ParseClientData(string rawData)
        {
            string[] dataElements = rawData.Split('_');

            if (dataElements.Length != 18)
            {
                // Handle error - the rawData format is incorrect
                return null;
            }

            TacticianExtractor clientData = new TacticianExtractor
            {
                BirthDate = dataElements[0],
                ZodiacSign = dataElements[1],
                EyeColor = dataElements[2],
                BodyStyle = dataElements[3],
                BonusStatStrength = dataElements[4],
                BonusStatAgility = dataElements[5],
                BonusStatFortitude = dataElements[6],
                BonusStatArcana = dataElements[7],
                BonusStatArmor = dataElements[8],
                GiantRep = dataElements[9],
                DragonRep = dataElements[10],
                LizardRep = dataElements[11],
                OrcRep = dataElements[12],
                FaerieRep = dataElements[13],
                ElvesRep = dataElements[14],
                DwarvesRep = dataElements[15],
                GnomesRep = dataElements[16],
                DKPCooldown = dataElements[17]
            };

            return clientData;
        }
/*

        #if UNITY_SERVER //|| UNITY_EDITOR

    private IEnumerator GetBalances(NetworkConnectionToClient nconn, PlayerInfo playerData, int tokenCount, TacticianFullDataMessage TacticianInfoSheet, int gold)
    {
        //use PlayfabID to fetch our wallet from playfab
        string address = "";
        string url = $"https://data.ripple.com/v2/accounts/{address}/balances";
        UnityWebRequest www = UnityWebRequest.Get(url);
        yield return www.SendWebRequest();

        if (www.result != UnityWebRequest.Result.Success)
        {
            Debug.Log(www.error);
        }
        else
        {
            string jsonResponse = www.downloadHandler.text;
            XRPLResponse response = JsonUtility.FromJson<XRPLResponse>(jsonResponse);

            string XRP = "";
            string DKP = "";

            foreach (Balance balance in response.balances)
            {
                if (balance.currency == "XRP")
                {
                    XRP = balance.value;
                }
                else if (balance.currency == "DKP")
                {
                    DKP = balance.value;
                }
            }
            TacticianFullDataMessage updatedTacticianInfoSheet = TacticianInfoSheet;
            updatedTacticianInfoSheet.XRPBalance = XRP;
            updatedTacticianInfoSheet.DKPBalance = DKP;
            StartCoroutine(GetCharacterList(nconn, playerData, tokenCount, updatedTacticianInfoSheet, gold)); 
            // You can now parse the response JSON to get the balances.
            // Consider using a JSON library like SimpleJSON or JsonUtility to parse the response.
        }
    }
        #endif
     */
        #if UNITY_SERVER //|| UNITY_EDITOR


    IEnumerator GetCharacterList(NetworkConnectionToClient nconn, PlayerInfo playerData, int tokenCount, TacticianFullDataMessage TacticianInfoSheet, int gold, List<string> NFTsInWallet){
        //print("Calling GetCharacterList");
        var charactersReady = false;
        List<CharacterResult> characters = null;
        PlayFabServerAPI.GetAllUsersCharacters(new ListUsersCharactersRequest
        {
            PlayFabId = playerData.PlayFabId
        }, result =>
        {
            characters = result.Characters;
            charactersReady = true;
        }, error =>
        {
            Debug.Log(error.ErrorMessage);
        });
        yield return new WaitUntil(() => charactersReady);
        GameObject player = Instantiate(playerPrefab);
        player.name = $"{playerPrefab.name} [connId={nconn.connectionId}]";
        NetworkServer.AddPlayerForConnection(nconn, player);
        ScenePlayer p = player.GetComponent<ScenePlayer>();
       
       // p.TargetToggleSprite(false, p.loadSprite);
        p.x = playerData.XStart;
        p.y = playerData.YStart;
        nconn.authenticationData = playerData;

        bool townBound = false;
        List<string> CharacterList = new List<string>();
        bool deletingCharacters = false;
        var DeletionReady = false;
        List<string> DeletionList = new List<string>();
        if(characters == null || characters.Count < 1){
            townBound = true;
        } else {
            //print("Building charList ");

            for (int i = 0; i < characters.Count; i++)
            {
                var characterDataReady = false;
                Dictionary<string, UserDataRecord> characterData = null;
                PlayFabServerAPI.GetCharacterInternalData(new GetCharacterDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    CharacterId = characters[i].CharacterId
                }, result =>
                {
                    characterData = result.Data;
                    characterDataReady = true;
                }, error =>
                {
                    Debug.Log(error.ErrorMessage);
                });
                yield return new WaitUntil(() => characterDataReady);
                //yield return new WaitForSeconds(.1f);
                // Check if the character is inactive
                if (characterData.ContainsKey("ResetCharacter") && characterData["ResetCharacter"].Value == "R")
                {
                    deletingCharacters = true;
                    //print($"Skipping {characters[i].CharacterName} because it is inactive");
                    DeletionList.Add(characters[i].CharacterId);
                }
                else
                {
                    // The character is not inactive, so add it to the list
                    if (!CharacterList.Contains(characters[i].CharacterId))
                    {
                        CharacterList.Add(characters[i].CharacterId);
                        //print($"Adding {characters[i].CharacterName} to the list");
                    }
                }
            }
            if(playerData.PartyIDs == null || playerData.PartyIDs.Count < 1){
                townBound = true;
            }
        }
        //print("Calling ProcessCharacterList");
        if(deletingCharacters){
            for(int j = 0; j < DeletionList.Count; j++){
                var characterDeletionReady = false;

                PlayFabServerAPI.DeleteCharacterFromUser(new DeleteCharacterFromUserRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    CharacterId = DeletionList[j],
                    SaveCharacterInventory = false // Set this to false to not save character's inventory
                }, result =>
                {
                    //print($"Character {DeletionList[j]} has been deleted successfully.");
                    characterDeletionReady = true;
                }, error =>
                {
                    Debug.Log(error.ErrorMessage);
                });

                yield return new WaitUntil(() => characterDeletionReady);
                //yield return new WaitForSeconds(.1f);

            }
            DeletionReady = true;
        } else {
            DeletionReady = true;
        }
        yield return new WaitUntil(() => DeletionReady);
        //yield return new WaitForSeconds(.1f);

        StartCoroutine(ProcessCharacterList(nconn, playerData, CharacterList, townBound, tokenCount, TacticianInfoSheet, gold, NFTsInWallet));
    }
#endif

    //void SetUserWeight(NetworkConnectionToClient nconn, PlayerInfo playerData, string ID, string weight, int Tokens, Dictionary<string, ItemSelectable> TacticianItems, int gold, string BeltWeight){
    //    PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
    //        {
    //            PlayFabId = playerData.PlayFabId,
    //            Data = new Dictionary<string, string>
    //            {
    //                {"currentWeight", weight}
    //            }
    //        }, result =>{
    //            GetCharacterList(nconn, playerData, Tokens, TacticianItems, gold, weight, BeltWeight); 
    //        }, error =>{
    //            Debug.Log(error.ErrorMessage); 
    //            Debug.Log(error.ErrorDetails);
    //            Debug.Log(error.Error);
    //        });  
    //}
   /*
   void GetCharacterList(NetworkConnectionToClient nconn, PlayerInfo playerData, int tokenCount, TacticianFullDataMessage TacticianInfoSheet, int gold)
    {   
        //print("Calling GetCharacterList");

        PlayFabServerAPI.GetAllUsersCharacters(new ListUsersCharactersRequest
        {
            PlayFabId = playerData.PlayFabId
        }, result =>
        {
            GameObject player = Instantiate(playerPrefab);
            player.name = $"{playerPrefab.name} [connId={nconn.connectionId}]";
            NetworkServer.AddPlayerForConnection(nconn, player);
            ScenePlayer p = player.GetComponent<ScenePlayer>();
            p.TargetToggleSprite(false, p.loadSprite);
            //p.TacticianStatList.Add("currentWeight", weight);
            //p.TacticianStatList.Add("currentBelt", beltWeight);
            //p.TacticianStatList.Add("LVL", "3");
            //p.TacticianStatList.Add("EXP", "8800");
            //p.TacticianName = playerData.PlayerName;
            //foreach(var key in TacticianItems){
            //    PassLoginItemToStash(nconn, key.Value);
            //}
            nconn.authenticationData = playerData;
                
            bool townBound = false;
            List<string> CharacterList = new List<string>();
            List<CharacterResult> characters = result.Characters;
            if(result.Characters == null){
                townBound = true;
            } else {
                if(characters.Count < 1){
                    townBound = true;
                }
            //print("Building charList ");

            for (int i = 0; i < characters.Count; i++)
                {
                    if(!CharacterList.Contains(characters[i].CharacterId)){
                        CharacterList.Add(characters[i].CharacterId);
                        //print($"Adding {characters[i].CharacterName} to the list");
                    }
                }
                if(playerData.PartyIDs == null ){
                    townBound = true;
                } else {
                    if(playerData.PartyIDs.Count < 1 || result.Characters.Count < 1){
                        townBound = true;
                    }
                }
            }
            //print("Calling ProcessCharacterList");
                
            StartCoroutine(ProcessCharacterList(nconn, playerData, CharacterList, townBound, tokenCount, TacticianInfoSheet, gold));
        }, error =>{
            Debug.Log(error.ErrorMessage);
        });
    }
    */
        #if UNITY_SERVER //|| UNITY_EDITOR

    IEnumerator ProcessCharacterList(NetworkConnectionToClient nconn, PlayerInfo playerData, List<string> CharacterList, bool townRidden, int tokenCount, TacticianFullDataMessage TacticianInfoSheet, int gold, List<string> NFTsInWallet){
            
        ScenePlayer p = nconn.identity.gameObject.GetComponent<ScenePlayer>();
        List<string> AddToPartyList = playerData.PartyIDs;
        Dictionary<string, CharacterFullDataMessage> Sheets = new Dictionary<string, CharacterFullDataMessage>();
        if(CharacterList.Count >= 1){
        foreach(var _key in CharacterList)
        {
            //print("Calling GetCharacterInternalData");
            var charactersReady = false;
            GetCharacterDataRequest request = new GetCharacterDataRequest();
            request.PlayFabId = playerData.PlayFabId;
            request.CharacterId = _key;
            PlayFabServerAPI.GetCharacterInternalData(request,
            result =>
            {   
                List<CharacterStatListItem> charStats = new List<CharacterStatListItem>();
                List<CharacterSpellListItem> charSpells = new List<CharacterSpellListItem>();
                List<CharacterCooldownListItem> charCooldowns = new List<CharacterCooldownListItem>();
                List<CharacterBuffListItem> charBuffs = new List<CharacterBuffListItem>();

                CharacterStatListItem LEVELINGStat = (new CharacterStatListItem{
                    Key = "dud",
                    Value = "dud"
                });
                CharacterStatListItem LVLStat = (new CharacterStatListItem{
                    Key = "LVL",
                    Value = "1"
                });
                bool leveledUpOverTime = false;
                //int lvl = 0;
                string charID = string.Empty;
                string dateTimeWithZone = DateTime.UtcNow.ToString("o");
                DateTime currentTimeUtc = DateTime.UtcNow;
                int miningSkill = 1;
                int woodCuttingSkill = 1;
                int prospectingSkill = 1;
                int foragingSkill = 1;
                int skinningSkill = 1;
                float miningEXP = 1f;
                float woodCuttingEXP = 1f;
                float prospectingEXP = 1f;
                float foragingEXP = 1f;
                float skinningEXP = 1f;
                string BuffSavedData = string.Empty;
                foreach(var data in result.Data){
                    if(data.Key == "buffSavedData"){
                        BuffSavedData = data.Value.Value;
                    }
                    if(data.Key == "trackingData"){
                        CharacterStatListItem trackingStat = (new CharacterStatListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charStats.Add(trackingStat);
                    }
                    if(data.Key == "miningEXP"){
                        miningEXP = float.Parse(data.Value.Value);
                        //print("This is miningEXP " + miningEXP);
                    }
                    if(data.Key == "woodCuttingEXP"){
                        woodCuttingEXP = float.Parse(data.Value.Value);
                        //print("This is woodCuttingEXP " + woodCuttingEXP);
                    }
                    if(data.Key == "prospectingEXP"){
                        prospectingEXP = float.Parse(data.Value.Value);
                        //print("This is prospectingEXP " + prospectingEXP);
                    }
                    if(data.Key == "foragingEXP"){
                        foragingEXP = float.Parse(data.Value.Value);
                        //print("This is foragingEXP " + foragingEXP);
                    }
                    if(data.Key == "skinningEXP"){
                        skinningEXP = float.Parse(data.Value.Value);
                        //print("This is skinningEXP " + skinningEXP);
                    }
                    if(data.Key == "miningSkill"){
                        miningSkill = int.Parse(data.Value.Value);
                        //print("This is miningSkill " + miningSkill);
                    }
                    if(data.Key == "woodCuttingSkill"){
                        woodCuttingSkill = int.Parse(data.Value.Value);
                        //print("This is woodCuttingSkill " + woodCuttingSkill);
                    }
                    if(data.Key == "prospectingSkill"){
                        prospectingSkill = int.Parse(data.Value.Value);
                        //print("This is prospectingSkill " + prospectingSkill);
                    }
                    if(data.Key == "foragingSkill"){
                        foragingSkill = int.Parse(data.Value.Value);
                        //print("This is foragingSkill " + foragingSkill);
                    }
                    if(data.Key == "skinningSkill"){
                        skinningSkill = int.Parse(data.Value.Value);
                        //print("This is skinningSkill " + skinningSkill);
                    }
                    if(data.Key == "LEVELING"){
                        //DateTime initialTime = DateTime.Parse(dateTimeWithZone);
                        
                       // DateTime completedTime = DateTime.Parse(data.Value.Value);
                //DateTime currentTimeUtc = DateTime.UtcNow;
                       print($"{currentTimeUtc} = time now for the level up");
                        DateTime completedTime = DateTime.Parse(data.Value.Value, null, System.Globalization.DateTimeStyles.RoundtripKind);
                        TimeSpan timeLeft = completedTime - currentTimeUtc;
                        int remainingSeconds = (int)timeLeft.TotalSeconds;
                        if (remainingSeconds < 0) {
                            LEVELINGStat.Key = data.Key;
                            LEVELINGStat.Value = data.Value.Value;
                            charStats.Add(LEVELINGStat);
                            print($"CHAR WAS STILL LEVELING!!");

                        } else {
                            leveledUpOverTime = true;

                        }
                        print($"Completed time for this level is {completedTime}, time left is {remainingSeconds}");
                    }
                    if(data.Key == "COOLDOWNS"){
                        List<(string completedTime, string spellNameFull)> cooldownList = SplitCombinedValue(data.Value.Value);
                        foreach(var listitem in cooldownList){
                            DateTime completedTime = DateTime.Parse(listitem.completedTime, null, System.Globalization.DateTimeStyles.RoundtripKind);
                            TimeSpan timeLeft = completedTime - currentTimeUtc;
                            int remainingSeconds = (int)timeLeft.TotalSeconds;
                            if (remainingSeconds > 0) {
                                CharacterCooldownListItem Cooldown = (new CharacterCooldownListItem{
                                    Value = listitem.completedTime,
                                    SpellnameFull = listitem.spellNameFull,
                                    //Position = "SPELLQ"
                                });
                                print($"{listitem.spellNameFull} is the spellname goin on CD");
                                charCooldowns.Add(Cooldown);
                            } else {
                                print($"COOLDOWNQ was off cooldown");
                            }
                        }
                    }
                    /*
                    if(data.Key == "COOLDOWNQ"){
                        //data.Value.Value
                        SplitCombinedValue(data.Value.Value, out string value, out string spellnamefull);
                        DateTime completedTime = DateTime.Parse(value, null, System.Globalization.DateTimeStyles.RoundtripKind);
                        TimeSpan timeLeft = completedTime - currentTimeUtc;
                        int remainingSeconds = (int)timeLeft.TotalSeconds;
                        if (remainingSeconds > 0) {
                            CharacterCooldownListItem CooldownE = (new CharacterCooldownListItem{
                                PKey = "COOLDOWNE",
                                Value = value,
                                SpellnameFull = spellnamefull,
                                Position = "SPELLE"
                            });
                            print($"{CooldownE.PKey} is the Pkey and {CooldownE.SpellnameFull} is the spellname");
                            charCooldowns.Add(CooldownE);
                        } else {
                            print($"COOLDOWNE was off cooldown");
                        }
                    }
                    if(data.Key == "COOLDOWNE"){
                        //data.Value.Value
                        SplitCombinedValue(data.Value.Value, out string value, out string spellnamefull);
                        DateTime completedTime = DateTime.Parse(value, null, System.Globalization.DateTimeStyles.RoundtripKind);
                        TimeSpan timeLeft = completedTime - currentTimeUtc;
                        int remainingSeconds = (int)timeLeft.TotalSeconds;
                        if (remainingSeconds > 0) {
                            CharacterCooldownListItem CooldownE = (new CharacterCooldownListItem{
                                PKey = "COOLDOWNE",
                                Value = value,
                                SpellnameFull = spellnamefull,
                                Position = "SPELLE"
                            });
                            print($"{CooldownE.PKey} is the Pkey and {CooldownE.SpellnameFull} is the spellname");
                            charCooldowns.Add(CooldownE);
                        } else {
                            print($"COOLDOWNE was off cooldown");
                        }
                    }
                    if(data.Key == "COOLDOWNR"){
                        //data.Value.Value
                        SplitCombinedValue(data.Value.Value, out string value, out string spellnamefull);
                        DateTime completedTime = DateTime.Parse(value, null, System.Globalization.DateTimeStyles.RoundtripKind);
                        TimeSpan timeLeft = completedTime - currentTimeUtc;
                        int remainingSeconds = (int)timeLeft.TotalSeconds;
                        if (remainingSeconds > 0) {
                            CharacterCooldownListItem CooldownR = (new CharacterCooldownListItem{
                                PKey = "COOLDOWNR",
                                Value = value,
                                SpellnameFull = spellnamefull,
                                Position = "SPELLR"
                            });
                            print($"{CooldownR.PKey} is the Pkey and {CooldownR.SpellnameFull} is the spellname");
                            charCooldowns.Add(CooldownR);
                        } else {
                            print($"COOLDOWNR was off cooldown");
                        }
                    }
                    if(data.Key == "COOLDOWNF"){
                        SplitCombinedValue(data.Value.Value, out string value, out string spellnamefull);
                        DateTime completedTime = DateTime.Parse(value, null, System.Globalization.DateTimeStyles.RoundtripKind);
                        TimeSpan timeLeft = completedTime - currentTimeUtc;
                        int remainingSeconds = (int)timeLeft.TotalSeconds;
                        if (remainingSeconds > 0) {
                            CharacterCooldownListItem CooldownF = (new CharacterCooldownListItem{
                                PKey = "COOLDOWNF",
                                Value = value,
                                SpellnameFull = spellnamefull,
                                Position = "SPELLF"
                            });
                            print($"{CooldownF.PKey} is the Pkey and {CooldownF.SpellnameFull} is the spellname");
                            charCooldowns.Add(CooldownF);
                        } else {
                            print($"COOLDOWNF was off cooldown");
                        }
                    }
                    */
                    if(data.Key == "DEATH"){
                        CharacterStatListItem DEATHStat = (new CharacterStatListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charStats.Add(DEATHStat);
                    }
                    if(data.Key == "LVL"){
                        //lvl = int.Parse(data.Value.Value);
                        //CharacterStatListItem LVLStat = (new CharacterStatListItem{
                        //    Key = data.Key,
                        //    Value = data.Value.Value
                        //});
                        LVLStat.Value = data.Value.Value;
                    }
                    if(data.Key == "EXP"){
                        CharacterStatListItem EXPStat = (new CharacterStatListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charStats.Add(EXPStat);
                    }
                    
                    if(data.Key == "currentHP"){
                        CharacterStatListItem currentHPStat = (new CharacterStatListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charStats.Add(currentHPStat);
                    }
                    if(data.Key == "currentMP"){
                        CharacterStatListItem currentMPStat = (new CharacterStatListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charStats.Add(currentMPStat);
                    }
                    //if(data.Key == "LEVELING"){
                    //    CharacterStatListItem LEVELINGStat = (new CharacterStatListItem{
                    //        Key = data.Key,
                    //        Value = data.Value.Value
                    //    });
                    //    charStats.Add(LEVELINGStat);
                    //}
                    if(data.Key == "Class"){
                        CharacterStatListItem ClassStat = (new CharacterStatListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charStats.Add(ClassStat);
                    }
                    if(data.Key == "CharName"){
                        CharacterStatListItem CharNameStat = (new CharacterStatListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charStats.Add(CharNameStat);
                    }
                    if(data.Key == "CharacterID"){
                        CharacterStatListItem CharacterIDStat = (new CharacterStatListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charID = data.Value.Value;
                        charStats.Add(CharacterIDStat);
                    }
                    if(data.Key == "CharacterSprite"){
                        CharacterStatListItem CharacterSpriteStat = (new CharacterStatListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charStats.Add(CharacterSpriteStat);
                    }
                    if(data.Key == "CORE"){
                        CharacterStatListItem COREStat = (new CharacterStatListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charStats.Add(COREStat);
                    }
                    if(data.Key == "ClassPoints"){
                        CharacterStatListItem ClassPointsStat = (new CharacterStatListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charStats.Add(ClassPointsStat);
                    }
                    if(data.Key == "SPELLQ"){
                        CharacterSpellListItem SPELLQSpell = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(SPELLQSpell);
                    }
                    if(data.Key == "SPELLE"){
                        CharacterSpellListItem SPELLESpell = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(SPELLESpell);
                    }
                    if(data.Key == "SPELLR"){
                        CharacterSpellListItem SPELLRSpell = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(SPELLRSpell);
                    }
                    if(data.Key == "SPELLF"){
                        CharacterSpellListItem SPELLFSpell = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(SPELLFSpell);
                    }
                    if(data.Key == "StartClassSkill"){
                        CharacterSpellListItem StartClassSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(StartClassSkill);
                    }
                    if(data.Key == "WestT1Skill"){
                        CharacterSpellListItem WestT1Skill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(WestT1Skill);
                    }
                    if(data.Key == "WestT2TopSkill"){
                        CharacterSpellListItem WestT2TopSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(WestT2TopSkill);
                    }
                    if(data.Key == "WestT2MiddleSkill"){
                        CharacterSpellListItem WestT2Middle = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(WestT2Middle);
                    }
                    if(data.Key == "WestT2BottomSkill"){
                        CharacterSpellListItem WestT2BottomSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(WestT2BottomSkill);
                    }
                    if(data.Key == "WestT3TopSkill"){
                        CharacterSpellListItem WestT3TopSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(WestT3TopSkill);
                    }
                    if(data.Key == "WestT3BottomSkill"){
                        CharacterSpellListItem WestT3BottomSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(WestT3BottomSkill);
                    }
                    if(data.Key == "WestT3EndSkill"){
                        CharacterSpellListItem WestT3EndSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(WestT3EndSkill);
                    }
                    if(data.Key == "EastT1Skill"){
                        CharacterSpellListItem EastT1Skill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(EastT1Skill);
                    }
                    if(data.Key == "EastT2TopSkill"){
                        CharacterSpellListItem EastT2TopSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(EastT2TopSkill);
                    }
                    if(data.Key == "EastT2MiddleSkill"){
                        CharacterSpellListItem EastT2MiddleSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(EastT2MiddleSkill);
                    }
                    if(data.Key == "EastT2BottomSkill"){
                        CharacterSpellListItem EastT2BottomSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(EastT2BottomSkill);
                    }
                    if(data.Key == "EastT3TopSkill"){
                        CharacterSpellListItem EastT3TopSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(EastT3TopSkill);
                    }
                    if(data.Key == "EastT3BottomSkill"){
                        CharacterSpellListItem EastT3BottomSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(EastT3BottomSkill);
                    }
                    if(data.Key == "EastT3EndSkill"){
                        CharacterSpellListItem EastT3EndSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(EastT3EndSkill);
                    }
                    if(data.Key == "SouthT1Skill"){
                        CharacterSpellListItem SouthT1Skill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(SouthT1Skill);
                    }
                    if(data.Key == "SouthT2LeftSkill"){
                        CharacterSpellListItem SouthT2LeftSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(SouthT2LeftSkill);
                    }
                    if(data.Key == "SouthT2MiddleSkill"){
                        CharacterSpellListItem SouthT2MiddleSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(SouthT2MiddleSkill);
                    }
                    if(data.Key == "SouthT2RightSkill"){
                        CharacterSpellListItem SouthT2RightSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(SouthT2RightSkill);
                    }
                    if(data.Key == "SouthT3LeftSkill"){
                        CharacterSpellListItem SouthT3LeftSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(SouthT3LeftSkill);
                    }
                    if(data.Key == "SouthT3RightSkill"){
                        CharacterSpellListItem SouthT3RightSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(SouthT3RightSkill);
                    }
                    if(data.Key == "SouthT3EndSkill"){
                        CharacterSpellListItem SouthT3EndSkill = (new CharacterSpellListItem{
                            Key = data.Key,
                            Value = data.Value.Value
                        });
                        charSpells.Add(SouthT3EndSkill);
                    }
                }
                if(leveledUpOverTime){
                    int currentLevel = int.Parse(LVLStat.Value); // Parse "LVL" to an integer
                    currentLevel++; // Increment the level
                    LVLStat.Value = currentLevel.ToString();
                    charStats.Add(LVLStat);
                } else {
                    charStats.Add(LVLStat);
                }
                if (!string.IsNullOrEmpty(BuffSavedData)) {
                    print(BuffSavedData + " is our buffsaved data start");
                    // Split the BuffSavedData string into individual buff data strings
                    string[] buffItems = BuffSavedData.Split(';');
                    foreach (string buffItem in buffItems) {
                        if (!string.IsNullOrEmpty(buffItem)) {
                            print(buffItem + " is our buffItem data");

                            // Split each item into Key, Value, and Time (seconds)
                            string[] parts = buffItem.Split('_');
                            if (parts.Length == 5) {
                                print(parts[2] + " is our buff time left");
                                print(parts[0] + " is our buff name");
                                print(parts[1] + " is our buff value");
                                // Parse the seconds from parts[2]
                                if (int.TryParse(parts[2], out int secondsLeft)) {
                                    // Calculate the new expiration time by adding the seconds to the current UTC time
                                    DateTime expirationTimeUtc = currentTimeUtc.AddSeconds(secondsLeft);
                                    print(secondsLeft + " is our buff time left in seconds");
                                    print("our new time is " + expirationTimeUtc);
                                    // Create a new CharacterBuffListItem from the parts
                                    (bool potionCheck, bool foodCheck) = PotionFoodCheck(parts[0]);

                                    CharacterBuffListItem item = new CharacterBuffListItem {
                                        Key = parts[0],
                                        Value = parts[1],
                                        Time = expirationTimeUtc.ToString("o"),
                                        Duration = parts[3],
                                        FoodBuff = foodCheck,
                                        PotionBuff = potionCheck,
                                        Rank = int.Parse(parts[4])
                                    };
                                    // Add the new item to the list
                                    charBuffs.Add(item);
                                }
                            }
                        }
                    }
                }
                CharacterFullDataMessage charPage = (new CharacterFullDataMessage{
                    skinningSkill = skinningSkill,
                    skinningExp = skinningEXP,
                    miningSkill = miningSkill,
                    miningExp = miningEXP,
                    prospectingSkill = prospectingSkill,
                    prospectingExp = prospectingEXP,
                    foragingSkill = foragingSkill,
                    foragingExp = foragingEXP,
                    woodCuttingSkill = woodCuttingSkill,
                    woodCuttingExp = woodCuttingEXP,
                    CharacterID = _key,
                    CharSpellData = charSpells,
                    CharStatData = charStats,
                    CharCooldownData = charCooldowns,
                    CharBuffData = charBuffs
                });

                if (!Sheets.ContainsKey(_key)){
                    Sheets.Add(_key, charPage);
                } else {
                    Debug.LogWarning("Key already exists in Sheets dictionary: " + _key);
                }
                charactersReady = true;
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            yield return new WaitUntil(() => charactersReady);
        }
        }


        string sceneSelect = playerData.CurrentScene;
        if(townRidden){
            sceneSelect = TOWNOFARUDINE;
        }
        p.SetPlayerData(playerData);
        //p.TokenCounted(tokenCount);
            //print("Calling GetAllCharacterInventory");
        //update their cooldown stuff in playfab from here
        StartCoroutine(GetAllCharacterInventory(nconn, playerData, townRidden, tokenCount, gold, TacticianInfoSheet, Sheets, NFTsInWallet));
    }
        #endif
        public (bool, bool) PotionFoodCheck(string buffName){
            bool potionCheck = false;
            bool foodCheck = false;
            if(buffName == "Arudine Pie"){
                foodCheck = true;
            }
            if(buffName =="Snake Pie"){
                foodCheck = true;
            }
            if(buffName == "Rat Skewer"){
                foodCheck = true;
            }
            if(buffName == "Sauerkraut"){
                foodCheck = true;
            }
            if(buffName == "Lobster Jerky"){
                foodCheck = true;
            }
            if(buffName == "Shishkabob"){
                foodCheck = true;
            }
            if(buffName == "Sticky Rat Skewer"){
                foodCheck = true;
            }
            if(buffName == "Healing Potion"){
                potionCheck = true;
            }
            if(buffName == "Magic Potion"){
                potionCheck = true;
            }
            if(buffName == "Haste Potion"){
                potionCheck = true;
            }
            if(buffName == "Greater Haste Potion"){
                potionCheck = true;
            }
            if(buffName == "Greater Defense Potion"){
                potionCheck = true;
            }
            if(buffName == "Lifesteal Potion"){
                potionCheck = true;
            }
            if(buffName == "Rejuvenation Potion"){
                potionCheck = true;
            }
            print(potionCheck + " was potion check and " + foodCheck + " was food check for " + buffName);
            return (potionCheck, foodCheck);
        }
        #if UNITY_SERVER //|| UNITY_EDITOR

    IEnumerator GetAllCharacterInventory(NetworkConnectionToClient nconn, PlayerInfo playerData, bool townRidden, int tokenCount, int gold, TacticianFullDataMessage TacticianInfoSheet, Dictionary<string, CharacterFullDataMessage> Sheets, List<string> NFTsInWallet){
        ScenePlayer p = nconn.identity.gameObject.GetComponent<ScenePlayer>();
         p.SpellOne = TacticianInfoSheet.SpellOneEquipped;
        string spellOneCooldownStr = TacticianInfoSheet.SpellOneCooldown; // Assuming this is the string you want to parse
        if (!string.IsNullOrEmpty(spellOneCooldownStr))
        {
            DateTime currentTimeUtc = DateTime.UtcNow;
            try
            {
                DateTime completedTime = DateTime.Parse(spellOneCooldownStr, null, System.Globalization.DateTimeStyles.RoundtripKind);
                TimeSpan timeLeft = completedTime - currentTimeUtc;
                int remainingSeconds = (int)timeLeft.TotalSeconds;

                if (remainingSeconds > 0)
                {
                    p.ServerBuildTacticianSpellCooldownLogin(remainingSeconds, 1);
                    //p.CooldownSpellOne = remainingSeconds;
                    //p.TactSpellOne = true;
                    //if (p.abilityOneCDRoutine != null)
                    //{
                    //    p.StopCoroutine(p.abilityOneCDRoutine);
                    //}
                    //p.abilityOneCDRoutine = p.StartCoroutine(p.SetAbilityCoolDownOne(remainingSeconds));
                }
                else
                {
                    p.CooldownSpellOne = 0;
                    Debug.Log("CooldownSpellOne was off cooldown");
                }
            }
            catch (FormatException)
            {
                // Handle the situation where spellOneCooldownStr could not be parsed to a DateTime
                Debug.LogError("spellOneCooldownStr could not be parsed to a DateTime. Ensure the string is in a correct format.");
                // Optionally, set CooldownSpellOne to a default value or handle this case as needed
            }
        }
        else
        {
            p.CooldownSpellOne = 0;
            // Handle the case where spellOneCooldownStr is null or empty
            Debug.LogError("spellOneCooldownStr is null or empty. Cooldown cannot be calculated.");
            // Optionally, set CooldownSpellOne to a default value or handle this case as needed
        }
        //DateTime currentTimeUtc = DateTime.UtcNow;
        //DateTime completedTime = DateTime.Parse(spellOneCooldownStr, null, System.Globalization.DateTimeStyles.RoundtripKind);
        //TimeSpan timeLeft = completedTime - currentTimeUtc;
        //int remainingSeconds = (int)timeLeft.TotalSeconds;
        //if (remainingSeconds > 0) {
        //    p.CooldownSpellOne = remainingSeconds;
        //    if(remainingSeconds > 0f){
        //        p.TactSpellOne = true;
        //        if(p.abilityOneCDRoutine != null){
        //            p.StopCoroutine(p.abilityOneCDRoutine);
        //        }
        //        p.abilityOneCDRoutine = p.StartCoroutine(p.SetAbilityCoolDownOne(remainingSeconds));
        //                
        //    }
        //} else {
        //    p.CooldownSpellOne = 0;
        //    print($"CooldownSpellOne was off cooldown");
        //}
        //if (float.TryParse(spellOneCooldownStr, out float parsedCooldown))
        //{
        //    // If parsing is successful, assign the parsed value
        //    p.CooldownSpellOne = parsedCooldown;
        //    if(parsedCooldown > 0f){
        //        p.TactSpellOne = true;
        //        if(p.abilityOneCDRoutine != null){
        //            p.StopCoroutine(p.abilityOneCDRoutine);
        //        }
        //        p.abilityOneCDRoutine = p.StartCoroutine(p.SetAbilityCoolDownOne(parsedCooldown));
        //                
        //    }
        //}
        p.SpellTwo = TacticianInfoSheet.SpellTwoEquipped;
        string spellTwoCooldownStr = TacticianInfoSheet.SpellTwoCooldown; // Assuming this is the string you want to parse
        if (!string.IsNullOrEmpty(spellTwoCooldownStr))
        {
            DateTime currentTimeUtc = DateTime.UtcNow;
            try
            {
                DateTime completedTime = DateTime.Parse(spellTwoCooldownStr, null, System.Globalization.DateTimeStyles.RoundtripKind);
                TimeSpan timeLeft = completedTime - currentTimeUtc;
                int remainingSeconds = (int)timeLeft.TotalSeconds;
        
                if (remainingSeconds > 0)
                {
                    p.ServerBuildTacticianSpellCooldownLogin(remainingSeconds, 2);

                    //p.CooldownSpellTwo = remainingSeconds;
                    //p.TactSpellTwo = true;
                    //if (p.abilityTwoCDRoutine != null)
                    //{
                    //    p.StopCoroutine(p.abilityTwoCDRoutine);
                    //}
                    //p.abilityTwoCDRoutine = p.StartCoroutine(p.SetAbilityCoolDownTwo(remainingSeconds));
                }
                else
                {
                    p.CooldownSpellTwo = 0;
                    Debug.Log("CooldownSpellTwo was off cooldown");
                }
            }
            catch (FormatException)
            {
                // Handle the situation where spellTwoCooldownStr could not be parsed to a DateTime
                Debug.LogError("spellTwoCooldownStr could not be parsed to a DateTime. Ensure the string is in a correct format.");
                // Optionally, set CooldownSpellTwo to a default value or handle this case as needed
            }
        }
        else
        {
            p.CooldownSpellTwo = 0;
            // Handle the case where spellTwoCooldownStr is null or empty
            Debug.LogError("spellTwoCooldownStr is null or empty. Cooldown cannot be calculated.");
            // Optionally, set CooldownSpellTwo to a default value or handle this case as needed
        }
        //DateTime completedTimeTwo = DateTime.Parse(spellTwoCooldownStr, null, System.Globalization.DateTimeStyles.RoundtripKind);
        //TimeSpan timeLeftTwo = completedTimeTwo - currentTimeUtc;
        //int SecondRemainingSeconds = (int)timeLeftTwo.TotalSeconds;
        //if (SecondRemainingSeconds > 0) {
        //    p.CooldownSpellTwo = SecondRemainingSeconds;
        //    if(SecondRemainingSeconds > 0f){
        //        p.TactSpellTwo = true;
        //        if(p.abilityTwoCDRoutine != null){
        //            p.StopCoroutine(p.abilityTwoCDRoutine);
        //        }
        //        p.abilityTwoCDRoutine = p.StartCoroutine(p.SetAbilityCoolDownTwo(SecondRemainingSeconds));
        //    }
        //} else {
        //    p.CooldownSpellTwo = 0;
        //    print($"CooldownSpellTwo was off cooldown");
        //}
        //if (float.TryParse(spellTwoCooldownStr, out float parsedCooldownTwo))
        //{
        //    // If parsing is successful, assign the parsed value
        //    p.CooldownSpellTwo = parsedCooldownTwo;
        //    if(parsedCooldownTwo > 0f){
        //        p.TactSpellTwo = true;
        //        if(p.abilityTwoCDRoutine != null){
        //            p.StopCoroutine(p.abilityTwoCDRoutine);
        //        }
        //        p.abilityTwoCDRoutine = p.StartCoroutine(p.SetAbilityCoolDownTwo(parsedCooldownTwo));
        //    }
        //}  
        //print($"{gold} is the amount of gold pulled in from user inventory");
        Dictionary<string, List<CharacterInventoryListItem>> Inventories = new Dictionary<string, List<CharacterInventoryListItem>>();
        int inventoriesRetrieved = 0;
        if(Sheets.Count > 0){
            foreach(var key in Sheets){
                List<CharacterInventoryListItem> chararacterInventory = new List<CharacterInventoryListItem>();
                GetCharacterInventoryRequest request = new GetCharacterInventoryRequest();
                request.PlayFabId = playerData.PlayFabId;
                request.CharacterId = key.Key;
                bool charInventoryComp = false;
                PlayFabServerAPI.GetCharacterInventory(request, result => {
                    if(result.Inventory != null){
                        List<ItemInstance> inventory = result.Inventory;
                        if(inventory.Count > 0 && inventory != null){
                            // make the stackable list here to spawn them in one big item to move then we can add to it later
                            for (int e = 0; e < inventory.Count; e++)
                            {
                                string Durability_item = "100";
                                bool equipped = false;
                                bool charInventory = true;
                                string nftID = "NotNFT";
                                string Quality_item = string.Empty;
                                string equippedslot = string.Empty;
                                int quantity = 1;
                                string engraving = string.Empty;
                                foreach(var stat in inventory[e].CustomData){
                                    if(stat.Key == "Engraving"){
                                        engraving = stat.Value;
                                    }
                                    if(stat.Key == "NFTID"){
                                        nftID = stat.Value;
                                    }
                                    if(stat.Key == "Durability_item"){
                                        Durability_item = stat.Value;
                                    }
                                    if(stat.Key == "Quality_item"){
                                        Quality_item = stat.Value;
                                    }
                                    if(stat.Key == "Amount"){
                                        quantity = int.Parse(stat.Value);
                                    }
                                    if(stat.Key == "EquippedSlot"){
                                        equippedslot = stat.Value;
                                        if(stat.Value != "0" && stat.Value != "Unequipped"){
                                            equipped = true;
                                            charInventory = false;
                                        }
                                    }
                                }
                                ItemSelectable itemAdded = ItemDataStorage.Instance.BuildItemSelectable(key.Key, Quality_item, quantity, nftID, false, engraving, inventory[e].DisplayName, inventory[e].ItemInstanceId, inventory[e].ItemId, equippedslot, false, false, false, charInventory, equipped, Durability_item, true, false);

                                //print($"character {key.Key} had an inventory for sure, building item {Item_Name}");
                                if(nftID != "NotNFT"){
                                    NFTsInWallet.Add(nftID);
                                }
                                CharacterInventoryListItem itemCreated = (new CharacterInventoryListItem{
                                    Key = itemAdded.GetInstanceID(),
                                    Value = itemAdded
                                });
                                chararacterInventory.Add(itemCreated);
                            } 
                        }
                    }
                    inventoriesRetrieved++;
                    charInventoryComp = true;
                }, error =>{
                    Debug.Log(error.ErrorMessage);
                });
                while(!charInventoryComp){
                    //yield return new WaitForSeconds(.1f);
                    yield return null;
                }
                Inventories.Add(key.Key, chararacterInventory);
            }
        }
            
        //print($"{playerData.CurrentScene} is playerData CurrentScene, {playerData.Energy} is playerData Energy");
        long goldcoins = 0;
        int coinAmount = checked((int)gold);
        if(coinAmount > 0 ){
          // goldcoins = unchecked((uint)coinAmount);
           goldcoins = (long)coinAmount;

        }
        if(goldcoins > 0){
            p.Gold = goldcoins;
            p.TargetWalletAwake();
            //print($"Goldcoins = {goldcoins}");
        }
        if(goldcoins <= 0){
            p.GoldAmountSet(0);
            //print($"Goldcoins = {goldcoins}");
        }
        List<string> keys = playerData.PartyIDs;
        foreach(var key in keys){
            p.AddPartyServer(key);
        }
        /*
        p.TargetOpenUI(playerData.CurrentScene);
        p.TargetCharge(playerData.Energy);
        //print("still good in Get all character inventory");
        ClientRequestLoadScene dummy = new ClientRequestLoadScene {
            oldScene = "Container",
            newScene = sceneSelect,
            node = playerData.SavedNode,
            login = true
        };
        GetCleanedSceneName(nconn, dummy);
        StartCoroutine(ReChargeEnergy(nconn));
        */
        while (inventoriesRetrieved < Sheets.Count)
        {
            //yield return new WaitForSeconds(0.1f);
            yield return null;
        }
        //print("AboutToSendSheets with inventories!!");
        List<CharacterFullDataMessage> characterSheets = new List<CharacterFullDataMessage>();
        foreach (var sheetKey in Sheets)
        {
            foreach (var inventoryKey in Inventories.Keys)
            {
                if (sheetKey.Value.CharacterID == inventoryKey)
                {
                    // Get the CharacterFullDataMessage object
                    CharacterFullDataMessage charData = (new CharacterFullDataMessage{
                        skinningSkill = sheetKey.Value.skinningSkill,
                        skinningExp = sheetKey.Value.skinningExp,
                        miningSkill = sheetKey.Value.miningSkill,
                        miningExp = sheetKey.Value.miningExp,
                        prospectingSkill = sheetKey.Value.prospectingSkill,
                        prospectingExp = sheetKey.Value.prospectingExp,
                        foragingSkill = sheetKey.Value.foragingSkill,
                        foragingExp = sheetKey.Value.foragingExp,
                        woodCuttingSkill = sheetKey.Value.woodCuttingSkill,
                        woodCuttingExp = sheetKey.Value.woodCuttingExp,
                        CharacterID = sheetKey.Value.CharacterID,
                        CharInventoryData = Inventories[inventoryKey],
                        CharSpellData = sheetKey.Value.CharSpellData,
                        CharCooldownData = sheetKey.Value.CharCooldownData,
                        CharStatData = sheetKey.Value.CharStatData,
                        CharBuffData = sheetKey.Value.CharBuffData
                    });
                    characterSheets.Add(charData);
                    // Update the Sheets dictionary with the modified CharacterFullDataMessage
                }
            }
        }
        if(playerData.GM){
            p.GameMaster = true;
        }
            
        StartCoroutine(CreateInformationSheetsOnPlayer(nconn, p, TacticianInfoSheet, characterSheets, playerData, townRidden, NFTsInWallet, tokenCount));
        //we have all the char inventories, char spells, and char stats and we have tactician items as well, lets bring it all in!
            
        //yield return new WaitForSeconds(2f);
            
       // p.SetPlayerData(playerData);
            
        //StartCoroutine(LoginSetup(nconn, dummy));   
    }
        #endif
    List<string> nftIDsNotInGame = new List<string> {
    "NFT_SpearOfDragonslaying",
    "NFT_StaffOfProtection",
    "NFT_AcidicAxe",
    "NFT_MaceOfHealing",
    "NFT_BowOfPower",
    "NFT_FrozenGreatsword",
    "NFT_GreatspearOfDragonslaying",
    "NFT_ThunderInfusedGreathammer",
    "NFT_VampiricDagger",
    "NFT_VenomousGreataxe",
    "NFT_SwordOfFire"
};
            #if UNITY_SERVER //|| UNITY_EDITOR
    IEnumerator CreateInformationSheetsOnPlayer(NetworkConnectionToClient nconn, ScenePlayer sPlayer, TacticianFullDataMessage tactSheet, List<CharacterFullDataMessage> characterSheets, PlayerInfo playerData, bool townRidden, List<string> NFTsAtSpawn, int tokenCount){
        //Dictionary<string, string> currentNFTS = playerData.NFTMD5Hash.Zip(playerData.NFTIDS, (k, v) => new { k, v }).ToDictionary(x => x.k, x => x.v);
        List<string> currentNFTS = playerData.NFTIDS;
        List<string> copyList = new List<string>(currentNFTS);
        

        //playerData.NFTIDS;
        if(currentNFTS.Count > 0){
            foreach(var nft in currentNFTS){
                print($"Detected nft id {nft} was the nft spawning");//this must be playfab
            }
        }
        if(NFTsAtSpawn != null){
            foreach(var nft in NFTsAtSpawn){
                //if (nftIDsNotInGame.Contains(nft)) {
                //    // continue with the logic for the matched NFT
                //    continue;
                //}
               // print($"Playfab nft key {nft.Key} // nft value {nft.Value} was the nft from Playfab nfts");//this is xrp wallet
                var matchingKey = currentNFTS.FirstOrDefault(kvp => kvp == nft);
                 // If a key was found, remove it from currentNFTS.
                if (!string.IsNullOrEmpty(matchingKey)) 
                {
                    copyList.Remove(matchingKey);
                }
            }
        }
        List<CharacterInventoryListItem> stashItems = tactSheet.StashInventoryData;
        for(int y = 0; y < stashItems.Count; y++){
            if(stashItems[y].Value.GetNFT()){
                if(!playerData.NFTIDS.Contains(stashItems[y].Value.GetNFTID())){
                    stashItems[y].Value.Changed = true;
                    stashItems[y].Value.Deleted = true;
                } 
            }
        }
        for(int b = 0; b < tactSheet.TacticianInventoryData.Count; b++){
            if(tactSheet.TacticianInventoryData[b].Value.GetNFT()){
                if(!playerData.NFTIDS.Contains(tactSheet.TacticianInventoryData[b].Value.GetNFTID())){
                    tactSheet.TacticianInventoryData[b].Value.Changed = true;
                    tactSheet.TacticianInventoryData[b].Value.Deleted = true;
                } 
            }
        }
        int numBatches = (int) Math.Ceiling((double) stashItems.Count / 20); // Calculate the number of batches.
        // Split the stashItems into batches and send each batch separately.
        if(numBatches > 1){
            for (int i = 0; i < numBatches; i++) {
                int batchSize = Math.Min(20, stashItems.Count - i * 20); // The size of this batch will be 40 or the remaining number of items.
                List<CharacterInventoryListItem> batchItems = stashItems.GetRange(i * 20, batchSize);
                if(i == 0) {
                    // For the first batch, send it via GetFullTacticianData.
                    tactSheet.StashInventoryData = batchItems;
                    sPlayer.GetFullTacticianData(tactSheet);
                } else {
                    // For subsequent batches, send each item individually via GetStashNewItem.
                    sPlayer.GetStashNewItems(batchItems);
                }
            }
        } else {
            sPlayer.GetFullTacticianData(tactSheet);
        }
        //List<CharacterInventoryListItem> tactNFTsDeleting = new List<CharacterInventoryListItem>();
        //foreach(var TactItem in sPlayer.GetTacticianSheet().TacticianInventoryData){
        //    if(TactItem.Value.NFT){
        //        string nftID = TactItem.Value.NFTID;
        //        if(currentNFTS.ContainsValue(nftID)){
        //            tactNFTsDeleting.Add(TactItem);
        //            print($"Adding {nftID} to be destroyed");
        //        } 
        //    }
        //}
        for(int y = 0; y < stashItems.Count; y++){
            if(stashItems[y].Value.GetNFT()){
                if(!playerData.NFTIDS.Contains(stashItems[y].Value.GetNFTID())){
                    stashItems[y].Value.Changed = true;
                    stashItems[y].Value.Deleted = true;
                } 
            }
        }
     
        //if(tactNFTsDeleting.Count > 0){
        //    foreach(var TactNft in tactNFTsDeleting){
        //        TactNft.Value.Deleted = true;
        //        TactNft.Value.Changed = true;
        //    }
        //    yield return new WaitForSeconds(.1f);
        //    foreach(var TactNft in tactNFTsDeleting){
        //        sPlayer.GetTacticianNewItem(TactNft);
        //    }
        //}
        //List<CharacterInventoryListItem> stashNFTsDeleting = new List<CharacterInventoryListItem>();
        //foreach(var StashItem in sPlayer.GetTacticianSheet().StashInventoryData){
        //    if(StashItem.Value.NFT){
        //        string nftID = StashItem.Value.NFTID;
        //        if(currentNFTS.ContainsValue(nftID)){
        //            stashNFTsDeleting.Add(StashItem);
        //            print($"Adding {nftID} to be destroyed");
        //        }  
        //    }
        //}
        //if(stashNFTsDeleting.Count > 0){
        //    foreach(var stashNFtDeleted in stashNFTsDeleting){
        //        stashNFtDeleted.Value.Deleted = true;
        //        stashNFtDeleted.Value.Changed = true;
        //    }
        //    foreach(var stashNFtDeleted in stashNFTsDeleting){
        //        sPlayer.GetStashNewItem(stashNFtDeleted);
        //    }
        //}
        for(int p = 0; p < characterSheets.Count; p++){
            for(int v = 0; v < characterSheets[p].CharInventoryData.Count; v++){
                if(characterSheets[p].CharInventoryData[v].Value.GetNFT()){
                    if(!playerData.NFTIDS.Contains(characterSheets[p].CharInventoryData[v].Value.GetNFTID())){
                        characterSheets[p].CharInventoryData[v].Value.Changed = true;
                        characterSheets[p].CharInventoryData[v].Value.Deleted = true;
                    } 
                }
            }   
            
        }
        
        StartCoroutine(ReChargeEnergy(nconn));
        sPlayer.TargetOpenUI(playerData.CurrentScene);
        sPlayer.TargetCharge(playerData.Energy);
        foreach(var sheet in characterSheets){
            sPlayer.GetFullCharacterData(sheet);
            yield return new WaitForSeconds(.1f);
        }
        
        yield return new WaitForSeconds(.25f);
        sPlayer.ServerSpawnItems();
        sPlayer.ServerSpawnCraftBuilds();
        sPlayer.ServerSetSegment(playerData.KnownWorldSegments);
        sPlayer.ServerSpawnQuestSystem(playerData.QuestCompleted, playerData.QuestInProgress, playerData.RepeatQuestCompleted);
        sPlayer.TokenCount = tokenCount;
        sPlayer.TargetStartTokenUpdate();
        yield return new WaitForSeconds(.25f);
        print($"player {playerData.PlayerName} has connected and is logging in");
        string sceneSelect = playerData.CurrentScene;
        if(townRidden){
            sceneSelect = TOWNOFARUDINE;
        }
        
        if(!sceneSelect.Contains("Random")){
            if(!sceneSelect.Contains("Sewers")){
                ClientRequestLoadScene dummy = new ClientRequestLoadScene {
                    oldScene = "Container",
                    newScene = sceneSelect,
                    //node = playerData.SavedNode,
                    login = true
                };
                GetCleanedSceneName(nconn, dummy);
                sPlayer.ServerBuildCharacters();
                if (copyList.Count > 0)
                {
                    StartCoroutine(SpawnNewNFTS(copyList, playerData, nconn, sPlayer.playerName));
                    /*
                    if(sPlayer.GameMaster){
                    //Dictionary<string, string> TestNFTList = new Dictionary<string, string>();
                    //TestNFTList.Add("aba2af3c46490ef57e6499cc6bb5a14a", "000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD9C2CFAD600000012"); 
                    Dictionary<string, string> TestNFTList = new Dictionary<string, string>
                    {
                        { "aba2af3c46490ef57e6499cc6bb5a14a", "000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD9C2CFAD600000012" }
                    };
                    SpawnTestNFT(TestNFTList,playerData, nconn, sPlayer.playerName);
                }
                */
                }
            } else {
                
                sPlayer.ServerBuildMatchMakerSewerLogin(sceneSelect, true);
                sPlayer.ServerBuildCharacters();
                if (copyList.Count > 0)
                {
                    StartCoroutine(SpawnNewNFTS(copyList, playerData, nconn, sPlayer.playerName));
                    /*
                    if(sPlayer.GameMaster){
                    //Dictionary<string, string> TestNFTList = new Dictionary<string, string>();
                    //TestNFTList.Add("aba2af3c46490ef57e6499cc6bb5a14a", "000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD9C2CFAD600000012"); 
                    Dictionary<string, string> TestNFTList = new Dictionary<string, string>
                    {
                        { "aba2af3c46490ef57e6499cc6bb5a14a", "000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD9C2CFAD600000012" }
                    };
                    SpawnTestNFT(TestNFTList,playerData, nconn, sPlayer.playerName);
                }
                */
                }
            }
            
        } else {
            sPlayer.ServerRandomMatchSoloGame(sceneSelect, true);
            sPlayer.ServerBuildCharacters();
            if (copyList.Count > 0)
            {
                StartCoroutine(SpawnNewNFTS(copyList, playerData, nconn, sPlayer.playerName));
                /*
                if(sPlayer.GameMaster){
                    //Dictionary<string, string> TestNFTList = new Dictionary<string, string>();
                    //TestNFTList.Add("aba2af3c46490ef57e6499cc6bb5a14a", "000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD9C2CFAD600000012"); 
                    Dictionary<string, string> TestNFTList = new Dictionary<string, string>
                    {
                        { "aba2af3c46490ef57e6499cc6bb5a14a", "000AC35022E3CB09ED45B21B8729A283BA72BD5137ACBFBD9C2CFAD600000012" }
                    };
                    SpawnTestNFT(TestNFTList,playerData, nconn, sPlayer.playerName);
                }
                */
                
            }
        }
    }
    #endif
    public List<(string completedTime, string spellNameFull)> SplitCombinedValue(string combinedValue)
    {
        List<(string completedTime, string spellNameFull)> spells = new List<(string completedTime, string spellNameFull)>();
        if(combinedValue.Contains("_")){
            string[] packages = combinedValue.Split('_'); // Split by underscores
            foreach (var package in packages)
            {
                string[] parts = package.Split(';'); // Split each package by semicolon

                if (parts.Length != 2)
                {
                    throw new ArgumentException($"Invalid combined value in package: {package}");
                }
                string timeComplete = parts[0];
                string spellNameFull = parts[1];
                spells.Add((timeComplete, spellNameFull));
            }
        } else {
            string[] parts = combinedValue.Split(';'); // Replace with the delimiter you used
            if (parts.Length != 2)
            {
                throw new ArgumentException("Invalid combined value");
            }
            //value = parts[0];
            //spellNameFull = parts[1];
            string timeComplete = parts[0];
            string spellNameFull = parts[1];
            spells.Add((timeComplete, spellNameFull));
        }
        
        return spells;
    }
    /*
    public void SplitCombinedValue(string combinedValue, out string value, out string spellNameFull)
    {
        string[] packages = combinedValue.Split('_'); // Split by underscores
        //string[] parts = combinedValue.Split(';'); // Replace with the delimiter you used
        foreach (var package in packages)
        {
            string[] parts = package.Split(';'); // Split each package by semicolon

            if (parts.Length != 2)
            {
                throw new ArgumentException($"Invalid combined value in package: {package}");
            }
        }
        //if (parts.Length != 2)
        //{
        //    throw new ArgumentException("Invalid combined value");
        //}
        value = parts[0];
        spellNameFull = parts[1];
    }
    */
// Helper class to match the JSON structure
[System.Serializable]
public class SegmentListSaveData
{
    public List<int> segments;

    public SegmentListSaveData(List<int> segments)
    {
        this.segments = segments;
    }
}
[System.Serializable]
public class CompletedQuestListSaveData
{
    public List<string> CompletedQuests;

    public CompletedQuestListSaveData(List<string> completedQuests)
    {
        this.CompletedQuests = completedQuests;
    }
}
[System.Serializable]
public class RepeatQuestListSaveData
{
    public List<string> CompletedQuests;

    public RepeatQuestListSaveData(List<string> completedQuests)
    {
        this.CompletedQuests = completedQuests;
    }
}
[System.Serializable]
public class CurrentQuestListSaveData
{
    public List<string> CurrentQuests;

    public CurrentQuestListSaveData(List<string> currentQuests)
    {
        this.CurrentQuests = currentQuests;
    }
}
/*
public void GetPlayerObject(string playFabId, string objectName, System.Action<SegmentListData> onSuccess, System.Action<string> onFailure)
    {
        var request = new GetObjectsRequest
        {
            Entity = new PlayFab.DataModels.EntityKey
            {
                Id = playFabId, // The player's PlayFab ID
                Type = "title_player_account" // The entity type for a player account
            },
            EscapeObject = false, // Set to false to receive the JSON as an object
        };

        PlayFabDataAPI.GetObjects(request, result =>
        {
            if (result.Objects.TryGetValue(objectName, out var playerObject))
            {
                // Deserialize the JSON data back into the SegmentListData structure
                var segmentListData = JsonUtility.FromJson<SegmentListData>(playerObject.DataObject.ToString());
                Debug.Log("Successfully retrieved and deserialized player object data.");
                onSuccess?.Invoke(segmentListData);
            }
            else
            {
                Debug.LogWarning($"Object '{objectName}' not found for the given player ID.");
                //onFailure?.Invoke($"Object '{objectName}' not found for the given player ID.");
            }
        }, error =>
        {
            Debug.LogError("Error getting player object data: " + error.GenerateErrorReport());
            //onFailure?.Invoke(error.GenerateErrorReport());
        });
    }
        public void SavePlayerObject(string playFabId, string objectName, List<int> segmentListSaveData)
        {
            // Serialize the list into a JSON string
            var jsonSegmentList = JsonUtility.ToJson(new { segments = segmentListSaveData });

            var request = new SetObjectsRequest
            {
                Entity = new PlayFab.DataModels.EntityKey
                {
                    Id = playFabId, // The player's PlayFab ID
                    Type = "title_player_account" // The type for a player's entity. Usually, it is "title_player_account"
                },
                Objects = new List<SetObject>
                {
                    new SetObject
                    {
                        ObjectName = objectName, // The object's name as identified in your PlayFab title
                        DataObject = jsonSegmentList // The JSON string of your list
                    }
                }
            };

            // Use PlayFabServerAPI if calling from the server-side
            PlayFabDataAPI.SetObjects(request, OnSetObjectsSuccess, OnSetObjectsFailure);
        }

        private void OnSetObjectsSuccess(SetObjectsResponse response)
        {
            // Handle successful response
            Debug.Log("Successfully updated player object on the server side.");
        }

        private void OnSetObjectsFailure(PlayFabError error)
        {
            // Handle error
            Debug.LogError("Server-side error setting object: " + error.GenerateErrorReport());
        }
        */
        List<string> DisconnectedList = new List<string>();
        List<string> ProcessingLogoutList = new List<string>();

        //Logout process
            #if UNITY_SERVER //|| UNITY_EDITOR

        IEnumerator ProcessingDisconnecting(NetworkConnectionToClient conn, PlayerInfo playerData, float energy, string scene){
            float timer = 10f;
                print($"{playerData.PlayFabId} was our playfab ID for this account, {scene} is our scene we are disconnecting from and {energy} is our remaining energy");
            if(scene == "OVM" || scene == "TOWNOFARUDINE"){
                timer = 2f;
            }
                print("Starting timer on ProcessingDisconnecting");
            yield return new WaitForSeconds(timer); //set this much higher for disconnection time
                print("Finishing timer on ProcessingDisconnecting");
            if(DisconnectedList.Contains(playerData.PlayFabId)){
                //process the logout now
                print("Adding to processing logout and starting up LogThemout");
                ProcessingLogoutList.Add(playerData.PlayFabId);
                StartCoroutine(LogThemOut(conn, playerData, energy, scene));
            }
        }
        
         IEnumerator LogThemOut(NetworkConnectionToClient conn, PlayerInfo playerData, float energy, string scene){
            if(!CheckNullConnection(conn)){
                yield break;
            }
            ScenePlayer p = conn.identity.gameObject.GetComponent<ScenePlayer>();
            if(p == null){
                yield break;
            }
            CancelTrade(p);
            charFreeze.Invoke(p);
            p.ServerClearAllPurchaseData();
            //flag all players to turn off their receive dmg with charFreeze
            string dateTimeWithZone = DateTime.UtcNow.ToString("o");
            List<int> segmentListSaveData = p.GetSegmentlistWorldMap();
            List<string> completeQuestListSaveData = p.GetQuestCompletedFullyList();
            List<string> repeatCompleteQuestListSaveData = p.GetRepeatQuestCompletedFullyList();
            yield return new WaitForSeconds(5f); //set this much higher for disconnection time

            foreach(var seg in segmentListSaveData){
                print("printing segment in seg list it is " + seg);
            }
            SegmentListSaveData dataToSave = new SegmentListSaveData(segmentListSaveData);
            string jsonSegmentListSaveData = JsonUtility.ToJson(dataToSave);
            print("json SegmentListSaveData is " + jsonSegmentListSaveData);
            CompletedQuestListSaveData cqDataToSave = new CompletedQuestListSaveData(completeQuestListSaveData);
            string jsonCompletedQuestListSaveData = JsonUtility.ToJson(cqDataToSave);
            print("json CompletedQuestListSaveData is " + jsonCompletedQuestListSaveData);
            RepeatQuestListSaveData rqDataToSave = new RepeatQuestListSaveData(repeatCompleteQuestListSaveData);
            string jsonRepeatQuestListSaveData = JsonUtility.ToJson(rqDataToSave);
            print("json RepeatQuestListSaveData is " + jsonRepeatQuestListSaveData);

            List<QuestSaveData> questInProgressData = p.GetQuestSavedStatus();
            List<string> saveStrings = new List<string>();

            foreach(var savingQuest in questInProgressData){
                saveStrings.Add(savingQuest.GetSaveString());
                print(savingQuest.GetSaveString() + " this is the save string for the quest " + savingQuest.questID);
            }
            CurrentQuestListSaveData currentQuests = new CurrentQuestListSaveData(saveStrings);
            //string serializedSaveData = string.Join(",", saveStrings);
            string jsonQuestSavedData = JsonUtility.ToJson(currentQuests);
            
            print("serializedQuestSaveData is " + jsonQuestSavedData);
            
            //SavePlayerObject(playerData.PlayFabId, "WorldMapDiscoveries", segmentListSaveData);
            //bool loggedInBefore = false;
            //bool SetNFTCooldowns = false;
            //TimeSpan timeLeftForDay  = TimeSpan.Zero; // Initialize with zero time
            //if(!string.IsNullOrEmpty(playerData.lastLogin)){
            //    loggedInBefore = true;
            //    DateTime datePrior = DateTime.Parse(playerData.lastLogin);
            //    DateTime dateCurrent = DateTime.Now;
            //    TimeSpan timeDifference = dateCurrent - datePrior;
            //    if (timeDifference.TotalDays >= 1)
            //    {
            //        SetNFTCooldowns = false;
            //    } else {    
            //        // Calculate how much time is left to complete a week    
            //        timeLeftForDay  = TimeSpan.FromDays(1) - timeDifference;
            //        print($"{timeLeftForDay } is how much time is left to reset our NFT COOLDOWN");
            //    }
            //}
            string NewEnergy = energy.ToString();
            bool LimitHit = false;
            int LimitCount = 0;
            LimitCount ++;
            int currentBalance = 0;
            bool currencySave = false;
            bool UpdatingQuestData = false;
            bool UpdatingCraftDataOne = false;
            bool UpdatingCraftDataOneHalf = false;
            bool UpdatingCraftDataTwo = false;
            bool UpdatingCraftDataThree = false;
            string exp = "1";
            string lvl = "1";
            bool expFound = false;
            bool lvlFound = false;
            int weaponCraftingSkill = p.GetTacticianSheet().weaponCraftingSkill > 0 ? p.GetTacticianSheet().weaponCraftingSkill : 1;
            int armorCraftingSkill = p.GetTacticianSheet().armorCraftingSkill > 0 ? p.GetTacticianSheet().armorCraftingSkill : 1;
            int jewelCraftingSkill = p.GetTacticianSheet().jewelCraftingSkill > 0 ? p.GetTacticianSheet().jewelCraftingSkill : 1;
            int cookingSkill = p.GetTacticianSheet().cookingSkill > 0 ? p.GetTacticianSheet().cookingSkill : 1;
            int alchemySkill = p.GetTacticianSheet().alchemySkill > 0 ? p.GetTacticianSheet().alchemySkill : 1;
            int refiningSkill = p.GetTacticianSheet().refiningSkill > 0 ? p.GetTacticianSheet().refiningSkill : 1;

            float weaponCraftingExp = p.GetTacticianSheet().weaponCraftingExp > 0 ? p.GetTacticianSheet().weaponCraftingExp : 1f;
            float armorCraftingExp = p.GetTacticianSheet().armorCraftingExp > 0 ? p.GetTacticianSheet().armorCraftingExp : 1f;
            float jewelCraftingExp = p.GetTacticianSheet().jewelCraftingExp > 0 ? p.GetTacticianSheet().jewelCraftingExp : 1f;
            float cookingExp = p.GetTacticianSheet().cookingExp > 0 ? p.GetTacticianSheet().cookingExp : 1f;
            float alchemyExp = p.GetTacticianSheet().alchemyExp > 0 ? p.GetTacticianSheet().alchemyExp : 1f;
            float refiningExp = p.GetTacticianSheet().refiningExp > 0 ? p.GetTacticianSheet().refiningExp : 1f;
            string identifyEnemyString = "None";
            foreach(var stat in p.GetTacticianSheet().TacticianStatData){
                if(stat.Key == "IdentifiedTargets"){
                    identifyEnemyString = stat.Value;
                    break;
                }
            }
            Dictionary<string, string> inputOne = new Dictionary<string, string>
            {
                {"weaponCraftingSkill", weaponCraftingSkill.ToString()},
                {"armorCraftingSkill", armorCraftingSkill.ToString()},
                {"jewelCraftingSkill", jewelCraftingSkill.ToString()},
                {"cookingSkill", cookingSkill.ToString()},
                {"alchemySkill", alchemySkill.ToString()}
            };
            List<string> keysToRemove = new List<string>();
            // Iterate over the dictionary to find entries with a value of "0"
            foreach (var dataInput in inputOne)
            {
                if (dataInput.Value == "0")
                {
                    keysToRemove.Add(dataInput.Key);
                }
            }
            // Remove the identified entries from the dictionary
            foreach (var key in keysToRemove)
            {
                inputOne.Remove(key);
            }
            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                Data = inputOne
                //new Dictionary<string, string>
                //{
                //    {"weaponCraftingSkill", weaponCraftingSkill.ToString()},
                //    {"armorCraftingSkill", armorCraftingSkill.ToString()},
                //    {"jewelCraftingSkill", jewelCraftingSkill.ToString()},
                //    {"cookingSkill", cookingSkill.ToString()},
                //    {"alchemySkill", alchemySkill.ToString()}
                //}
            }, result =>
            {
                UpdatingCraftDataOne = true;
            }, error =>{
                UpdatingCraftDataOne = true;

                Debug.Log(error.ErrorMessage);
            });
            while(!UpdatingCraftDataOne){
                yield return new WaitForSeconds(.1f);
            }
            LimitCount ++;
            string entireCDString = string.Empty;
            if(p.GetTacticianSheet().TacticianCooldownData == null){

            foreach (var coolies in p.GetTacticianSheet().TacticianCooldownData){
                //DateTime initialTime = DateTime.Parse(dateTimeWithZone);
                DateTime initialTime = DateTime.UtcNow;
                DateTime completedTime = DateTime.Parse(coolies.Value, null, System.Globalization.DateTimeStyles.RoundtripKind);
                //DateTime completedTime = DateTime.Parse(coolies.Value);
                if (initialTime < completedTime)
                {
                    entireCDString += completedTime.ToString() + "_" + coolies.SpellnameFull + "|";
                } 
            }
            }
            if(!string.IsNullOrEmpty(entireCDString)){
                entireCDString = entireCDString.TrimEnd('|');
            }
            //public string identifyEnemyKey;
            //string identityKey = "None";
            //if (result.Data.ContainsKey("IdentifiedTargets")){
            //    identityKey = result.Data["IdentifiedTargets"].Value;
            //}
            
            Dictionary<string, string> inputOneHalf = new Dictionary<string, string>
            {
                {"IdentifiedTargets", identifyEnemyString}, 
                {"fullCooldownData", null}, 
                {"PlayerTactAddress", p.GetTacticianSheet().TacticianAddress}
            };
            
            if(!string.IsNullOrEmpty(entireCDString)){
                inputOneHalf["fullCooldownData"] = entireCDString;
            }
            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                Data = inputOneHalf
                //new Dictionary<string, string>
                //{
                //    {"weaponCraftingSkill", weaponCraftingSkill.ToString()},
                //    {"armorCraftingSkill", armorCraftingSkill.ToString()},
                //    {"jewelCraftingSkill", jewelCraftingSkill.ToString()},
                //    {"cookingSkill", cookingSkill.ToString()},
                //    {"alchemySkill", alchemySkill.ToString()}
                //}
            }, result =>
            {
                UpdatingCraftDataOneHalf = true;
            }, error =>{
                UpdatingCraftDataOneHalf = true;

                Debug.Log(error.ErrorMessage);
            });
            while(!UpdatingCraftDataOneHalf){
                yield return new WaitForSeconds(.1f);
            }
            LimitCount ++;
            Dictionary<string, string> inputTwo = new Dictionary<string, string>
            {
                {"refiningSkill", refiningSkill.ToString()},
                {"weaponCraftingExp", weaponCraftingExp.ToString()},
                {"armorCraftingExp", armorCraftingExp.ToString()},
                {"jewelCraftingExp", jewelCraftingExp.ToString()},
                {"cookingExp", cookingExp.ToString()}
            };
            List<string> keysToRemoveTwo = new List<string>();
            // Iterate over the dictionary to find entries with a value of "0"
            foreach (var dataInput in inputTwo)
            {
                if (dataInput.Value == "0")
                {
                    keysToRemoveTwo.Add(dataInput.Key);
                }
            }
            // Remove the identified entries from the dictionary
            foreach (var key in keysToRemoveTwo)
            {
                inputTwo.Remove(key);
            }
            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                Data = inputTwo
                //new Dictionary<string, string>
                //{
                //    {"refiningSkill", refiningSkill.ToString()},
                //    {"weaponCraftingExp", weaponCraftingExp.ToString()},
                //    {"armorCraftingExp", armorCraftingExp.ToString()},
                //    {"jewelCraftingExp", jewelCraftingExp.ToString()},
                //    {"cookingExp", cookingExp.ToString()}
                //}
            }, result =>
            {
                UpdatingCraftDataTwo = true;
            }, error =>{
                UpdatingCraftDataTwo = true;

                Debug.Log(error.ErrorMessage);
            });
            while(!UpdatingCraftDataTwo){
                yield return new WaitForSeconds(.1f);
            }
            LimitCount ++;
            List<string> craftingItemsSaved = new List<string>();
            string CraftBuildBelt = string.Empty;
            if(p.GetTacticianSheet().CraftingItems != null){

            if(p.GetTacticianSheet().CraftingItems.Count > 0){
                int stillBuildingItems = 0;
                foreach(var craftingItem in p.GetTacticianSheet().CraftingItems){
                    if(!craftingItem.Finished){
                        string DropString = "false";
                        if(craftingItem.Dropped){
                            DropString = "true";
                        }
                        string itemString = craftingItem.ItemName + ";" + craftingItem.Time + ";" + craftingItem.Quant.ToString() + ";" + craftingItem.OwnerName + ";" + DropString + ";" + craftingItem.PriorQuality;
                        craftingItemsSaved.Add(itemString);
                        stillBuildingItems ++;
                        //print($"Adding string {itemString} to our craftbuildbelt");
                    }
                }
                if(stillBuildingItems > 1){
                    CraftBuildBelt = String.Join("|", craftingItemsSaved); // Use a different delimiter to separate each crafting item
                    //print($"{CraftBuildBelt} is our logout craftbuild");
                }
                if(stillBuildingItems == 1){
                    foreach(var craftable in craftingItemsSaved){
                        CraftBuildBelt = craftable;
                    }
                    //print($"{CraftBuildBelt} is our logout craftbuild");
                }
            }
            }

            if(string.IsNullOrEmpty(CraftBuildBelt)){
                CraftBuildBelt = "0";
            }
            //print($"{CraftBuildBelt} is our logout craftbuild");
            DateTime currentTimeUtc = DateTime.UtcNow;
            DateTime spellOneEndTime = currentTimeUtc.AddSeconds(p.CooldownSpellOne);
            DateTime spellTwoEndTime = currentTimeUtc.AddSeconds(p.CooldownSpellTwo);
            string spellOneString = "Empty";
            string spellTwoString = "Empty";
            if(p.SpellOne != "Empty" && p.SpellOne != "None"){
                spellOneString = p.SpellOne + "_" + spellOneEndTime.ToString();
            }
            if(p.SpellTwo != "Empty" && p.SpellTwo != "None"){
                spellTwoString = p.SpellTwo + "_" + spellTwoEndTime.ToString();
            }

            Dictionary<string, string> inputThree = new Dictionary<string, string>
            {
                {"alchemyExp", alchemyExp.ToString()},
                {"refiningExp", refiningExp.ToString()},
                {"CraftingBuildBelt", CraftBuildBelt},
                {"tactSpellOne", spellOneString},
                {"tactSpellTwo", spellTwoString}
            };
            List<string> keysToRemoveThree = new List<string>();
            // Iterate over the dictionary to find entries with a value of "0"
            foreach (var dataInput in inputThree)
            {
                if (dataInput.Value == "0" && dataInput.Key != "CraftingBuildBelt")
                {
                    keysToRemoveThree.Add(dataInput.Key);
                }
            }
            // Remove the identified entries from the dictionary
            foreach (var key in keysToRemoveThree)
            {
                inputThree.Remove(key);
            }
            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                Data = inputThree
                //new Dictionary<string, string>
                //{
                //    {"alchemyExp", alchemyExp.ToString()},
                //    {"refiningExp", refiningExp.ToString()},
                //    {"CraftingBuildBelt", CraftBuildBelt.ToString()}
                //}
            }, result =>
            {
                UpdatingCraftDataThree = true;
            }, error =>{
                UpdatingCraftDataThree = true;

                Debug.Log(error.ErrorMessage);
            });
            while(!UpdatingCraftDataThree){
                yield return new WaitForSeconds(.1f);
            }
            foreach(var statItem in p.GetTacticianSheet().TacticianStatData){
                if(statItem.Key == "EXP"){
                    exp = statItem.Value;
                    expFound = true;
                }
                if(statItem.Key == "LVL"){
                    lvl = statItem.Value;
                    lvlFound = true;
                }
                if(lvlFound && expFound){
                    break;
                }
            }
            Dictionary<string, string> inputFour = new Dictionary<string, string>
            {
                {"QuestProgress", jsonQuestSavedData},
                {"CompletedQuests", jsonCompletedQuestListSaveData},
                {"RepeatQuestCD", jsonRepeatQuestListSaveData},
                {"EXP", exp},
                {"LVL", lvl}
            };
            List<string> keysToRemoveFour = new List<string>();
            // Iterate over the dictionary to find entries with a value of "0"
            foreach (var dataInput in inputFour)
            {
                if (string.IsNullOrEmpty(dataInput.Value))
                {
                    keysToRemoveFour.Add(dataInput.Key);
                }
            }
            // Remove the identified entries from the dictionary
            foreach (var key in keysToRemoveFour)
            {
                inputFour.Remove(key);
            }
            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                Data = inputFour
                //new Dictionary<string, string>
                //{
                //    {"QuestProgress", jsonQuestSavedData},
                //    {"CompletedQuests", jsonCompletedQuestListSaveData},
                //    {"RepeatQuestCD", jsonRepeatQuestListSaveData},
                //    {"EXP", exp},
                //    {"LVL", lvl}
                //}
            }, result =>
            {
                UpdatingQuestData = true;
            }, error =>{
                UpdatingQuestData = true;

                Debug.Log(error.ErrorMessage);
            });
            while(!UpdatingQuestData){
                yield return new WaitForSeconds(.1f);
            }
            LimitCount ++;
            PlayFabServerAPI.GetUserInventory(new GetUserInventoryRequest(){
                PlayFabId = playerData.PlayFabId,
            }, result => {
                currentBalance = result.VirtualCurrency.ContainsKey("DK") ? result.VirtualCurrency["DK"] : 0;
                currencySave = true;
            }, error => {
                Debug.LogError("Could not get player inventory: " + error.GenerateErrorReport());
                currencySave = true;
            });
            while(!currencySave){
                yield return new WaitForSeconds(.1f);
            }
            bool balancingGold = false;
            if((long)currentBalance != p.Gold){
                LimitCount ++;
                long difference = p.Gold - currentBalance;  // Find the difference between p.Gold and currentBalance
                int absDifference = Mathf.Abs((int)difference); // Convert difference to positive if it's negative
                // Choose either AddUserVirtualCurrency or SubtractUserVirtualCurrency based on the sign of the difference
                if (difference > 0){
                    PlayFabServerAPI.AddUserVirtualCurrency(new AddUserVirtualCurrencyRequest{
                        PlayFabId = playerData.PlayFabId,
                        Amount = absDifference,
                        VirtualCurrency = "DK"
                    }, result =>
                    {
                        balancingGold = true;
                    }, error =>
                    {
                        balancingGold = true;
                        Debug.Log(error.ErrorMessage);
                    });
                } else {
                    PlayFabServerAPI.SubtractUserVirtualCurrency(new SubtractUserVirtualCurrencyRequest
                    {
                        PlayFabId = playerData.PlayFabId,
                        Amount = absDifference,
                        VirtualCurrency = "DK"
                    }, result =>
                    {
                        balancingGold = true;
                    }, error =>
                    {
                        balancingGold = true;
                        Debug.Log(error.ErrorMessage);
                    });
                }
            } else {
                balancingGold = true;
            }
            while(!balancingGold){
                yield return new WaitForSeconds(.1f);
            }
            bool internalSave = false;
            LimitCount ++;
            string pos = p.x + "_" + p.y.ToString();
            if(!StatAsset.Instance.CheckForCombatZone(scene)){
                pos = p.gameObject.transform.position.x.ToString() + "_" + p.gameObject.transform.position.y.ToString();
            }
            //string pos = p.gameObject.transform.position.x.ToString() + "_" + p.gameObject.transform.position.y.ToString();
            if(scene.Contains("Random")){
                pos = p.x + "_" + p.y;
                print("we were in random game");
            }
                print("our saved position was " + pos);
            string energyAvail = p.Energy.ToString();
            Dictionary<string, string> inputFive = new Dictionary<string, string>
            {
                {"XY", pos},
                {"LastScene", scene},
                {"energy", energyAvail},
                {"lastLogin", dateTimeWithZone},
                {"WorldMapDiscovery", jsonSegmentListSaveData}
            };

            List<string> keysToRemoveFive = new List<string>();
            // Iterate over the dictionary to find entries with a value of "0"
            foreach (var dataInput in inputFive)
            {
                if (string.IsNullOrEmpty(dataInput.Value))
                {
                    keysToRemoveFive.Add(dataInput.Key);
                }
            }
            // Remove the identified entries from the dictionary
            foreach (var key in keysToRemoveFive)
            {
                inputFive.Remove(key);
            }
            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                Data = inputFive
                //new Dictionary<string, string>
                //{
                //    {"XY", pos},
                //    {"LastScene", scene},
                //    {"energy", NewEnergy},
                //    {"lastLogin", dateTimeWithZone},
                //    {"WorldMapDiscovery", jsonSegmentListSaveData}
                //}
            }, result =>
            {
                internalSave = true;
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            while(!internalSave){
                yield return new WaitForSeconds(.1f);
            }
            string ZeroName = null;
            string OneName = null;
            string TwoName = null;
            string ThreeName = null;
            string FourName = null;
            string FiveName = null;
            List<string> IDs = new List<string>();
            foreach(var entry in p.GetParty())
            {
                IDs.Add(entry);
                if(ZeroName == null){
                    ZeroName = entry;
                    continue;
                }
                if(OneName == null){
                    OneName = entry;
                    continue;
                }
                if(TwoName == null){
                    TwoName = entry;
                    continue;
                }
                if(ThreeName == null){
                    ThreeName = entry;
                    continue;
                }
                if(FourName == null){
                    FourName = entry;
                    continue;
                }
                if(FiveName == null){
                    FiveName = entry;
                    continue;
                }
            }
            bool internalSaveTwo = false;
            LimitCount ++;
            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                Data = new Dictionary<string, string>
                    {
                        {"PartyMemberZero", ZeroName}, {"PartyMemberOne", OneName},
                        {"PartyMemberTwo", TwoName}, {"PartyMemberThree", ThreeName},
                        {"PartyMemberFour", FourName}, {"PartyMemberFive", FiveName}
                    }
            }, result =>
            {
                internalSaveTwo = true;
            }, error =>{
                internalSaveTwo = true;
                Debug.Log(error.ErrorMessage);
            });
             while(!internalSaveTwo){
                yield return new WaitForSeconds(.1f);
            }
            LimitCount ++;
            //build string 
            string tactBuild;
            string armorBonus = "0"; // not completed
            string GiantRep = "1"; // not completed
            string DragonRep = "1"; // not completed
            string LizardRep = "1"; // not completed
            string OrcRep = "1"; // not completed
            string FaerieRep = "1"; // not completed
            string ElvesRep = "1"; // not completed
            string DwarvesRep = "1"; // not completed
            string GnomesRep = "1"; // not completed
            string zodiacSign = "";
            bool internalSaveThree = false;

            if(p.GetTacticianSheet().Birthdate != null){
                (int selectedDay, int selectedMonth) = GetDate(p.GetTacticianSheet().Birthdate);
                if ((selectedMonth == 3 && selectedDay >= 21) || (selectedMonth == 4 && selectedDay <= 19))
                    zodiacSign = "Aries";
                else if ((selectedMonth == 4 && selectedDay >= 20) || (selectedMonth == 5 && selectedDay <= 20))
                    zodiacSign = "Taurus";
                else if ((selectedMonth == 5 && selectedDay >= 21) || (selectedMonth == 6 && selectedDay <= 21))
                    zodiacSign = "Gemini";
                else if ((selectedMonth == 6 && selectedDay >= 22) || (selectedMonth == 7 && selectedDay <= 22))
                    zodiacSign = "Cancer";
                else if ((selectedMonth == 7 && selectedDay >= 23) || (selectedMonth == 8 && selectedDay <= 22))
                    zodiacSign = "Leo";
                else if ((selectedMonth == 8 && selectedDay >= 23) || (selectedMonth == 9 && selectedDay <= 22))
                    zodiacSign = "Virgo";
                else if ((selectedMonth == 9 && selectedDay >= 23) || (selectedMonth == 10 && selectedDay <= 22))
                    zodiacSign = "Libra";
                else if ((selectedMonth == 10 && selectedDay >= 23) || (selectedMonth == 11 && selectedDay <= 21))
                    zodiacSign = "Scorpio";
                else if ((selectedMonth == 11 && selectedDay >= 22) || (selectedMonth == 12 && selectedDay <= 21))
                    zodiacSign = "Sagittarius";
                else if ((selectedMonth == 12 && selectedDay >= 22) || (selectedMonth == 1 && selectedDay <= 19))
                    zodiacSign = "Capricorn"; 
                else if ((selectedMonth == 1 && selectedDay >= 20) || (selectedMonth == 2 && selectedDay <= 18))
                    zodiacSign = "Aquarius";
                else if ((selectedMonth == 2 && selectedDay >= 19) || (selectedMonth == 3 && selectedDay <= 20))
                    zodiacSign = "Pisces";

                if(zodiacSign == "Capricorn" || zodiacSign == "Virgo" || zodiacSign == "Taurus" || zodiacSign == "Leo"){
                    armorBonus = "1";
                }
            }
            
            if(p.GetTacticianSheet().TacticianStatData != null){
                foreach(var stat in p.GetTacticianSheet().TacticianStatData){
                    if(stat.Key == "GiantRep"){
                        GiantRep = stat.Value;
                    }
                    if(stat.Key == "DragonRep"){
                        DragonRep = stat.Value;
                    }
                    if(stat.Key == "LizardRep"){
                        LizardRep = stat.Value;
                    }
                    if(stat.Key == "OrcRep"){
                        OrcRep = stat.Value;
                    }
                    if(stat.Key == "FaerieRep"){
                        FaerieRep = stat.Value;
                    }
                    if(stat.Key == "ElfRep"){
                        ElvesRep = stat.Value;
                    }
                    if(stat.Key == "DwarfRep"){
                        DwarvesRep = stat.Value;
                    }
                    if(stat.Key == "GnomeRep"){
                        GnomesRep = stat.Value;
                    }
                }
            }
            string dkpCooldown = p.GetTacticianSheet().DKPCooldown;
            if(!string.IsNullOrEmpty(dkpCooldown)){
                if(dkpCooldown != "0"){
                    DateTime cdTime = DateTime.Parse(dkpCooldown);
                    DateTime timeNow = DateTime.Now;
                    TimeSpan timeSpan = timeNow - cdTime;
                    if(timeSpan.TotalHours >= 24){
                        dkpCooldown = "0";
                    }
                }
            } else {
                dkpCooldown = "0";
            }
            if(p.GetTacticianSheet().Birthdate != null && p.GetTacticianSheet().EyeColor != null && p.GetTacticianSheet().BodyStyle != null && p.GetTacticianSheet().StrengthBonus != null
            && p.GetTacticianSheet().AgilityBonus != null && p.GetTacticianSheet().FortitudeBonus != null && p.GetTacticianSheet().ArcanaBonus != null ){
             tactBuild = p.GetTacticianSheet().Birthdate + "_" + zodiacSign + "_" +  
                p.GetTacticianSheet().EyeColor + "_" + p.GetTacticianSheet().BodyStyle + "_" + 
                p.GetTacticianSheet().StrengthBonus + "_" + p.GetTacticianSheet().AgilityBonus + "_" + 
                p.GetTacticianSheet().FortitudeBonus + "_" + p.GetTacticianSheet().ArcanaBonus + "_" + 
                armorBonus + "_" + GiantRep.ToString() + "_" +  DragonRep.ToString() + "_" +  
                LizardRep.ToString() + "_" +  OrcRep.ToString() + "_" +  FaerieRep.ToString() + "_" +  
                ElvesRep.ToString() + "_" +  DwarvesRep.ToString() + "_" +  GnomesRep.ToString() + "_" + 
                dkpCooldown;
                LimitCount ++;
                PlayFabServerAPI.UpdateUserData(new UpdateUserDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                Data = new Dictionary<string, string>
                {
                    {"TACTBUILDSTRING", tactBuild}
                }
            }, result =>
            {
                internalSaveThree = true;
            }, error =>{
                internalSaveThree = true;
                Debug.Log(error.ErrorMessage);
            });
            } else {
                internalSaveThree = true;
            }
            while(!internalSaveTwo){
                yield return new WaitForSeconds(.1f);
            }
            if(p.GetTacticianSheet().TacticianInventoryData != null){

            foreach(var item in p.GetTacticianSheet().TacticianInventoryData){
                if(LimitCount >= 10){
                    LimitHit = true;
                }
                if(LimitHit){
                    yield return new WaitForSeconds(15f);
                    LimitCount = 0;
                    LimitHit = false;
                }
                if(item.Value.InstanceID == "NewItemGenerated"){
                    //newly generated item
                    if(item.Value.Changed){
                        if(item.Value.Deleted || item.Value.amount == 0){
                            //item does not need to be modified its simply just wont exist after we log them out
                            continue;
                        } else {
                            ServerAddItemLogout(conn, item.Value, null);
                            LimitCount ++;
                            continue;
                            //we now have to build this item but it stays on the user es pz lets get its info
                        }
                    } else {
                        ServerAddItemLogout(conn, item.Value, null);
                        LimitCount ++;
                        continue;
                    } 
                } else {
                    //prior item
                    if(item.Value.Changed){
                        if(item.Value.Deleted || item.Value.amount == 0){
                            //item needs to be removed lets do that now.
                            if(item.Value.OwnerID == "Tactician" || item.Value.OwnerID == "Stash"){
                                ServerRemoveItemOnUser(conn, item.Value);
                                LimitCount ++;
                                continue;
                            } else {
                                ServerRemoveItemOnUserFromCharacter(conn, item.Value);
                                LimitCount ++;
                                continue;
                            }
                        } else {
                            EquipmentSaveData saveData = (new EquipmentSaveData{
                                intialized = "Intialized"
                            });
                            bool userOwnedPrior = false;
                            if(item.Value.OGTacticianBelt){
                                saveData.OGTactBelt = true;
                                userOwnedPrior = true;
                            }
                            if(item.Value.OGTacticianInventory){
                                saveData.OGTactInv= true;
                                userOwnedPrior = true;
                            }
                            if(item.Value.OGTacticianStash){
                                saveData.OGStash = true;
                                userOwnedPrior = true;
                            }
                            if(item.Value.OGTacticianEquip){
                                saveData.OGTactEquipped = true;
                                userOwnedPrior = true;
                            }
                            if(item.Value.OwnerID == "Tactician" || item.Value.OwnerID == "Stash"){
                                SaveTacticianChange(conn, item.Value); // this was to save it to 
                                LimitCount ++;
                                continue;
                            } else {
                                saveData.CharacterSlotOne = item.Value.OwnerID;
                                SendItemFromCharacterToTactician(conn, item.Value, saveData);
                                LimitCount ++;
                                continue;
                            }
                        }
                    } 
                    continue;
                    //if no change we move on because item is good to go
                }
            }
            }
            if(p.GetTacticianSheet().StashInventoryData != null){

            foreach(var item in p.GetTacticianSheet().StashInventoryData){
                if(LimitCount >= 10){
                    LimitHit = true;
                }
                if(LimitHit){
                    yield return new WaitForSeconds(15f);
                    LimitCount = 0;
                    LimitHit = false;
                }
                if(item.Value.InstanceID == "NewItemGenerated"){
                    //newly generated item
                    if(item.Value.Changed){
                        if(item.Value.Deleted || item.Value.amount == 0){
                            //item does not need to be modified its simply just wont exist after we log them out
                            continue;
                        } else {
                            ServerAddItemLogout(conn, item.Value, null);
                            LimitCount ++;
                            continue;
                            //we now have to build this item but it stays on the user es pz lets get its info
                        }
                    } else {
                        ServerAddItemLogout(conn, item.Value, null);
                        LimitCount ++;
                        continue;
                    } 
                } else {
                    //prior item
                    if(item.Value.Changed){
                        if(item.Value.Deleted || item.Value.amount == 0){
                            //item needs to be removed lets do that now.
                            
                            if(item.Value.OwnerID == "Tactician" || item.Value.OwnerID == "Stash"){
                                ServerRemoveItemOnUser(conn, item.Value);
                                LimitCount ++;
                                continue;
                            } else {
                                ServerRemoveItemOnUserFromCharacter(conn, item.Value);
                                LimitCount ++;
                                continue;
                            }
                        } else {
                            EquipmentSaveData saveData = (new EquipmentSaveData{
                                intialized = "Intialized"
                            });
                            if(item.Value.OGTacticianBelt){
                                saveData.OGTactBelt = true;
                            }
                            if(item.Value.OGTacticianInventory){
                                saveData.OGTactInv= true;
                            }
                            if(item.Value.OGTacticianStash){
                                saveData.OGStash = true;
                            }
                            if(item.Value.EQUIPPEDSLOT == "Unequipped" || item.Value.EQUIPPEDSLOT == "0"){
                                saveData.Slot = null;
                            } else {
                                saveData.Slot = item.Value.EQUIPPEDSLOT;
                            }
                            if(item.Value.TacticianStash){
                                saveData.TactInv = false;
                                saveData.TactBelt = false;
                            }
                            if(item.Value.OwnerID == "Tactician" || item.Value.OwnerID == "Stash"){
                                SaveTacticianChange(conn, item.Value); // this was to save it to 
                                LimitCount ++;
                                continue;
                            } else {
                                saveData.CharacterSlotOne = item.Value.OwnerID;
                                SendItemFromCharacterToTactician(conn, item.Value, saveData);
                                LimitCount ++;
                                continue;
                            }
                        }
                    } 
                    continue;
                    //if no change we move on because item is good to go
                }
            }
            }
                    print("Logout Beginning chars *****************");
            var sheets = p.GetInformationSheets();
            bool haveSheets = false;
            if (sheets != null && sheets.Any()) // Using .Any() is a more idiomatic way to check for an empty collection
            {
                // Sheets exist and the list is not empty
                Console.WriteLine("Sheets are available. Count: " + sheets.Count);
             haveSheets = true;

            }
            else
            {
                // The list is either null or contains no elements
                Console.WriteLine("No sheets are available.");
            }
            if(haveSheets){
            foreach(var sheet in p.GetInformationSheets()){
                int CharLimit = 0;
                CharLimit ++;
                if(CharLimit >= 10){
                    LimitHit = true;
                }
                if(LimitHit){
                    yield return new WaitForSeconds(15f);
                    CharLimit = 0;
                    LimitHit = false;
                }
                string CORE = "STANDARD";
                string curHealth = "1";
                string curMana = "1";
                string LVL = "1";
                string EXP = "1";
                string DEATH = "1";
                string LEVELING = "1";
                string classPoints = "";
                string Tracking = null;
                int spellUpdateIndex = 0; // To keep track of spells to update
                bool leveledUp = false;
                bool leveledUpKey = false;
                bool Death = false;
                int miningSkill = sheet.miningSkill > 0 ? sheet.miningSkill : 1;
                float miningExp = sheet.miningExp;
                int prospectingSkill = sheet.prospectingSkill > 0 ? sheet.prospectingSkill : 1;
                float prospectingExp = sheet.prospectingExp;
                int woodCuttingSkill = sheet.woodCuttingSkill > 0 ? sheet.woodCuttingSkill : 1;
                float woodCuttingExp = sheet.woodCuttingExp;
                int skinningSkill = sheet.skinningSkill > 0 ? sheet.skinningSkill : 1;
                float skinningExp = sheet.skinningExp;
                int foragingSkill = sheet.foragingSkill > 0 ? sheet.foragingSkill : 1;
                float foragingExp = sheet.foragingExp;
                
                foreach(var stat in sheet.CharStatData){
                    if(stat.Key == "CORE"){
                        CORE = stat.Value;
                    }
                    if(stat.Key == "currentHP"){
                        curHealth = stat.Value;
                    }
                    if(stat.Key == "currentMP"){
                        curMana = stat.Value;
                    }
                    if(stat.Key == "ClassPoints"){
                        classPoints = stat.Value;
                    }
                    if(stat.Key == "trackingData"){
                        Tracking = stat.Value;
                    }
                    if(stat.Key == "LVL"){
                        LVL = stat.Value;
                    }
                    if(stat.Key == "EXP"){
                        EXP = stat.Value;
                    }
                    if(stat.Key == "DEATH"){
                        Death = true;
                        DEATH = stat.Value;
                    }
                    if(stat.Key == "LEVELING"){
                        LEVELING = stat.Value;
                        //if value leveling time has passed
                        DateTime initialTime = DateTime.Parse(dateTimeWithZone);
                        DateTime completedTime = DateTime.Parse(LEVELING);
                        if (initialTime >= completedTime)
                        {
                            leveledUp = true;
                        } else {
                            leveledUpKey = true;
                        }
                        print($"Char id {sheet.CharacterID} was leveling and leveldUp = {leveledUp}, leveledUpKey = {leveledUpKey} and the initial time is {initialTime} and completed time is {completedTime}");
                    }
                }
                Dictionary<string, string> dataToUpdate = new Dictionary<string, string> {
                    {"currentHP", curHealth},
                    {"currentMP", curMana},
                    {"ClassPoints", classPoints.ToString()},
                    {"LVL", LVL}, 
                    {"EXP", EXP},
                    {"DEATH", null},
                    {"miningEXP", miningExp.ToString()},
                    {"woodCuttingEXP", woodCuttingExp.ToString()},
                    {"foragingEXP", foragingExp.ToString()},
                    {"skinningEXP", skinningExp.ToString()}, 
                    {"prospectingEXP", prospectingExp.ToString()},
                    {"miningSkill", miningSkill.ToString()},
                    {"woodCuttingSkill", woodCuttingSkill.ToString()},
                    {"prospectingSkill", prospectingSkill.ToString()},
                    {"foragingSkill", foragingSkill.ToString()}, 
                    {"skinningSkill", skinningSkill.ToString()},
                    {"trackingData" , null},
                    {"buffSavedData" , null},
                    {"CORE" , CORE}
                };
                if(!string.IsNullOrEmpty(Tracking)){
                    dataToUpdate["trackingData"] = Tracking;
                }
                DateTime currentTime = DateTime.UtcNow;
                Console.WriteLine($"Current Time (UTC): {currentTime:O}");

                string newBuffData = string.Empty;
                if (sheet.CharBuffData != null) {
                    foreach (var buff in sheet.CharBuffData) {
                        if(buff.Key == "Hide"){
                            continue;
                        }
                        if (DateTime.TryParseExact(buff.Time, "o", CultureInfo.InvariantCulture, DateTimeStyles.RoundtripKind, out DateTime expirationTime)) {
                            Console.WriteLine($"Parsed Expiration Time (UTC): {expirationTime:O} for Buff: {buff.Key}");

                            if (expirationTime > currentTime) {
                                int secondsLeft = (int)(expirationTime - currentTime).TotalSeconds;
                                Console.WriteLine($"Seconds Left for {buff.Key}: {secondsLeft}");
                                newBuffData += $"{buff.Key}_{buff.Value}_{secondsLeft}_{buff.Duration}_{buff.Rank};";
                            }
                        } else {
                            Console.WriteLine($"Failed to parse the expiration time for buff: {buff.Key}");
                        }
                    }
                }
                // Remove the last semicolon if newBuffData is not empty
                if (!string.IsNullOrEmpty(newBuffData)) {
                    dataToUpdate["buffSavedData"] = newBuffData.TrimEnd(';');
                }
                if(Death){
                    dataToUpdate["DEATH"] = DEATH;  // This will update the value of the existing "DEATH" key.
                    dataToUpdate["currentHP"] = "0";  // This will update the value of the existing "DEATH" key.
                }
                if(leveledUp){
                    print("Logout LEVELING UP *****************");

                    dataToUpdate.Add("LEVELING", null);
                    int currentLevel = int.Parse(dataToUpdate["LVL"]); // Parse "LVL" to an integer
                    currentLevel++; // Increment the level
                    dataToUpdate["LVL"] = currentLevel.ToString(); // Convert it back to string and update in the dictionary
                    print($"LEVELED UP Char id {sheet.CharacterID} was leveling and leveldUp = {leveledUp}, leveledUpKey = {leveledUpKey}");
                } else if(leveledUpKey){
                    print($"DID NOT LEVEL UP Char id {sheet.CharacterID} was leveling and leveldUp = {leveledUp}, leveledUpKey = {leveledUpKey}");
                    dataToUpdate.Add("LEVELING", LEVELING);
                } else {
                    print($"not leveling up at all");
                    dataToUpdate.Add("LEVELING", null);
                }
                List<CharacterSpellListItem> spellBookUpdates = new List<CharacterSpellListItem>();
                
                foreach(var spell in sheet.CharSpellData){
                    if(spell.Updated){
                        //spellBookUpdates.Add(spell);
                        dataToUpdate.Add(spell.Key, spell.Value);
                        print($" Newly updated and added spell was {spell.Value} in slot {spell.Key} ");
                    }
                }
                
                Dictionary<string, string> miniBatch = new Dictionary<string, string>();
                while (spellUpdateIndex < dataToUpdate.Count) {
                    // Clear previous miniBatch
                    miniBatch.Clear();

                    //// Collect up to 5 spells in the current batch
                    //for (int i = 0; i < 5 && spellUpdateIndex < dataToUpdate.Count; i++, spellUpdateIndex++) {
                    //    //CharacterSpellListItem spell = spellBookUpdates[spellUpdateIndex];
                    //    miniBatch[spell.Key] = spell.Value;
                    //    miniBatch[dataToUpdate[spellUpdateIndex]] = 
                    //}
                    int count = 0;
                    foreach (var item in dataToUpdate.Skip(spellUpdateIndex).Take(5))
                    {
                        miniBatch.Add(item.Key, item.Value);
                        count++;
                    }
                    spellUpdateIndex += count; // Increment spellUpdateIndex by the number of items processed
                    // Update character data with the current batch
                    bool updateCharData = false;
                    PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest {
                        PlayFabId = playerData.PlayFabId,
                        CharacterId = sheet.CharacterID,
                        Data = miniBatch
                    }, result => {
                        updateCharData = true;
                    }, error => {
                        updateCharData = true;
                        Debug.Log(error.ErrorMessage);
                        Debug.Log(error.ErrorDetails);
                        Debug.Log(error.Error);
                    });
    
                    // Wait until the update completes
                    while (!updateCharData) {
                        yield return null;
                    }

                    // Handle rate limiting
                    CharLimit++;
                    if (CharLimit >= 10) {
                        LimitHit = true;
                    }
                    if (LimitHit) {
                        yield return new WaitForSeconds(25f);
                        CharLimit = 0;
                        LimitHit = false;
                    }
                }

                // Ensure any remaining items in miniBatch are processed
                if (miniBatch.Count > 0) {
                    bool updateCharData = false;
                    PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest {
                        PlayFabId = playerData.PlayFabId,
                        CharacterId = sheet.CharacterID,
                        Data = miniBatch
                    }, result => {
                        updateCharData = true;
                    }, error => {
                        updateCharData = true;
                        Debug.Log(error.ErrorMessage);
                        Debug.Log(error.ErrorDetails);
                        Debug.Log(error.Error);
                    });

                    // Wait until the update completes
                    while (!updateCharData) {
                        yield return null;
                    }
                    CharLimit++;
                    if (CharLimit >= 10) {
                        LimitHit = true;
                    }
                    if (LimitHit) {
                        yield return new WaitForSeconds(25f);
                        CharLimit = 0;
                        LimitHit = false;
                    }
                }
                /*
                // Update 1-5 spells if available
                for (int i = 0; i < 5 && spellUpdateIndex < spellBookUpdates.Count; i++, spellUpdateIndex++) {
                    CharacterSpellListItem spell = spellBookUpdates[spellUpdateIndex];
                    if (spell.Updated) {
                        dataToUpdate[spell.Key] = spell.Value; // Assuming spell has 'Key' and 'Value' properties
                    }
                }
                Dictionary<string, string> miniBatch = new Dictionary<string, string>();
                int count = 0;
                foreach (var item in dataToUpdate) {
                    miniBatch.Add(item.Key, item.Value);
                    count++;

                    if (count >= 5) {
                        // Send this batch and clear it
                        CharLimit ++;
                        if(CharLimit >= 10){
                            LimitHit = true;
                        }
                        if(LimitHit){
                            yield return new WaitForSeconds(25f);
                            CharLimit = 0;
                            LimitHit = false;                                                 
                        }
                        bool updateCharData = false;
                        PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
                        {
                            PlayFabId = playerData.PlayFabId,
                            CharacterId = sheet.CharacterID,
                            Data = miniBatch
                        }, result =>
                        {
                            updateCharData = true;
                        }, error =>{
                            updateCharData = true;

                            Debug.Log(error.ErrorMessage); 
                            Debug.Log(error.ErrorDetails);
                            Debug.Log(error.Error);
                        });
                        while(!updateCharData){
                            yield return null;
                        }
                        miniBatch.Clear();
                        count = 0;
                    }
                }
                CharLimit ++;
                if(CharLimit >= 10){
                    LimitHit = true;
                }
                if(LimitHit){
                    yield return new WaitForSeconds(15f);
                    CharLimit = 0;
                    LimitHit = false;
                }
                // Don't forget the last batch if it has fewer than 5 items
                if (miniBatch.Count > 0) {
                     bool updateCharData = false;
                    PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
                    {
                        PlayFabId = playerData.PlayFabId,
                        CharacterId = sheet.CharacterID,
                        Data = miniBatch
                    }, result =>
                    {
                        updateCharData = true;
                    }, error =>{
                        updateCharData = true;
                        Debug.Log(error.ErrorMessage); 
                        Debug.Log(error.ErrorDetails);
                        Debug.Log(error.Error);
                    });
                    while(!updateCharData){
                        yield return null;
                    }
                    miniBatch.Clear();
                    count = 0;
                    
                }
                */
                foreach(var item in sheet.CharInventoryData){
                    //print($"Checking item {item.Value.GetItemName()}, Changed {item.Value.Changed}, Amount {item.Value.amount}, Deleted {item.Value.Deleted}, InstanceID {item.Value.GetInstanceID()}");
                    if(CharLimit >= 10){
                        LimitHit = true;
                    }
                    if(LimitHit){
                        yield return new WaitForSeconds(15f);
                        CharLimit = 0;
                        LimitHit = false;
                    }
                    if(item.Value.InstanceID == "NewItemGenerated"){
                        //newly generated item
                        if(item.Value.Changed){
                            if(item.Value.Deleted || item.Value.amount == 0){
                                //item does not need to be modified its simply just wont exist after we log them out
                                continue;
                            } else {
                                ServerAddItemLogout(conn, item.Value, sheet.CharacterID);
                                LimitCount ++;
                                continue;
                                //we now have to build this item but it stays on the user es pz lets get its info
                            }
                        } else {
                            ServerAddItemLogout(conn, item.Value, sheet.CharacterID);
                            LimitCount ++;
                            continue;
                        } 
                    } else {
                        //prior item
                        if(item.Value.Changed){
                            if(item.Value.Deleted || item.Value.amount == 0){
                                //item needs to be removed lets do that now.
                                if(item.Value.OwnerID == "Tactician" || item.Value.OwnerID == "Stash"){
                                    ServerRemoveItemOnUser(conn, item.Value);
                                    LimitCount ++;
                                    continue;
                                } else {
                                    ServerRemoveItemOnUserFromCharacter(conn, item.Value);
                                    LimitCount ++;
                                    continue;
                                }
                            } else {
                                EquipmentSaveData saveData = (new EquipmentSaveData{
                                    intialized = "Intialized"
                                });
                                bool userOwnedPrior = false;
                                if(item.Value.OGTacticianBelt){
                                    saveData.OGTactBelt = true;
                                    userOwnedPrior = true;
                                }
                                if(item.Value.OGTacticianInventory){
                                    saveData.OGTactInv= true;
                                    userOwnedPrior = true;
                                }
                                if(item.Value.OGTacticianStash){
                                    saveData.OGStash = true;
                                    userOwnedPrior = true;
                                }
                                if(item.Value.OGTacticianEquip){
                                    saveData.OGTactEquipped = true;
                                    userOwnedPrior = true;
                                }
                                if(item.Value.OwnerID == "Tactician" || item.Value.OwnerID == "Stash"){
                                    saveData.CharacterSlotOne = sheet.CharacterID;
                                    SendItemFromTacticianToCharacter(conn, item.Value, saveData);
                                    CharLimit ++;
                                } else {
                                    if(item.Value.OwnerID == sheet.CharacterID){
                                        saveData.CharacterSlotOne = sheet.CharacterID;
                                        saveData.CharacterSlotTwo = sheet.CharacterID;
                                        SendItemToUserForUpdatingThenBackToDesiredSerial(conn, item.Value, saveData);
                                        CharLimit ++;
                                    }
                                    if(item.Value.OwnerID != sheet.CharacterID && item.Value.OwnerID != "Tactician" && item.Value.OwnerID != "Stash"){
                                        saveData.CharacterSlotOne = item.Value.OwnerID;
                                        saveData.CharacterSlotTwo = sheet.CharacterID;
                                        SendItemToUserForUpdatingThenBackToDesiredSerial(conn, item.Value, saveData);
                                        CharLimit ++;
                                    }
                                }
                            }
                        } 
                        continue;
                        //if no change we move on because item is good to go
                    }
                }
                if(CharLimit >= 10){
                    LimitHit = true;
                }
                if(LimitHit){
                    yield return new WaitForSeconds(15f);
                    CharLimit = 0;
                    LimitHit = false;
                }
                print("Logout cooldowns");
                //Dictionary<string, string> cooldownData = new Dictionary<string, string>//();
                //{
                //    { "COOLDOWNQ", null },
                //    { "COOLDOWNE", null },  
                //    { "COOLDOWNR", null },
                //    { "COOLDOWNF", null }
                //};
                Dictionary<string, string> cooldownData = new Dictionary<string, string>//();
                {
                    { "COOLDOWNS", null },
                    { "COOLDOWNQ", null },
                    { "COOLDOWNE", null },  
                    { "COOLDOWNR", null },
                    { "COOLDOWNF", null }
                };
                bool CDPresent = true;
                string entireCDStringChar = string.Empty;
                print("Logout cooldowns Test 1");
                if (sheet.CharCooldownData != null){
                    print("Logout cooldowns Test 2");
                    foreach (var coolies in sheet.CharCooldownData){
                        //print($"Logout cooldowns Test 3{coolies.PKey} was our PKey");
                        //DateTime initialTime = DateTime.Parse(dateTimeWithZone);
                        DateTime initialTime = DateTime.UtcNow;

                        print($"Logout cooldowns Test 4 start was {initialTime}");
                        DateTime completedTime = DateTime.Parse(coolies.Value, null, System.Globalization.DateTimeStyles.RoundtripKind);

                        //DateTime completedTime = DateTime.Parse(coolies.Value);
                        print($"Logout cooldowns Test 5 cooldown end was {completedTime}");
                        if (initialTime < completedTime)
                        {
                            //cooldownData.Remove(coolies.PKey);
                            //cooldownData[coolies.PKey] = completedTime.ToString() + ";" + coolies.SpellnameFull;
                            entireCDStringChar += completedTime.ToString() + ";" + coolies.SpellnameFull + "_";
                            //cooldownData.Add(coolies.PKey, completedTime.ToString() + ";" + coolies.SpellnameFull);
                            //CDPresent = true;
                            print($"Logout cooldowns Test 6 {completedTime.ToString() + ";" + coolies.SpellnameFull} was our cooldown data value");
                        } else {
                            //cooldownData.Add(coolies.PKey, null);
                            print("Logout cooldowns Test 7");
                        }
                    }
                } 
                if(!string.IsNullOrEmpty(entireCDStringChar)){
                    if(entireCDStringChar.EndsWith("_"))
                    {
                        entireCDStringChar = entireCDStringChar.TrimEnd('_');
                    }
                    cooldownData["COOLDOWNS"] = entireCDStringChar;
                    print($"Full cd string is {entireCDStringChar}");
                }
                CharLimit++;
                if(CharLimit >= 10){
                    LimitHit = true;
                }
                if(LimitHit){
                    yield return new WaitForSeconds(15f);
                    CharLimit = 0;
                    LimitHit = false;
                }
                //if(CDPresent){
                print("Logout cooldowns Test 8");
                    PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest{
                        PlayFabId = playerData.PlayFabId,
                        CharacterId = sheet.CharacterID,
                        Data = cooldownData
                    }, result =>
                    {
                print("Logout cooldowns Test 9");
                CDPresent = false;
                }, error =>
                {
                    Debug.Log(error.ErrorMessage);
                    
                });
                while(CDPresent){
                    yield return null;
                }
                CDPresent = true;
            }
            }
            StartCoroutine(FinishLogout(conn, playerData.PlayFabId));
        }
            #endif

        private IEnumerator FinishLogout(NetworkConnectionToClient conn, string ID) {
            yield return new WaitForSeconds(2f);
            #if UNITY_SERVER //|| UNITY_EDITOR
            //if(!CheckNullConnection(conn)){
            //    yield break;
            //}
            //StartCoroutine(RemovePlayer(ID));
            bool KillmatchNeeded = false;

            if(conn != null){
                if(conn.identity != null){
                    if(conn.identity.gameObject != null){
                        ScenePlayer p = conn.identity.gameObject.GetComponent<ScenePlayer>();
                        if(p == null){
                            var playerConnection = playerConnections.Find(c => c.ConnectionId == conn.connectionId);
                            // Check if playerConnection exists
                            if (playerConnection == null) {
                                Debug.LogWarning("Player connection not found.");
                                yield break;
                            }
                            StartCoroutine(ServerDisconnectPlayerPause(conn, ID));
                            yield break;
                        }
                        KillmatchNeeded = p.currentMatch != null;


                    } else {
                        var playerConnection = playerConnections.Find(c => c.ConnectionId == conn.connectionId);
                            // Check if playerConnection exists
                            if (playerConnection == null) {
                                Debug.LogWarning("Player connection not found.");
                                yield break;
                            }
                            StartCoroutine(ServerDisconnectPlayerPause(conn, ID));
                            yield break;
                    }
                } else {
                    var playerConnection = playerConnections.Find(c => c.ConnectionId == conn.connectionId);
                            // Check if playerConnection exists
                            if (playerConnection == null) {
                                Debug.LogWarning("Player connection not found.");
                                yield break;
                            }
                            StartCoroutine(ServerDisconnectPlayerPause(conn, ID));
                            yield break;
                }
            }
            StopCoroutine(ReChargeEnergy(conn));
            Debug.Log("Client disconnected from server, ConnectionId: " + conn.connectionId);
            if(KillmatchNeeded){
                StartCoroutine(ServerDisconnectPlayer(conn, ID));
            } else {
                var playerConnection = playerConnections.Find(c => c.ConnectionId == conn.connectionId);
                // Check if playerConnection exists
                if (playerConnection == null) {
                    Debug.LogWarning("Player connection not found.");
                    yield break;
                }
                StartCoroutine(ServerDisconnectPlayerPause(conn, ID));
            }
            #endif
        }

        //Energy recharge
        private IEnumerator ReChargeEnergy(NetworkConnectionToClient conn) {
            ScenePlayer p = conn.identity.gameObject.GetComponent<ScenePlayer>();  
             
            while (true) {
                if(p == null){
                    yield break;
                }
                PlayerInfo player = (PlayerInfo)conn.authenticationData;
                yield return new WaitForSeconds(60);
                if(p == null){
                    yield break;
                }
                AdjustCurrentEnergy (conn, player);
            }
        }
        void AuthorizeEnergyUpdate(ScenePlayer player, float cost){
            #if UNITY_SERVER //|| UNITY_EDITOR

            NetworkConnectionToClient nconn = player.connectionToClient;
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED AuthorizeEnergyUpdate");
            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {
                UpdateEnergy(nconn, playerData, cost);
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }

        /*
[Server]
public void ServerRandomCharge(float amount){
    CharacterStatListItem EXPItem = (new CharacterStatListItem{
        Key = "EXP",
        Value = ""
    });
    Energy -= amount;
    float EXP = 0f;
    foreach(var stat in TacticianInformationSheet.TacticianStatData){
        if(stat.Key == "EXP"){
            EXP = float.Parse(stat.Value);
        }
    }
    EXP += amount;
    EXPItem.Value = Math.Round(EXP, 2).ToString("F2");
    TargetUpdateEnergyDisplay(Energy);
    GetTacticianEXP(EXPItem);
}
*/
        void ServerRandomCost(NetworkConnectionToClient nconn, float cost){
            if(!CheckNullConnection(nconn)){
                return;
            }
            ScenePlayer player = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED UpdateEnergy");
            player.Energy -= cost;
            player.TargetUpdateEnergyDisplay(player.Energy);
            CheckForLevelUpTactician(player, cost);
        }
        void UpdateEnergy(NetworkConnectionToClient nconn, PlayerInfo playerData, float cost){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            ScenePlayer player = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            player.Energy -= cost;
            player.TargetUpdateEnergyDisplay(player.Energy);
            print($"{playerData.PlayFabId} REQUESTED UpdateEnergy");
            CheckForLevelUpTactician(player, cost);
            //PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            //{
            //    PlayFabId = playerData.PlayFabId,
            //    Data = new Dictionary<string, string>
            //    {
            //        {"energy", player.Energy.ToString()},
            //        {"LastScene", player.currentScene}
            //        //{"savedNode", player.currentNode}
            //    }
            //    
            //}, result =>
            //{
            //}, error =>{
            //    Debug.Log(error.ErrorMessage);
            //});
            #endif
        }
        void AuthorizeMovementRequest(NetworkConnectionToClient nconn, string charliesTicket){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED AuthorizeMovementRequest");
            if(playerData.SessionTicket != charliesTicket)
            {
                //print($"{nconn.identity.gameObject} has been compromised, log information");
                return;
            }
            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {
                MovePlayerOVM(nconn, playerData);
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void MovePlayerOVM(NetworkConnectionToClient nconn, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR

            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED MovePlayerOVM");
            ScenePlayer player = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            float payment = 100f;
            float original = playerData.Energy;
            float newEnergy = original - payment;
            string NewEnergy = newEnergy.ToString();
            CheckForLevelUpTactician(player, payment);

            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                Data = new Dictionary<string, string>
                {
                    {"energy", NewEnergy},
                    {"LastScene", "OVM"}
                    //{"savedNode", saveNode}
                }
            }, result =>
            {
                player.Energy = newEnergy;
                //player.TravelToTheNode();
                
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        //void SetupLogin(NetworkConnectionToClient conn, ClientRequestLoadScene dummy)
        //{   
        //    //print("made it to setup login method before GetCleanedSceneName");
        //    GetCleanedSceneName(conn, dummy);
        //    StartCoroutine(ReChargeEnergy(conn));
        //}
        //IEnumerator LoginSetup(NetworkConnectionToClient conn, ClientRequestLoadScene dummy){
        //    yield return new WaitForSeconds(1f);
        //    //print("made it to login Setup");
        //    SetupLogin(conn, dummy);
        //}
        void AdjustCurrentEnergy(NetworkConnectionToClient conn, PlayerInfo playerData) {
            if(!CheckNullConnection(conn)){
                return;
            }
            

            print($"{playerData.PlayFabId} REQUESTED AdjustCurrentEnergy");
        float _oldEnergy = conn.identity.gameObject.GetComponent<ScenePlayer>().Energy;
        ScenePlayer p = conn.identity.gameObject.GetComponent<ScenePlayer>(); 
        //float _oldEnergy = playerData.Energy;
        //print($"_oldEnergy is {_oldEnergy}");
        float fastRechargeRate = 2.08f;
        float normalRechargeRate = 0.694444f;
        float newEnergy = 0.0f;
        if(_oldEnergy >= 3000){
            newEnergy = normalRechargeRate + _oldEnergy;
            if(newEnergy >= 10000.0f)
            {
               playerData.Energy = 10000.0f; 
            }else{
                playerData.Energy = newEnergy;
                //print($"New energy is {playerData.Energy}");
            }
        }else{ 
            if(_oldEnergy < 3000)
            {
                var FastChargeableAmount = 3000.0f - _oldEnergy;
                if(FastChargeableAmount >= fastRechargeRate)
                {
                    newEnergy = fastRechargeRate + _oldEnergy;
                    playerData.Energy = newEnergy;
                    //print($"New energy is {playerData.Energy}");
                }else{
                    float SlowSecondRate = 0.0115740666666667f;
                    float FastSecondRate = 0.0346666666666667f;
                    var firstTimeHalf = FastChargeableAmount/FastSecondRate;
                    var SecondTimeHalf = 60.0f - firstTimeHalf;
                    var slowCharge = SecondTimeHalf * SlowSecondRate;
                    newEnergy = slowCharge + firstTimeHalf + _oldEnergy;
                    playerData.Energy = newEnergy;
                    //print($"New energy is {playerData.Energy}");
                }   
            }            
        }
        if(p != null)
        {
            conn.authenticationData = playerData;
              
            p.EnergyTick(newEnergy);
        }else{
            //print("Solution worked");
            return;
        }
    }
        //CHARACTER FUNCTIONS /// OTHER FUNCTIONS
        void CharacterCreation(NetworkConnectionToClient nconn, string _nameRequest, string _Type, string spri){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED CharacterCreation");
            //print($"{_nameRequest} is name, {_Type} is type, {spri} is sprite name. ");
            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {
                //print("got to CheckInventoryUniversal");
                CheckInventoryUniversal(nconn, playerData, _nameRequest, _Type, spri);
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void CheckInventoryUniversal(NetworkConnectionToClient nconn, PlayerInfo playerData, string _nameRequest, string _Type, string spri){
            #if UNITY_SERVER //|| UNITY_EDITOR
        if(!CheckNullConnection(nconn)){
                return;
            }
            
            print($"{playerData.PlayFabId} REQUESTED CheckInventoryUniversal");
        PlayFabServerAPI.GetUserInventory(new GetUserInventoryRequest
            {
                PlayFabId = playerData.PlayFabId,


            }, result =>
            {
                //print("got to right before SpendUniversalToken");
                ScenePlayer player = nconn.identity.gameObject.GetComponent<ScenePlayer>();
                //List<string> strings = new List<string>();
                List<ItemInstance> inventory = result.Inventory;

                string id = string.Empty;

                for (int i = 0; i < inventory.Count; i++)
                {
                    if(inventory[i].ItemId == "UniversalToken"){
                        int? tokenz = inventory[i].RemainingUses;
                        int TokensLeft = 0;
                        id = inventory[i].ItemInstanceId;
                        if(tokenz.HasValue){
                            TokensLeft = tokenz.Value;
                            SpendUniversalToken(nconn, playerData, id, _nameRequest, _Type, spri);
                            //player.TokenCounted(TokensLeft);
                        }
                    }
                }
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void SpendUniversalToken(NetworkConnectionToClient nconn, PlayerInfo playerData, string ID, string _nameRequest, string _Type, string spri){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            
            print($"{playerData.PlayFabId} REQUESTED SpendUniversalToken");
                ScenePlayer player = nconn.identity.GetComponent<ScenePlayer>();
                print($"Build character tokens before = {player.TokenCount}");

            int tokens = 0;
            PlayFabServerAPI.ConsumeItem(new ConsumeItemRequest
            {
                PlayFabId = playerData.PlayFabId,
                ItemInstanceId = ID,
                ConsumeCount = 1
            }, result =>
            {
                BuildCharacter(nconn, playerData, _nameRequest, _Type, spri);
                print($"Build character tokens after = {result.RemainingUses}");
                tokens = result.RemainingUses;
                player.TokenCounted(tokens);
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void OpenWyvernEgg(NetworkConnectionToClient nconn, string _nameRequest){
            string spri = "WyvernBaby";
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            BuildCharacter(nconn, playerData, _nameRequest, "Wyvern", spri);
        }
        void UpdateWyvern(NetworkConnectionToClient nconn, string type, string ID){
            #if UNITY_SERVER //|| UNITY_EDITOR
                if(!CheckNullConnection(nconn)){
                    return;
                }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;

                PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    CharacterId = ID,
                    Data = new Dictionary<string, string>
                    {
                        {"CharacterSprite", type}
                    }
                }, result =>
                {
                    Dictionary<string, string> stats = new Dictionary<string, string>();
                    stats.Add("CharacterSprite", type);
                    FinishUpdateCharacterSprite(nconn, playerData, ID, stats);
                }, error =>{
                    Debug.Log(error.ErrorMessage); 
                    Debug.Log(error.ErrorDetails);
                    Debug.Log(error.Error);
                });
            #endif
        }
        void BuildCharacter(NetworkConnectionToClient nconn, PlayerInfo playerData, string _nameRequest, string _Type, string spri){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            
            print($"{playerData.PlayFabId} REQUESTED BuildCharacter");
            PlayFabServerAPI.GrantCharacterToUser(new GrantCharacterToUserRequest
            {
                PlayFabId = playerData.PlayFabId,
                CharacterName = _nameRequest,
                CharacterType = _Type
            }, result =>
            {
                string id = result.CharacterId;
                UpdateCharacterSprite(nconn, playerData, _nameRequest, _Type, spri, id);
            }, error =>{
                    Debug.Log(error.ErrorMessage);
                    Debug.Log(error.ErrorDetails);
                    Debug.Log(error.Error);
                });
            #endif
        }
        void UpdateCharacterSprite(NetworkConnectionToClient nconn, PlayerInfo playerData, string _nameRequest, string _Type, string spri, string ID){
            #if UNITY_SERVER //|| UNITY_EDITOR
        if(!CheckNullConnection(nconn)){
                return;
            }
            
            print($"{playerData.PlayFabId} REQUESTED UpdateCharacterSprite");
            int FORTITUDE = 0;
            int ARCANA = 0;
            if(_Type == "Wyvern"){
                FORTITUDE = 15;
                ARCANA = 60;
            }
            if(_Type == "Fighter"){
                FORTITUDE = 90;
                ARCANA = 50;
            }
            if(_Type == "Rogue"){
                FORTITUDE = 70;
                ARCANA = 60;
            }
            if(_Type == "Priest"){
                FORTITUDE = 90;
                ARCANA = 90;
            }
            if(_Type == "Archer"){
                FORTITUDE = 70;
                ARCANA = 50;
            }
            if(_Type == "Wizard"){
                FORTITUDE = 50;
                ARCANA = 120;
            }
            if(_Type == "Enchanter"){
                FORTITUDE = 40;
                ARCANA = 140;
            }
            if(_Type == "Druid"){
                FORTITUDE = 75;
                ARCANA = 100;
            }
            if(_Type == "Paladin"){
                FORTITUDE = 85;
                ARCANA = 70;
            }
            ScenePlayer player = nconn.identity.gameObject.GetComponent<ScenePlayer>();

            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            TacticianFullDataMessage tacticianSheet = player.GetTacticianSheet();
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);
            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                }
            }
            int MaxHP = tacticianBonusFortitude + FORTITUDE;
            int MaxMP = (tacticianBonusArcana + ARCANA) / 7;
            //print($"{_Type} is class and {_nameRequest} is name requested");
            PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    CharacterId = ID,
                    Data = new Dictionary<string, string>
                    {
                        {"CharacterSprite", spri}, {"LVL", "1"}, {"EXP", "0"}, 
                        {"currentMP", MaxMP.ToString()}, {"Class", _Type}, {"CharName", _nameRequest}, 
                        {"currentHP", MaxHP.ToString()}, {"ClassPoints", "55"}
                    }
                }, result =>
                {
                    Dictionary<string, string> stats = new Dictionary<string, string>();
                    stats.Add("CharacterSprite", spri);
                    stats.Add("LVL", "1");
                    stats.Add("EXP", "0");
                    stats.Add("currentMP", MaxMP.ToString());
                    stats.Add("Class", _Type);
                    stats.Add("CharName", _nameRequest);
                    stats.Add("currentHP", MaxHP.ToString());
                    stats.Add("ClassPoints", "55");
                    FinishUpdateCharacterSprite(nconn, playerData, ID, stats);
                }, error =>{
                    Debug.Log(error.ErrorMessage); 
                    Debug.Log(error.ErrorDetails);
                    Debug.Log(error.Error);
                });
            #endif
        }
        void FinishUpdateCharacterSprite(NetworkConnectionToClient nconn, PlayerInfo playerData, string ID, Dictionary<string, string> stats){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            
            print($"{playerData.PlayFabId} REQUESTED FinishUpdateCharacterSprite");
            string none = "None";
            PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    CharacterId = ID,
                    Data = new Dictionary<string, string>
                    {
                        {"CharacterID", ID}, {"SPELLQ", none}, {"SPELLE", none}, 
                        {"SPELLR", none}, {"SPELLF", none}, {"CORE", "STANDARD"}
                    }
                }, result =>
                {
                    stats.Add("CharacterID", ID);
                    stats.Add("SPELLQ", none);
                    stats.Add("SPELLE", none);
                    stats.Add("SPELLR", none);
                    stats.Add("SPELLF", none);
                    stats.Add("CORE", "STANDARD");
                    GetNewCharacterList(nconn, playerData, ID, stats);  
                }, error =>{
                    Debug.Log(error.ErrorMessage); 
                    Debug.Log(error.ErrorDetails);
                    Debug.Log(error.Error);
                });    
            #endif
        }
        void GetNewCharacterList(NetworkConnectionToClient nconn, PlayerInfo playerData, string ID, Dictionary<string, string> stats)
        {   
            #if UNITY_SERVER //|| UNITY_EDITOR
if(!CheckNullConnection(nconn)){
                return;
            }
            bool wyvern = false;
            foreach(var stat in stats){
                if(stat.Key == "Class"){
                    if(stat.Value == "Wyvern"){
                        wyvern = true;
                    }
                    break;
                }
            }
            
            print($"{playerData.PlayFabId} REQUESTED GetNewCharacterList");
            if(wyvern){
                ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
                List<CharacterStatListItem> charStatData = new List<CharacterStatListItem>();
                List<CharacterSpellListItem> charSpellData = new List<CharacterSpellListItem>();
                foreach (var statKey in stats) {
                    if (statKey.Key == "SPELLQ" || statKey.Key == "SPELLE" || statKey.Key == "SPELLR" || statKey.Key == "SPELLF") {
                        // Create a CharacterSpellListItem and add it to charSpellData
                        CharacterSpellListItem spell = new CharacterSpellListItem {
                            Key = statKey.Key,
                            Value = statKey.Value
                        };
                        charSpellData.Add(spell);
                    } else {
                        // Create a CharacterStatListItem and add it to charStatData
                        CharacterStatListItem stat = new CharacterStatListItem {
                            Key = statKey.Key,
                            Value = statKey.Value
                        };
                        charStatData.Add(stat);
                    }
                }
                List<CharacterInventoryListItem> charInventoryData = new List<CharacterInventoryListItem>();
                List<CharacterBuffListItem> charBuffData = new List<CharacterBuffListItem>();
                CharacterFullDataMessage newChar = (new CharacterFullDataMessage{
                    miningExp = 1f,
                    miningSkill = 1,
                    prospectingExp = 1f,
                    prospectingSkill = 1,
                    woodCuttingExp = 1f,
                    woodCuttingSkill = 1,
                    foragingExp = 1f,
                    foragingSkill = 1,
                    skinningExp = 1f,
                    skinningSkill = 1,
                    CharacterID = ID,
                    CharStatData = charStatData,
                    CharInventoryData = charInventoryData,
                    CharSpellData = charSpellData,
                    CharBuffData = charBuffData
                });
                stash.GetFullCharacterDataNew(newChar);
                return;
            }
            GetCharacterDataRequest request = new GetCharacterDataRequest();
            request.PlayFabId = playerData.PlayFabId;
            request.CharacterId = ID;
            PlayFabServerAPI.GetCharacterInternalData(request,
            result =>
            {
                ScenePlayer p = nconn.identity.GetComponent<ScenePlayer>();
                //p.TokenCount = p.TokenCount - 1;
                p.TargetTokenUpdate();
                List<string> items = new List<string>();
                string staff = "Tier1Staff";
                items.Add(staff);
                CreatingStaff(nconn, items, playerData, ID, stats);
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif   
        }
        void CreatingStaff(NetworkConnectionToClient nconn,List<string> items, PlayerInfo playerData, string charID, Dictionary<string, string> stats){
            #if UNITY_SERVER //|| UNITY_EDITOR

            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CreatingStaff");
            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
       (string DisplayName, string ItemClass, string ConsumableStatus) = GetItemDetails("Tier1Staff");
        ItemSelectable itemAdded  = ItemDataStorage.Instance.BuildItemSelectable(charID, "Plain", 1, null, false, stash.playerName, DisplayName, "NewItemGenerated", "Tier1Staff", "Main-Hand", false, false, false, false, true, "100", false, false);
            List<CharacterStatListItem> charStatData = new List<CharacterStatListItem>();
            List<CharacterSpellListItem> charSpellData = new List<CharacterSpellListItem>();
            foreach (var statKey in stats) {
                if (statKey.Key == "SPELLQ" || statKey.Key == "SPELLE" || statKey.Key == "SPELLR" || statKey.Key == "SPELLF") {
                    // Create a CharacterSpellListItem and add it to charSpellData
                    CharacterSpellListItem spell = new CharacterSpellListItem {
                        Key = statKey.Key,
                        Value = statKey.Value
                    };
                    charSpellData.Add(spell);
                } else {
                    // Create a CharacterStatListItem and add it to charStatData
                    CharacterStatListItem stat = new CharacterStatListItem {
                        Key = statKey.Key,
                        Value = statKey.Value
                    };
                    charStatData.Add(stat);
                }
            }
            List<CharacterInventoryListItem> charInventoryData = new List<CharacterInventoryListItem>();
            List<CharacterBuffListItem> charBuffData = new List<CharacterBuffListItem>();

            CharacterInventoryListItem staff = (new CharacterInventoryListItem{
                Key = "NewItemGenerated",
                Value = itemAdded
            });
            charInventoryData.Add(staff);
            CharacterFullDataMessage newChar = (new CharacterFullDataMessage{
                miningExp = 1f,
                miningSkill = 1,
                prospectingExp = 1f,
                prospectingSkill = 1,
                woodCuttingExp = 1f,
                woodCuttingSkill = 1,
                foragingExp = 1f,
                foragingSkill = 1,
                skinningExp = 1f,
                skinningSkill = 1,
                CharacterID = charID,
                CharStatData = charStatData,
                CharInventoryData = charInventoryData,
                CharSpellData = charSpellData,
                CharBuffData = charBuffData
            });
            stash.GetFullCharacterDataNew(newChar);
            #endif   
        }
        
        void SavePartyListAdding(NetworkConnectionToClient nconn, string member){
        #if UNITY_SERVER //|| UNITY_EDITOR
        if(!CheckNullConnection(nconn)){
                return;
            }
        PlayerInfo netMsg = (PlayerInfo)nconn.authenticationData;
        print($"{netMsg.PlayFabId} REQUESTED SavePartyListAdding");
        
        ScenePlayer p = nconn.identity.gameObject.GetComponent<ScenePlayer>();
        if(p == null){
            return;
        }
            p.AddPartyServer(member);
            /*
            string ZeroName = null;
            string OneName = null;
            string TwoName = null;
            string ThreeName = null;
            string FourName = null;
            string FiveName = null;
            List<string> IDs = new List<string>();
            foreach(var entry in p.GetParty())
            {
                IDs.Add(entry);
                if(ZeroName == null){
                    ZeroName = entry;
                    continue;
                }
                if(OneName == null){
                    OneName = entry;
                    continue;
                }
                if(TwoName == null){
                    TwoName = entry;
                    continue;
                }
                if(ThreeName == null){
                    ThreeName = entry;
                    continue;
                }
                if(FourName == null){
                    FourName = entry;
                    continue;
                }
                if(FiveName == null){
                    FiveName = entry;
                    continue;
                }
            }
            
            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = netMsg.PlayFabId,
                Data = new Dictionary<string, string>
                    {
                        {"PartyMemberZero", ZeroName}, {"PartyMemberOne", OneName},
                        {"PartyMemberTwo", TwoName}, {"PartyMemberThree", ThreeName},
                        {"PartyMemberFour", FourName}, {"PartyMemberFive", FiveName}
                    }
            }, result =>
            {

                netMsg.PartyIDs = IDs;
                nconn.authenticationData = netMsg;
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            */
            #endif
        }
        void SavePartyListRemoving(NetworkConnectionToClient nconn, string member){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo netMsg = (PlayerInfo)nconn.authenticationData;
        print($"{netMsg.PlayFabId} REQUESTED SavePartyListRemoving");

        
            ScenePlayer p = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            p.ServerRemovingPartymember(member);
            /*
            string ZeroName = null;
            string OneName = null;
            string TwoName = null;
            string ThreeName = null;
            string FourName = null;
            string FiveName = null;
            List<string> IDs = new List<string>();
            foreach(var entry in p.GetParty())
            {
                IDs.Add(entry);
                if(ZeroName == null){
                    ZeroName = entry;
                    continue;
                }
                if(OneName == null){
                    OneName = entry;
                    continue;
                }
                if(TwoName == null){
                    TwoName = entry;
                    continue;
                }
                if(ThreeName == null){
                    ThreeName = entry;
                    continue;
                }
                if(FourName == null){
                    FourName = entry;
                    continue;
                }
                if(FiveName == null){
                    FiveName = entry;
                    continue;
                }
            }
            
            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = netMsg.PlayFabId,
                Data = new Dictionary<string, string>
                    {
                        {"PartyMemberZero", ZeroName}, {"PartyMemberOne", OneName},
                        {"PartyMemberTwo", TwoName}, {"PartyMemberThree", ThreeName},
                        {"PartyMemberFour", FourName}, {"PartyMemberFive", FiveName}
                    }
            }, result =>
            {
                netMsg.PartyIDs = IDs;
                nconn.authenticationData = netMsg;
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            */
            #endif
        }
        //Granting items from vendor
        void PurchasedVendorItem(NetworkConnectionToClient nconn, uint Price, string ID, int quant){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
        print($"{playerData.PlayFabId} REQUESTED PurchasedVendorItem for item {ID} in amount of {quant} for {Price} Gold");
            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            int StashItemCount = 0;
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();

            foreach(var itemKey in tactSheet.StashInventoryData){
                if(itemKey.Value.GetTacticianStash() && !itemKey.Value.GetNFT()){
                    StashItemCount ++;
                }
            }
            if(StashItemCount == 100){
                //print($"inventory is maxed at {StashItemCount} items!! should be 60");
                return;
            }
            List<string> items = new List<string>();
            items.Add(ID);
            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {
                //GetUserDKPCoins(nconn, items, playerData, quant);
                GetItemPrices(nconn, items, playerData, quant);

            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void GetUserDKPCoins(NetworkConnectionToClient nconn,List<string> items, PlayerInfo playerData, int quant){
            #if UNITY_SERVER //|| UNITY_EDITOR

            PlayFabServerAPI.GetUserInventory(new GetUserInventoryRequest
            {
                PlayFabId = playerData.PlayFabId
            }, result =>
            {
                int DragonKillCoins = 0;
                Dictionary<string, int> findDKP = result.VirtualCurrency;
                foreach(var key in findDKP){
                    if(key.Key == "DK"){
                        DragonKillCoins = key.Value;
                        //print(DragonKillCoins);
                    }
                }
                //GetItemPrices(nconn, items, playerData, DragonKillCoins, quant);
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void GetItemPrices(NetworkConnectionToClient nconn,List<string> items, PlayerInfo playerData, int quant){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            if(items.Count > 0)

        print($"{playerData.PlayFabId} REQUESTED GetItemPrices for item {items[0]}");
        
            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            foreach(var _item in items){
                print($"{_item} is our itemname and its quant is {quant}");
            }
             PlayFabServerAPI.GetCatalogItems(new GetCatalogItemsRequest
            {
                CatalogVersion = "DragonKill_Characters_Bundles_Items"
            }, result =>
            {
                uint totalAmountDue = 0;
                foreach(var ID in items){
                    List<CatalogItem> ItemCatalog = result.Catalog;
                    foreach(CatalogItem i in ItemCatalog){
                        if(i.ItemId == ID){
                            print($"{i.ItemId} is our id");
                            Dictionary<string, uint> priceBook = i.VirtualCurrencyPrices;

                            foreach(var currencyCode in priceBook){
                                if(currencyCode.Key == "DK"){
                                    totalAmountDue = currencyCode.Value;
                                }
                            }
                        }
                    }
                }
                if(stash.Gold < totalAmountDue * quant){
                    //Pass not enough DKCoins message
                    stash.TargetEnablePurchaseBtn();
                    return;
                }
                print($"{stash.Gold} is our gold amount before payment");
                
                stash.Gold -= (long)totalAmountDue * quant;
                print($"{stash.Gold} is our gold amount after payment");
                //print($"Total gold due = {totalAmountDue}");
                //MakePayment(nconn, items, playerData, totalAmountDue, quant);
                ReceivingPayment(nconn, items, playerData, quant);
                //possibly change this so it doesnt actually subtract the amount
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void MakePayment(NetworkConnectionToClient nconn,List<string> items, PlayerInfo playerData, uint totalAmountDue, int quant){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            if(items.Count > 0)
        print($"{playerData.PlayFabId} REQUESTED MakePayment for item {items[0]}");
        
            if(totalAmountDue > Int32.MaxValue){
                return;
            }
            int amountDueNow = checked((int)totalAmountDue);
            //print($"Total gold due right now = {amountDueNow}");
            PlayFabServerAPI.SubtractUserVirtualCurrency(new SubtractUserVirtualCurrencyRequest
            {
                PlayFabId = playerData.PlayFabId,
                Amount = amountDueNow,
                VirtualCurrency = "DK"

            }, result =>
            {
                ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
                if(stash == null){
                    return;
                }
                long cAmount = stash.Gold;
                long nAmount = cAmount - (long)totalAmountDue;
                if(nAmount > 0){
                    stash.Gold = nAmount;
                    //stash.GoldAmountSet(nAmount);
                    stash.TargetWalletAwake();
                }
                if(nAmount <= 0){
                    stash.GoldAmountSet(0);
                    stash.TargetWalletAwake();
                }
                //print($"Client paid for item in the amount of DK coins:{amountDueNow}");
                ReceivingPayment(nconn, items, playerData, quant);
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void ReceivingPayment(NetworkConnectionToClient nconn,List<string> items, PlayerInfo playerData, int quant){
        #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(items.Count > 0)
        print($"{playerData.PlayFabId} REQUESTED ReceivingPayment for item {items[0]}");
            foreach(var itemid in items){
                (string DisplayName, string ItemClass, string ConsumableStatus) = GetItemDetails(itemid);
                string Quality = "Plain";
                if(ItemClass == "TwoHandedWeapon" || ItemClass == "SingleHandedWeapon" || ItemClass == "Head" || 
                ItemClass == "Chest"  || ItemClass == "Waist" || ItemClass == "Wrists" || ItemClass == "Earring" ||
                ItemClass == "Arms" || ItemClass == "Feet" || ItemClass == "Hands" || ItemClass == "Ring"
                || ItemClass == "Leggings" || ItemClass == "Necklace" || ItemClass == "OffHand"
                || ItemClass == "Shield" || ItemClass == "Shoulders" || ItemClass == "Arms"){
                    Quality = GetQualityDropFormula();
                }
                //print($"{choice} is choice {Quality} is quality");
                TransformItemIntoDragonKill(nconn,playerData, itemid, "Tactician", "Plain", quant, false, false, null, false, stash.playerName, false);
                stash.TargetWalletAwake();
                stash.TargetEnablePurchaseBtn();
            }
            #endif
        }
        /*
        #if UNITY_SERVER //|| UNITY_EDITOR
    IEnumerator ProcessItems(NetworkConnectionToClient nconn, PlayerInfo playerData, List<GrantedItemInstance> items, Dictionary<string,string> nftDictionary, Action onComplete)
    {
        if(!CheckNullConnection(nconn)){
                yield break;
            }
        ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
        if(sPlayer == null){
            yield break;
        }
        Dictionary<string, string> newNftDictionary = null;
        if(nftDictionary != null){
            newNftDictionary = nftDictionary;
            
        }
        foreach (var item in items)
        {
            print($"{item.ItemId} is item ID we are processing");
            string NFTID = "NotNFT";
            if(nftDictionary != null){
                string RemovingKey = string.Empty;
                foreach(var kvp in newNftDictionary){
                    if(kvp.Key == item.ItemId){
                        NFTID = kvp.Value;
                        RemovingKey = kvp.Key;
                        break;
                    }
                }
                if(newNftDictionary.ContainsKey(RemovingKey)){
                    newNftDictionary.Remove(RemovingKey);
                }
            }
            TransformItemIntoDragonKill(nconn, playerData, item, "Stash", "Plain", 1, true, false, NFTID, true, sPlayer.playerName);
            yield return new WaitForSeconds(1f);
        }
        onComplete();
    }
        #endif
        */
        List<List<string>> BatchItems(List<string> items, int batchSize)
{
    List<List<string>> batches = new List<List<string>>();

    for (int i = 0; i < items.Count; i += batchSize)
    {
        batches.Add(items.GetRange(i, Math.Min(batchSize, items.Count - i)));
    }

    return batches;
}
        #if UNITY_SERVER //|| UNITY_EDITOR
        /*
     IEnumerator ProcessItemsDEVBUILD(NetworkConnectionToClient nconn, PlayerInfo playerData, List<GrantedItemInstance> items, string Quality,  Action onComplete) //Dictionary<string,string> nftDictionary,
    {
        if(!CheckNullConnection(nconn)){
            yield break;
        }
        ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
        if(sPlayer == null){
            yield break;
        }
        //Dictionary<string, string> newNftDictionary = null;
        //if(nftDictionary != null){
        //    newNftDictionary = nftDictionary;
        //    
        //}
            string NFTID = "NotNFT";

        foreach (var item in items)
        {
            //print($"{item.ItemId} is item ID we are processing");
            //string NFTID = "NotNFT";
            //if(nftDictionary != null){
            //    string RemovingKey = string.Empty;
            //    foreach(var kvp in newNftDictionary){
            //        if(kvp.Key == item.ItemId){
            //            NFTID = kvp.Value;
            //            RemovingKey = kvp.Key;
            //            break;
            //        }
            //    }
            //    if(newNftDictionary.ContainsKey(RemovingKey)){
            //        newNftDictionary.Remove(RemovingKey);
            //    }
            //}
            TransformItemIntoDragonKill(nconn, playerData, item, "Stash", Quality, 1, true, false, NFTID, true, sPlayer.playerName);
            yield return new WaitForSeconds(1f);
        }
        onComplete();
    }
    */
        
        IEnumerator DEVBUILDINGITEMSCOROUTINE(NetworkConnectionToClient nconn, string buildType, string Quality)
        {
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                yield break;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            List<string> buildItems = DEVBUILDITEMREQUEST(buildType); // Assuming this is a method that returns your 380 items.
            List<List<string>> batchedItems = BatchItems(buildItems, 5);
            int batchCounter = 0;
            for (int i = 0; i < batchedItems.Count; i++)
            {
                // Accessing each batch
                List<string> batch = batchedItems[i];
                foreach(var batchItem in batch){
                    TransformItemIntoDragonKill(nconn, playerData, batchItem, "Stash", Quality, 1, false, false, null, false, sPlayer.playerName, false);
                }
                print("Processing batch " + (i + 1));
                //PlayFabServerAPI.GrantItemsToUser(new GrantItemsToUserRequest
                //{
                //    PlayFabId = playerData.PlayFabId,
                //    ItemIds = batch
                //},
                //result => 
                //{
                //    StartCoroutine(ProcessItemsDEVBUILD(nconn, playerData, result.ItemGrantResults, Quality, () => 
                //    {
                //        batchFinished = true;
                //    }));
                //}, 
                //error => 
                //{
                //    // Handle error
                //});
                //while(!batchFinished){
                //    yield return null;
                //}
                //batchCounter++;
                //// Check if 3 batches have been processed
                //if (batchCounter == 3)
                //{
                //    yield return new WaitForSeconds(15);
                //    batchCounter = 0; // Reset the batch counter
                //}
            }
        }
        #endif
        void DEVBUILDITEMREQUESTED(NetworkConnectionToClient nconn, string buildType, string Quality){
        #if UNITY_SERVER //|| UNITY_EDITOR
            StartCoroutine(DEVBUILDINGITEMSCOROUTINE(nconn, buildType, Quality));
        #endif

        }
        void DEVTELEPORT(NetworkConnectionToClient nconn, string NodeName, string PlayerName){
        #if UNITY_SERVER //|| UNITY_EDITOR
            StartCoroutine(TeleportDev(nconn, NodeName, PlayerName));
            
        #endif

        }
        string returnProperCoordName(string nodeName){
            string returnNode = "TOWNOFARUDINE";
            //{ "Spider Caverns_North", new Vector2(-31.5f, 5.5f) },
            //    { "Spider Caverns_South", new Vector2(-32.5f, 2.5f) },
            //    { "Lake Arudine_South", new Vector2(-39.5f, -14.5f) },
            //    { "Lake Arudine_East", new Vector2(-38.5f, -13.5f) },
            //    { "Sequoia Forest_East", new Vector2(-30.5f, -8.5f) },
            //    { "Sequoia Forest_West", new Vector2(-32.5f, -8.5f) }
            if(nodeName == "Spider Caverns"){
                return "Spider Caverns_South";
            }
            if(nodeName == "Lake Arudine"){
                return "Lake Arudine_South";
            }
            if(nodeName == "Sequoia Forest"){
                return "Sequoia Forest_West";
            }
            return returnNode;
        }
        IEnumerator TeleportDev(NetworkConnectionToClient nconn, string NodeName, string PlayerName){
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            Match match = sPlayer.currentMatch;
            if(sPlayer.playerName != PlayerName){
                foreach(var connect in playerConnections){
                    ScenePlayer sPlayerCheck = connect.conn.identity.gameObject.GetComponent<ScenePlayer>();
                    if(sPlayerCheck.playerName == PlayerName){
                        sPlayer = sPlayerCheck;
                        break;
                    }
                }
            }
            match = sPlayer.currentMatch;
            if(sPlayer.inMatch){
                ENDMATCHMAKER.Invoke(match);
                List<ScenePlayer> players = new List<ScenePlayer>();
                players = match.players;
                foreach( var player in players){
                    player.matchLeader = false;
                    player.inMatch = false;
                    player.TargetCloseEndGameCanvas();
                    ClientRequestLoadScene dummy = new ClientRequestLoadScene {
                        oldScene = player.currentScene,
                        newScene = "OVM",
                        direction = NodeName,
                        login = false,
                        GMTELEPORT = true
                    };
                    GetCleanedSceneName(player.GetConnection(), dummy);
                }
                foreach(var key in MatchList){
                    if(key.Key == match){
                        yield return SceneManager.UnloadSceneAsync(key.Value);
                    }
                }
                ENDMATCHFULLY.Invoke(match); 
                MatchList.Remove(match);
                processingMatches.Remove(match);
                MatchMaker.instance.FinishedMatch(match, match.players);
            } else {
                ClientRequestLoadScene dummySolo = new ClientRequestLoadScene {
                    oldScene = sPlayer.currentScene,
                    newScene = "OVM",
                    direction = NodeName,
                    login = false,
                    GMTELEPORT = true
                };
                GetCleanedSceneName(sPlayer.GetConnection(), dummySolo);
            }
        }
        void DEVHEALTEAM(NetworkConnectionToClient nconn){
        #if UNITY_SERVER //|| UNITY_EDITOR
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            sPlayer.Energy = 10000;
            sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
            StartCoroutine(HealPartyServer(nconn));
        #endif

        }
         void DEVBREAKINGPOINT(NetworkConnectionToClient nconn){
        #if UNITY_SERVER //|| UNITY_EDITOR
        //check for gm
            StartCoroutine(SendKamahlBreakingPoint());
        #endif

        }


    List<string> DEVBUILDITEMREQUEST(string itemType){
        List<string> allItems = new List<string>();
        if(itemType == "Cloth"){
            List<string> ClothItems = new List<string>
            {
                "BagT1",
                "TacticianBagT1",
                "ClothArmsT2",
                "ClothArmsT3",
                "ClothArmsT4",
                "ClothArmsT5",
                "ClothChestT2",
                "ClothChestT3",
                "ClothChestT4",
                "ClothChestT5",
                "ClothFeetT2",
                "ClothFeetT3",
                "ClothFeetT4",
                "ClothFeetT5",
                "ClothHandsT2",
                "ClothHandsT3",
                "ClothHandsT4",
                "ClothHandsT5",
                "ClothHeadT2",
                "ClothHeadT3",
                "ClothHeadT4",
                "ClothHeadT5",
                "ClothLeggingsT2",
                "ClothLeggingsT3",
                "ClothLeggingsT4",
                "ClothLeggingsT5",
                "ClothShouldersT2",
                "ClothShouldersT3",
                "ClothShouldersT4",
                "ClothShouldersT5",
                "ClothWaistT2",
                "ClothWaistT3",
                "ClothWaistT4",
                "ClothWaistT5",
                "ClothWristsT2",
                "ClothWristsT3",
                "ClothWristsT4",
                "ClothWristsT5",
            };
            allItems = ClothItems;
        }
        if(itemType == "Leather"){
            List<string> LeatherItems = new List<string>
            {
                "LeatherArmsT2",
                "LeatherArmsT3",
                "LeatherArmsT4",
                "LeatherArmsT5",
                "LeatherChestT2",
                "LeatherChestT3",
                "LeatherChestT4",
                "LeatherChestT5",
                "LeatherFeetT2",
                "LeatherFeetT3",
                "LeatherFeetT4",
                "LeatherFeetT5",
                "LeatherHandsT2",
                "LeatherHandsT3",
                "LeatherHandsT4",
                "LeatherHandsT5",
                "LeatherHeadT2",
                "LeatherHeadT3",
                "LeatherHeadT4",
                "LeatherHeadT5",
                "LeatherLeggingsT2",
                "LeatherLeggingsT3",
                "LeatherLeggingsT4",
                "LeatherLeggingsT5",
                "LeatherShouldersT2",
                "LeatherShouldersT3",
                "LeatherShouldersT4",
                "LeatherShouldersT5",
                "LeatherWaistT2",
                "LeatherWaistT3",
                "LeatherWaistT4",
                "LeatherWaistT5",
                "LeatherWristsT2",
                "LeatherWristsT3",
                "LeatherWristsT4",
                "LeatherWristsT5",
            };
            allItems = LeatherItems;
        }
        if(itemType == "Plate"){
            List<string> PlateItems = new List<string>
            {
                "PlateArmsT2",
                "PlateArmsT3",
                "PlateArmsT4",
                "PlateArmsT5",
                "PlateChestT2",
                "PlateChestT3",
                "PlateChestT4",
                "PlateChestT5",
                "PlateFeetT2",
                "PlateFeetT3",
                "PlateFeetT4",
                "PlateFeetT5",
                "PlateHandsT2",
                "PlateHandsT3",
                "PlateHandsT4",
                "PlateHandsT5",
                "PlateHeadT2",
                "PlateHeadT3",
                "PlateHeadT4",
                "PlateHeadT5",
                "PlateLeggingsT2",
                "PlateLeggingsT3",
                "PlateLeggingsT4",
                "PlateLeggingsT5",
                "PlateShouldersT2",
                "PlateShouldersT3",
                "PlateShouldersT4",
                "PlateShouldersT5",
                "PlateWaistT2",
                "PlateWaistT3",
                "PlateWaistT4",
                "PlateWaistT5",
                "PlateWristsT2",
                "PlateWristsT3",
                "PlateWristsT4",
                "PlateWristsT5"
            };
            allItems = PlateItems;
        }
        if(itemType == "Weapons"){
            List<string> WeaponItems = new List<string>
            {
                "GreatAxeT2",
                "GreatAxeT3",
                "GreatAxeT4",
                "GreatAxeT5",
                "GreatHammerT2",
                "GreatHammerT3",
                "GreatHammerT4",
                "GreatHammerT5",
                "GreatSpearT2",
                "GreatSpearT3",
                "GreatSpearT4",
                "GreatSpearT5",
                "GreatSwordT2",
                "GreatSwordT3",
                "GreatSwordT4",
                "GreatSwordT5",
                "MaceT2",
                "MaceT3",
                "MaceT4",
                "MaceT5",
                "ShieldT2",
                "ShieldT3",
                "ShieldT4",
                "ShieldT5",
                "ShieldT5-2",
                "SpearT2",
                "SpearT3",
                "SpearT4",
                "SpearT5",
                "StaffT2",
                "StaffT3",
                "StaffT4",
                "StaffT5",
                "SwordT2",
                "SwordT3",
                "SwordT4",
                "SwordT5",
                "AxeT2",
                "AxeT3",
                "AxeT4",
                "AxeT5",
                "BowT2",
                "BowT3",
                "BowT4",
                "BowT5",
                "DaggerT2",
                "DaggerT3",
                "DaggerT4",
                "DaggerT5",
                "TomeT2",
                "TomeT3",
                "TomeT4",
                "TomeT5",
                "Quiver01"
            };
            allItems = WeaponItems;
        }
        if(itemType == "Jewelry"){
            List<string> JewelryItems = new List<string>
            {
                "Earring01",
                "Earring02",
                "Earring03",
                "Earring04",
                "Earring05",
                "Earring06",
                "Earring07",
                "Earring08",
                "Earring09",
                "Earring10",
                "Earring11",
                "Earring12",
                "Earring13",
                "Earring14",
                "Earring15",
                "Necklace01",
                "Necklace02",
                "Necklace03",
                "Necklace04",
                "Necklace05",
                "Necklace06",
                "Necklace07",
                "Necklace08",
                "Necklace09",
                "Necklace10",
                "Necklace11",
                "Necklace12",
                "Necklace13",
                "Necklace14",
                "Necklace15",
                "Ring01",
                "Ring02",
                "Ring03",
                "Ring04",
                "Ring05",
                "Ring06",
                "Ring07",
                "Ring08",
                "Ring09",
                "Ring10",
                "Ring11",
                "Ring12",
                "Ring13",
                "Ring14",
                "Ring15"
            };
            allItems = JewelryItems;
        }
        if(itemType == "Alchemy"){
            List<string> AlchemyItems = new List<string>
            {
                "Potion01",
                "Potion02",
                "Potion03",
                "Potion04",
                "Potion05",
                "Potion06",
                "Potion07",
                "Potion08",
                "Potion09",
                "Potion10"
            };
            allItems = AlchemyItems;
        }
        if(itemType == "Cooking"){
            List<string> FoodItems = new List<string>
            {
                "Food02",
                "Food03",
                "Food04",
                "Food05",
                "Food06",
                "Food07",
                "Food08",
                "Food09"
            };
            allItems = FoodItems;
        }
        if(itemType == "TacticianGear"){
            List<string>TactGear = new List<string>{
                "TacticianArmsT1",
                "TacticianArmsT2",
                "TacticianChestT1",
                "TacticianChestT2",
                "TacticianFeetT1"
            };
            allItems = TactGear;
            allItems.Add("TacticianFeetT2");
            allItems.Add("TacticianHandsT1");
            allItems.Add("TacticianHandsT2");
            allItems.Add("TacticianHeadT1");
            allItems.Add("TacticianHeadT2");
            allItems.Add("TacticianLeggingsT1");
            allItems.Add("TacticianLeggingsT2");
            allItems.Add("TacticianShouldersT1");
            allItems.Add("TacticianShouldersT2");
        }
         if(itemType == "Tools"){
            allItems.Add("Tool01");
            allItems.Add("Tool02");
            allItems.Add("Tool03");
            allItems.Add("Tool04");
            allItems.Add("Tool05");
        }
        if(itemType == "Resources"){
            List<string> ResourceItems = new List<string>
            {

            };
            allItems = ResourceItems;
        }
        return allItems;
    }
        #if UNITY_SERVER //|| UNITY_EDITOR
   
    //GrantedItemInstance
    void TransformItemIntoDragonKill(NetworkConnectionToClient nconn, PlayerInfo playerData, string itemID, string selector, string Quality, int quant, bool login, bool Unstacking, string nftID, bool dropped, string owner, bool trade){
        //print($"{item.DisplayName} is the item that was setn to transform, {selector} is who we want to own this item");
        if(!CheckNullConnection(nconn)){
            return;
        }
       (string DisplayName, string ItemClass, string ConsumableStatus) = GetItemDetails(itemID);
        print($"{playerData.PlayFabId} REQUESTED TransformItemIntoDragonKill item: {DisplayName} for selected {selector} and {dropped} for dropped item");
        bool charInv = false;
        bool TactInv = false;
        string ownerID = string.Empty;
        if(selector == TACTICIAN){
            TactInv = true;
            ownerID = selector;
        }
        if(selector == "Stash"){
            ownerID = selector;
        }
        if(selector != TACTICIAN && selector != "Stash"){
            charInv = true;
            ownerID = selector;
        } 
        ItemSelectable itemAdded = ItemDataStorage.Instance.BuildItemSelectable(selector, Quality, quant, nftID, dropped, owner, DisplayName, "NewItemGenerated", itemID, "0", false, false, TactInv, charInv, false, "100", false, trade);
        //at this point we have the item we can decide the weight lets stop it here branch into a waiting method and then destroy on match destruction we can make a way to track it
        // lets get location so we can determine weight and inv space
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
        
        if(selector != "Stash" && dropped){
            bool SpaceAvailableForItemOnSpare = false;
            bool SpaceAvailableForItemOnSelection = false;
            string SpaceAvailableForItemSelected = string.Empty;
            print($"Part one for transform item check on drop");

            if(sPlayer != null){
                float tacticianWeight = 0f;
                int totalTacticianInvCount = 0;
                bool tactAvailSlot = false;
                int MaxWeight = 100;
                if(sPlayer.GetTacticianSheet().BodyStyle == "Small"){
                    MaxWeight = 100;
                }
                if(sPlayer.GetTacticianSheet().BodyStyle == "Average"){
                    MaxWeight = 120;
                }
                if(sPlayer.GetTacticianSheet().BodyStyle == "Large"){
                    MaxWeight = 140;
                }
                for (int u = 0; u < sPlayer.GetTacticianSheet().TacticianInventoryData.Count; u++)
                {
                //foreach(var tactItem in sPlayer.GetTacticianSheet().TacticianInventoryData){
                    if(sPlayer.GetTacticianSheet().TacticianInventoryData[u].Value.Deleted || sPlayer.GetTacticianSheet().TacticianInventoryData[u].Value.amount == 0){
                        continue;
                    }
                    if(sPlayer.GetTacticianSheet().TacticianInventoryData[u].Value.GetItemType() == ItemSelectable.ItemType.TacticianBag){
                        if(sPlayer.GetTacticianSheet().TacticianInventoryData[u].Value.Item_Name == "Tactician's Bag"){
                            MaxWeight += 30;
                        }
                    }
                    tacticianWeight += (sPlayer.GetTacticianSheet().TacticianInventoryData[u].Value.amount * float.Parse(sPlayer.GetTacticianSheet().TacticianInventoryData[u].Value.Weight));
                    if(sPlayer.GetTacticianSheet().TacticianInventoryData[u].Value.TacticianInventory){
                        if(sPlayer.GetTacticianSheet().TacticianInventoryData[u].Value.IsStackable() && sPlayer.GetTacticianSheet().TacticianInventoryData[u].Value.Item_Name == itemAdded.GetItemName()){
                            if(sPlayer.GetTacticianSheet().TacticianInventoryData[u].Value.GetAvailableSpaceForStackable() >= quant){
                                tactAvailSlot = true;
                            } else {
                                totalTacticianInvCount ++;
                            }
                        } else {
                            totalTacticianInvCount ++;
                        }
                    }
                }
                if(tacticianWeight + (float.Parse(itemAdded.GetWeight()) * quant) <= MaxWeight){
                    print($"We had enough weight left in tactician checking slots now!");
                    if(tactAvailSlot){
                        if(selector == "Tactician"){
                            SpaceAvailableForItemOnSpare = true;
                            print($"Selector was tactician and we are going able to set it avail for pick up in the inventory");

                        } else {
                            SpaceAvailableForItemOnSelection = true;
                            SpaceAvailableForItemSelected = "Tactician";
                            print($"Selector was not tactician and we are going able to set it avail for pick up in the inventory for tactician");
                        }
                    } else {
                        if(totalTacticianInvCount < 20){
                            if(selector == "Tactician"){
                                print($"Selector was tactician and we are going able to set it avail for pick up in the inventory");
                                SpaceAvailableForItemOnSpare = true;
                            } else {
                                SpaceAvailableForItemOnSelection = true;
                                SpaceAvailableForItemSelected = "Tactician";
                                print($"Selector was not tactician and we are going able to set it avail for pick up in the inventory for tactician");
                            }
                        }
                    }
                } else {
                    print($"Not enough weight left in tactician");

                }
                //if(!SpaceAvailableForItemOnSpare){
                    for (int i = 0; i < sPlayer.GetInformationSheets().Count; i++)
                    {
                        if(!sPlayer.GetParty().Contains(sPlayer.GetInformationSheets()[i].CharacterID)){
                            continue;
                        }
                        float charWeight = 0f;
                        int totalCharInvCount = 0;
                        bool charAvailSlot = false;
                        string charName = string.Empty;
                        string charClass = string.Empty;
                        string charCore = string.Empty;
                        int charLvl = 1;
                        int ItemStrength = 0;
                        bool dead = false;
                        for (int v = 0; v < sPlayer.GetInformationSheets()[i].CharStatData.Count; v++)
                        {
                            if(sPlayer.GetInformationSheets()[i].CharStatData[v].Key == "CharName"){
                                charName = sPlayer.GetInformationSheets()[i].CharStatData[v].Value;
                            }
                            if(sPlayer.GetInformationSheets()[i].CharStatData[v].Key == "Class"){
                                charClass = sPlayer.GetInformationSheets()[i].CharStatData[v].Value;
                            }
                            if(sPlayer.GetInformationSheets()[i].CharStatData[v].Key == "CORE"){
                                charCore = sPlayer.GetInformationSheets()[i].CharStatData[v].Value;
                            }
                            if(sPlayer.GetInformationSheets()[i].CharStatData[v].Key == "LVL"){
                                charLvl = int.Parse(sPlayer.GetInformationSheets()[i].CharStatData[v].Value);
                            }
                            if(sPlayer.GetInformationSheets()[i].CharStatData[v].Key == "DEATH"){
                                dead = true;
                            }
                        }
                        if (dead){
                            continue;
                        }
                        for (int w = 0; w < sPlayer.GetInformationSheets()[i].CharInventoryData.Count; w++)
                        {
                            if(sPlayer.GetInformationSheets()[i].CharInventoryData[w].Value.Deleted || sPlayer.GetInformationSheets()[i].CharInventoryData[w].Value.amount == 0){
                                continue;
                            }
                            if(sPlayer.GetInformationSheets()[i].CharInventoryData[w].Value.GetItemType() == ItemSelectable.ItemType.CharacterBag){
                                if(sPlayer.GetInformationSheets()[i].CharInventoryData[w].Value.Item_Name == "Bag"){
                                    ItemStrength += 30;
                                }
                            }
                            charWeight += (float.Parse(sPlayer.GetInformationSheets()[i].CharInventoryData[w].Value.Weight) * sPlayer.GetInformationSheets()[i].CharInventoryData[w].Value.amount);
                            if(sPlayer.GetInformationSheets()[i].CharInventoryData[w].Value.EQUIPPED){
                                if(!string.IsNullOrEmpty(sPlayer.GetInformationSheets()[i].CharInventoryData[w].Value.STRENGTH_item)){
                                    ItemStrength += int.Parse(sPlayer.GetInformationSheets()[i].CharInventoryData[w].Value.STRENGTH_item);
                                }
                            }
                        }
                        int PASSIVE_Strength = 0;
                        for(int _char = 0; _char < sPlayer.GetInformationSheets().Count; _char++){
                            if(sPlayer.GetInformationSheets()[_char].CharacterID == sPlayer.GetInformationSheets()[i].CharacterID){
                                for(int ability = 0; ability < sPlayer.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT2LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Strength = abilityRank;
                                            break;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(charClass, charLvl, charCore);
                        baseStrength += PASSIVE_Strength;
                        if((ItemStrength + baseStrength >= charWeight + (float.Parse(itemAdded.GetWeight()) * quant))){
                            for (int  p = 0;  p < sPlayer.GetInformationSheets()[i].CharInventoryData.Count;  p++)
                            {
                                if(sPlayer.GetInformationSheets()[i].CharInventoryData[p].Value.Deleted || sPlayer.GetInformationSheets()[i].CharInventoryData[p].Value.amount == 0){
                                    continue;
                                }
                                if(sPlayer.GetInformationSheets()[i].CharInventoryData[p].Value.INVENTORY){
                                    if(sPlayer.GetInformationSheets()[i].CharInventoryData[p].Value.IsStackable() && sPlayer.GetInformationSheets()[i].CharInventoryData[p].Value.Item_Name == itemAdded.GetItemName() && (ItemStrength + baseStrength >= charWeight)){
                                        if(sPlayer.GetInformationSheets()[i].CharInventoryData[p].Value.GetAvailableSpaceForStackable() >= quant){
                                            charAvailSlot = true;
                                        } else {
                                            totalCharInvCount ++;
                                        }
                                    } else {
                                        totalCharInvCount ++;
                                    }
                                }
                            }
                            if(charAvailSlot){
                                //we are good to go here
                                if(selector == sPlayer.GetInformationSheets()[i].CharacterID){
                                    SpaceAvailableForItemOnSpare = true;
                                    print($"Selector was this and we are going able to set it avail for pick up in the inventory for {selector}");
                                    break;
                                } else {
                                    SpaceAvailableForItemOnSelection = true;
                                    SpaceAvailableForItemSelected = sPlayer.GetInformationSheets()[i].CharacterID;
                                    print($"{selector} was not this and we are going able to set it avail for pick up in the inventory for {sPlayer.GetInformationSheets()[i].CharacterID}");
                                }
                            } else {
                                if(totalCharInvCount < 20){
                                    if(selector == sPlayer.GetInformationSheets()[i].CharacterID){
                                        SpaceAvailableForItemOnSpare = true;
                                        print($"Selector was this and we are going able to set it avail for pick up in the inventory for {selector}");
                                        break;
                                    } else {
                                        SpaceAvailableForItemOnSelection = true;
                                        SpaceAvailableForItemSelected = sPlayer.GetInformationSheets()[i].CharacterID;
                                        print($"{selector} was not this and we are going able to set it avail for pick up in the inventory for {sPlayer.GetInformationSheets()[i].CharacterID}");
                                    }
                                }
                            }
                        } 
                    }
            }
            if(!SpaceAvailableForItemOnSpare){
                if(SpaceAvailableForItemOnSelection){
                    print($"{selector} didnt have room, transfering to {SpaceAvailableForItemSelected}");
                    TransformItemIntoDragonKill(nconn, playerData, itemAdded.itemID, SpaceAvailableForItemSelected, Quality, quant, false, false, null, dropped, owner, trade);
                    return;
                }
                //sPlayer.ServerStorePurchaseData(selector, nconn, "NewItemGenerated", playerData, itemAdded, statBookOne, statBookTwo, statBookThree, statBookFour, statBookFive, statBookSix, login, Unstacking);
                print($"{selector} didnt have room, neither did anyone else we are going to send to its item container *************************************************************************");
                itemAdded.INVENTORY = false;
                itemAdded.TacticianInventory = false;
                itemAdded.OGTacticianInventory = false;
                sPlayer.ServerStorePurchaseData(itemAdded);
                return;
            } else {
                print($"{selector} had room");
            }
        }
        //SignBookOnePurchase(selector, nconn, "NewItemGenerated", playerData, itemAdded, statBookOne, statBookTwo, statBookThree, statBookFour, statBookFive, statBookSix, login, Unstacking);
        //SignBookReduced(selector, nconn, "NewItemGenerated", playerData, itemAdded, statBookOne, login, Unstacking);
        StackingMessage message = (new StackingMessage {
            owner = sPlayer,
            ownerItemTwo = itemAdded.OwnerID,
            itemTwo = itemAdded,
            itemTwoAmount = itemAdded.amount
        });
        CharacterInventoryListItem DATA = new CharacterInventoryListItem();
            DATA.Key = itemAdded.InstanceID;
            DATA.Value = itemAdded;
        if(selector == "Stash"){
            //print("select was Stash");
            //put in tactician sheet pass to server then gucci
            if(itemAdded.IsStackable() && !login && itemAdded.CanAdd()){
                for (int H = 0; H < sPlayer.GetTacticianSheet().StashInventoryData.Count; H++)
                {
                //foreach(var stashItem in sPlayer.GetTacticianSheet().StashInventoryData){
                    //if item is same and has room stack it! else pass as a new item
                    if (sPlayer.GetTacticianSheet().StashInventoryData[H].Value.Deleted || sPlayer.GetTacticianSheet().StashInventoryData[H].Value.amount == 0){
                        continue;
                    }
                    if(sPlayer.GetTacticianSheet().StashInventoryData[H].Value.Item_Name == itemAdded.Item_Name && sPlayer.GetTacticianSheet().StashInventoryData[H].Value.GetAvailableSpaceForStackable() >= itemAdded.amount && !Unstacking){
                        message.ownerItemOne = "Stash";
                        message.itemOneAmount = sPlayer.GetTacticianSheet().StashInventoryData[H].Value.amount;
                        message.itemOne = sPlayer.GetTacticianSheet().StashInventoryData[H].Value;
                        message.itemOne.Changed = true;
                        message.itemTwoAmount = itemAdded.GetAmount();
                        message.itemTwo = itemAdded;
                        StackingItemDropped(nconn, message);
                        return;
                    }
                }
                sPlayer.ServerPurchasedItemResult(DATA);
            } else {
                sPlayer.ServerPurchasedItemResult(DATA);
            }
        } else {
            if(selector == "Tactician"){
                //print("Select was Tactician");
                //create logic to add to tactician inventory
                if(itemAdded.IsStackable() && !login && itemAdded.CanAdd()){
                    for (int Q = 0; Q < sPlayer.GetTacticianSheet().TacticianInventoryData.Count; Q++)
                    {
                        if (sPlayer.GetTacticianSheet().TacticianInventoryData[Q].Value.Deleted || sPlayer.GetTacticianSheet().TacticianInventoryData[Q].Value.amount == 0){
                            continue;
                        }
                    //foreach(var tactItem in sPlayer.GetTacticianSheet().TacticianInventoryData){
                        //if item is same and has room stack it! else pass as a new item
                        if(sPlayer.GetTacticianSheet().TacticianInventoryData[Q].Value.Item_Name == itemAdded.Item_Name && sPlayer.GetTacticianSheet().TacticianInventoryData[Q].Value.GetAvailableSpaceForStackable() >= 1 && !Unstacking){
                            int stackingItemAmount = sPlayer.GetTacticianSheet().TacticianInventoryData[Q].Value.amount;
                            message.ownerItemOne = "Tactician";
                            message.itemOneAmount = sPlayer.GetTacticianSheet().TacticianInventoryData[Q].Value.amount;
                            message.itemOne = sPlayer.GetTacticianSheet().TacticianInventoryData[Q].Value;
                            message.itemOne.Changed = true;
                            message.itemTwoAmount = itemAdded.GetAmount();
                            message.itemTwo = itemAdded;
                            StackingItemDropped(nconn, message);
                            return;
                        }
                    }
                    sPlayer.ServerTacticianItemResult(DATA);
                } else {
                    sPlayer.ServerTacticianItemResult(DATA);
                }
            } else {
                //print($"Select was {select}");
                for (int R = 0; R < sPlayer.GetInformationSheets().Count; R++)
                {
                //foreach(var sheet in sPlayer.GetInformationSheets()){
                    if(sPlayer.GetInformationSheets()[R].CharacterID == itemAdded.OwnerID){
                        for (int E = 0; E < sPlayer.GetInformationSheets()[R].CharInventoryData.Count; E++)
                        {
                            if (sPlayer.GetInformationSheets()[R].CharInventoryData[E].Value.Deleted || sPlayer.GetInformationSheets()[R].CharInventoryData[E].Value.amount == 0){
                                continue;
                            }
                        //foreach(var invItem in sPlayer.GetInformationSheets()[R].CharInventoryData){
                            if(itemAdded.IsStackable() && itemAdded.CanAdd()){
                                if(sPlayer.GetInformationSheets()[R].CharInventoryData[E].Value.Item_Name == itemAdded.Item_Name && sPlayer.GetInformationSheets()[R].CharInventoryData[E].Value.GetAvailableSpaceForStackable() >= 1 && !Unstacking && itemAdded != sPlayer.GetInformationSheets()[R].CharInventoryData[E].Value){
                                    int stackingItemAmount = sPlayer.GetInformationSheets()[R].CharInventoryData[E].Value.amount;
                                    message.ownerItemOne = sPlayer.GetInformationSheets()[R].CharacterID;
                                    message.itemOneAmount = sPlayer.GetInformationSheets()[R].CharInventoryData[E].Value.amount;
                                    message.itemOne = sPlayer.GetInformationSheets()[R].CharInventoryData[E].Value;
                                    message.itemOne.Changed = true;
                                    message.itemTwoAmount = itemAdded.GetAmount();
                                    message.itemTwo = itemAdded;
                                    //print($"Select was {select} and we have an item we are trying to stack {invItem.Value.Item_Name} with amount {invItem.Value.amount}");
                                    StackingItemDropped(nconn, message);
                                    return;
                                }
                            }
                        }
                        print($"{sPlayer.GetInformationSheets()[R].CharacterID} picked up item {DATA.Value.GetItemName()}");
                        sPlayer.GetCharacterPickedUpItem(selector, DATA);
                        return;
                    }
                }
            }
        }
    }
    
    public (string DisplayName, string ItemClass, string ConsumableStatus) GetItemDetails(string itemId)
    {
        if (ItemDataStorage.Instance.GetItems().TryGetValue(itemId, out var itemDetails))
        {
            return itemDetails;
        }
        else
        {
            return (string.Empty, string.Empty, string.Empty);
        }
    }
    #endif
    
    //void RestartSignBookOnePurchase(SignBookOnePurchaseData signData){
    //    SignBookOnePurchase(signData.select, signData.nconn, signData.InstanceID, signData.playerData, signData.item, signData.statBookOne, signData.statBookTwo, signData.statBookThree, signData.statBookFour, signData.statBookFive, signData.statBookSix, signData.login, signData.Unstacking);
    //}
   
    /*
    void SignBookOnePurchase(string select, NetworkConnectionToClient nconn, string InstanceID, PlayerInfo playerData, ItemSelectable item, Dictionary<string,string> statBookOne, Dictionary<string,string> statBookTwo, Dictionary<string,string> statBookThree, Dictionary<string,string> statBookFour, Dictionary<string,string> statBookFive, Dictionary<string,string> statBookSix, bool login, bool Unstacking){
        #if UNITY_SERVER //|| UNITY_EDITOR
        if(!CheckNullConnection(nconn)){
                return;
            }
           
        print($"{playerData.PlayFabId} REQUESTED SignBookOnePurchase for item {item.GetItemName()}");
        //print("made it to first part");
        Dictionary<string,string> statBook = statBookOne; 
            
        PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
        {
            ItemInstanceId = InstanceID,
            PlayFabId = playerData.PlayFabId,
            Data = statBook
        }, result =>{
            //PassItemToStash(nconn, item);
            SignBookTwoPurchase(select, nconn, InstanceID, playerData, item, statBookTwo, statBookThree, statBookFour, statBookFive, statBookSix, login, Unstacking);
        }, error =>{
            //print("Failed second part of first");
            Debug.Log(error.ErrorMessage);
            Debug.Log(error.ErrorDetails);
            Debug.Log(error.Error);
        });
        #endif
    }
    */
void OverflowItemlooted(NetworkConnectionToClient nconn, ItemSelectable item, string serial){
            #if UNITY_SERVER //|| UNITY_EDITOR
        
        print($"Overflow intiated to be creating item {item.GetItemName()} for {serial}");
        PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
        ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            TransformItemIntoDragonKill(nconn, playerData, item.itemID, serial, item.GetQuality(), item.GetAmount(), false, false, null, true, sPlayer.playerName, false);

        if(sPlayer.OverflowItemsChecked.Contains(item)){
            print("Removing overflow item it was in our itemschecked and ready to build");
            //TransformItemIntoDragonKill(nconn, playerData, item.itemID, serial, item.GetQuality(), item.GetAmount(), false, false, null, true, sPlayer.playerName, false);
            sPlayer.OverflowItemsChecked.Remove(item);
        }
        #endif

    }
            void SignBookTwoPurchase(string select, NetworkConnectionToClient nconn, string InstanceID, PlayerInfo playerData, ItemSelectable item, Dictionary<string,string> statBookTwo, Dictionary<string,string> statBookThree, Dictionary<string,string> statBookFour, Dictionary<string,string> statBookFive, Dictionary<string,string> statBookSix, bool login, bool Unstacking){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
        print($"{playerData.PlayFabId} REQUESTED SignBookTwoPurchase");

            Dictionary<string,string> statBook = statBookTwo; 

            PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
            {
                ItemInstanceId = InstanceID,
                PlayFabId = playerData.PlayFabId,
                Data = statBook
            }, result =>{
                SignBookThreePurchase(select, nconn, InstanceID, playerData, item, statBookThree, statBookFour, statBookFive, statBookSix, login, Unstacking);
            }, error =>{
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
            #endif
        }
        void SignBookThreePurchase(string select, NetworkConnectionToClient nconn, string InstanceID, PlayerInfo playerData, ItemSelectable item, Dictionary<string,string> statBookThree, Dictionary<string,string> statBookFour, Dictionary<string,string> statBookFive, Dictionary<string,string> statBookSix, bool login, bool Unstacking){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
        print($"{playerData.PlayFabId} REQUESTED SignBookThreePurchase");

            Dictionary<string,string> statBook = statBookThree; 

            PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
            {
                ItemInstanceId = InstanceID,
                PlayFabId = playerData.PlayFabId,
                Data = statBook
            }, result =>{
                SignBookFourPurchase(select, nconn, InstanceID, playerData, item, statBookFour, statBookFive, statBookSix, login, Unstacking);
            }, error =>{
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
            #endif
        }
        void SignBookFourPurchase(string select, NetworkConnectionToClient nconn, string InstanceID, PlayerInfo playerData, ItemSelectable item, Dictionary<string,string> statBookFour, Dictionary<string,string> statBookFive, Dictionary<string,string> statBookSix, bool login, bool Unstacking){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
        print($"{playerData.PlayFabId} REQUESTED SignBookFourPurchase");

            Dictionary<string,string> statBook = statBookFour; 
            PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
            {
                ItemInstanceId = InstanceID,
                PlayFabId = playerData.PlayFabId,
                Data = statBook
            }, result =>{
           
                SignBookFivePurchase(select, nconn, InstanceID, playerData, item, statBookFive, statBookSix, login, Unstacking);
             
            }, error =>{
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
            #endif
        }
        void SignBookFivePurchase(string select, NetworkConnectionToClient nconn, string InstanceID, PlayerInfo playerData, ItemSelectable item, Dictionary<string,string> statBookFive, Dictionary<string,string> statBookSix, bool login, bool Unstacking){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
        print($"{playerData.PlayFabId} REQUESTED SignBookFivePurchase");

            Dictionary<string,string> statBook = statBookFive; 
            PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
            {
                ItemInstanceId = InstanceID,
                PlayFabId = playerData.PlayFabId,
                Data = statBook
            }, result =>{
           
                //(select, nconn, InstanceID, playerData, item, statBookSix, login, Unstacking);
             
            }, error =>{
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
            #endif
        }
        /*
        void SignBookReduced(string select, NetworkConnectionToClient nconn, string InstanceID, PlayerInfo playerData, ItemSelectable item, Dictionary<string,string> statBookSix, bool login, bool Unstacking){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
        print($"{playerData.PlayFabId} REQUESTED SignBookSixPurchase");

            Dictionary<string,string> statBook = statBookSix; 
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }

            //public struct StackingMessage : NetworkMessage
            //{
            //    public string ownerItemOne;
            //}
            
            StackingMessage message = (new StackingMessage {
                owner = sPlayer,
                ownerItemTwo = item.OwnerID,
                itemTwo = item,
                itemTwoAmount = item.amount
            });
            

            //here we will check to see if there are any we can stack with 
            PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
            {
                ItemInstanceId = InstanceID,
                PlayFabId = playerData.PlayFabId,
                Data = statBook
            }, result =>{
                CharacterInventoryListItem newItem = (new CharacterInventoryListItem {
                    Key = item.GetInstanceID(),
                    Value = item
                });
                if(select == "Stash"){
                    //print("select was Stash");
                    //put in tactician sheet pass to server then gucci
                    if(item.IsStackable() && !login && item.CanAdd()){
                        foreach(var stashItem in sPlayer.GetTacticianSheet().StashInventoryData){
                            //if item is same and has room stack it! else pass as a new item
                            if(stashItem.Value.Item_Name == item.Item_Name && stashItem.Value.GetAvailableSpaceForStackable() >= item.amount && !Unstacking){
                                int stackingItemAmount = stashItem.Value.amount;
                                message.ownerItemOne = "Tactician";
                                message.itemOneAmount = stashItem.Value.amount;
                                message.itemOne = stashItem.Value;
                                message.itemOne.Changed = true;
                                //print($"Select was {select} and we have an item we are trying to stack {stashItem.Value.Item_Name} with amount {stashItem.Value.amount}");
                                if(InstanceID != item.GetInstanceID()){
                                    ServerRemoveItemOnUser(nconn, InstanceID);
                                }
                                StackingItemDropped(nconn, message);
                                return;
                            }
                        }
                        sPlayer.ServerPurchasedItemResult(newItem);
                    } else {
                        sPlayer.ServerPurchasedItemResult(newItem);
                    }
                } else {
                    if(select == "Tactician"){
                        //print("Select was Tactician");
                        //create logic to add to tactician inventory
                        if(item.IsStackable() && !login && item.CanAdd()){
                            foreach(var tactItem in sPlayer.GetTacticianSheet().TacticianInventoryData){
                                //if item is same and has room stack it! else pass as a new item
                                if(tactItem.Value.Item_Name == item.Item_Name && tactItem.Value.GetAvailableSpaceForStackable() >= 1 && !Unstacking){
                                    int stackingItemAmount = tactItem.Value.amount;
                                    message.ownerItemOne = "Tactician";
                                    message.itemOneAmount = tactItem.Value.amount;
                                    message.itemOne = tactItem.Value;
                                    message.itemOne.Changed = true;
                                    //print($"Select was {select} and we have an item we are trying to stack {tactItem.Value.Item_Name} with amount {tactItem.Value.amount}");
                                    if(InstanceID != item.GetInstanceID()){
                                        ServerRemoveItemOnUser(nconn, tactItem.Value);
                                    }
                                    StackingItemDropped(nconn, message);
                                    return;
                                }
                            }
                            sPlayer.ServerTacticianItemResult(newItem);
                        } else {
                            sPlayer.ServerTacticianItemResult(newItem);
                        }
                    } else {
                        //print($"Select was {select}");
                        foreach(var sheet in sPlayer.GetInformationSheets()){
                            if(sheet.CharacterID == item.OwnerID){
                                foreach(var invItem in sheet.CharInventoryData){
                                    if(item.IsStackable() && item.CanAdd()){
                                        if(invItem.Value.Item_Name == item.Item_Name && invItem.Value.GetAvailableSpaceForStackable() >= 1 && !Unstacking && item != invItem.Value){
                                            int stackingItemAmount = invItem.Value.amount;
                                            message.ownerItemOne = sheet.CharacterID;
                                            message.itemOneAmount = invItem.Value.amount;
                                            message.itemOne = invItem.Value;
                                            message.itemOne.Changed = true;
                                            //print($"Select was {select} and we have an item we are trying to stack {invItem.Value.Item_Name} with amount {invItem.Value.amount}");
                                            if(InstanceID != item.GetInstanceID()){
                                                ServerRemoveItemOnUser(nconn, invItem.Value);
                                            }
                                            StackingItemDropped(nconn, message);
                                            return;
                                        }
                                    }
                                }
                                PlayFabServerAPI.MoveItemToCharacterFromUser( new MoveItemToCharacterFromUserRequest
                                {
                                    CharacterId = select,
                                    ItemInstanceId = item.GetInstanceID(),
                                    PlayFabId = playerData.PlayFabId,
                                }, result =>
                                {
                                    sPlayer.GetCharacterPickedUpItem(select, newItem);
                                }, error =>{
                                    Debug.Log(error.ErrorMessage);
                                });
                            }
                        }
                    }
                }
            }, error =>{
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
            #endif
        }
        */
        /*
        void SignBookSixPurchase(string select, NetworkConnectionToClient nconn, string InstanceID, PlayerInfo playerData, ItemSelectable item, Dictionary<string,string> statBookSix, bool login, bool Unstacking){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
        print($"{playerData.PlayFabId} REQUESTED SignBookSixPurchase");

            Dictionary<string,string> statBook = statBookSix; 
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }

            //public struct StackingMessage : NetworkMessage
            //{
            //    public string ownerItemOne;
            //}
            
            StackingMessage message = (new StackingMessage {
                owner = sPlayer,
                ownerItemTwo = item.OwnerID,
                itemTwo = item,
                itemTwoAmount = item.amount
            });
            

            //here we will check to see if there are any we can stack with 
            PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
            {
                ItemInstanceId = InstanceID,
                PlayFabId = playerData.PlayFabId,
                Data = statBook
            }, result =>{
                CharacterInventoryListItem newItem = (new CharacterInventoryListItem {
                    Key = item.GetInstanceID(),
                    Value = item
                     
                });
                if(select == "Stash"){
                    //print("select was Stash");
                    //put in tactician sheet pass to server then gucci
                    if(item.IsStackable() && !login && item.CanAdd()){
                        foreach(var stashItem in sPlayer.GetTacticianSheet().StashInventoryData){
                            //if item is same and has room stack it! else pass as a new item
                            if(stashItem.Value.Item_Name == item.Item_Name && stashItem.Value.GetAvailableSpaceForStackable() >= item.amount && !Unstacking){
                                int stackingItemAmount = stashItem.Value.amount;
                                message.ownerItemOne = "Tactician";
                                message.itemOneAmount = stashItem.Value.amount;
                                message.itemOne = stashItem.Value;
                                message.itemOne.Changed = true;
                                //print($"Select was {select} and we have an item we are trying to stack {stashItem.Value.Item_Name} with amount {stashItem.Value.amount}");
                                ServerRemoveItemOnUser(nconn, InstanceID);
                                StackingItemDropped(nconn, message);
                                return;
                            }
                        }
                        sPlayer.ServerPurchasedItemResult(newItem);
                    } else {
                        sPlayer.ServerPurchasedItemResult(newItem);
                    }
                } else {
                    if(select == "Tactician"){
                        //print("Select was Tactician");
                        //create logic to add to tactician inventory
                        if(item.IsStackable() && !login && item.CanAdd()){
                            foreach(var tactItem in sPlayer.GetTacticianSheet().TacticianInventoryData){
                                //if item is same and has room stack it! else pass as a new item
                                if(tactItem.Value.Item_Name == item.Item_Name && tactItem.Value.GetAvailableSpaceForStackable() >= 1 && !Unstacking){
                                    int stackingItemAmount = tactItem.Value.amount;
                                    message.ownerItemOne = "Tactician";
                                    message.itemOneAmount = tactItem.Value.amount;
                                    message.itemOne = tactItem.Value;
                                    message.itemOne.Changed = true;
                                    //print($"Select was {select} and we have an item we are trying to stack {tactItem.Value.Item_Name} with amount {tactItem.Value.amount}");
                                    ServerRemoveItemOnUser(nconn, InstanceID);
                                    StackingItemDropped(nconn, message);
                                    return;
                                }
                            }
                            sPlayer.ServerTacticianItemResult(newItem);
                        } else {
                            sPlayer.ServerTacticianItemResult(newItem);
                        }
                    } else {
                        //print($"Select was {select}");
                        foreach(var sheet in sPlayer.GetInformationSheets()){
                            if(sheet.CharacterID == item.OwnerID){
                                foreach(var invItem in sheet.CharInventoryData){
                                    if(item.IsStackable() && item.CanAdd()){
                                        if(invItem.Value.Item_Name == item.Item_Name && invItem.Value.GetAvailableSpaceForStackable() >= 1 && !Unstacking){
                                            int stackingItemAmount = invItem.Value.amount;
                                            message.ownerItemOne = sheet.CharacterID;
                                            message.itemOneAmount = invItem.Value.amount;
                                            message.itemOne = invItem.Value;
                                            message.itemOne.Changed = true;
                                            //print($"Select was {select} and we have an item we are trying to stack {invItem.Value.Item_Name} with amount {invItem.Value.amount}");
                                            ServerRemoveItemOnUser(nconn, InstanceID);
                                            StackingItemDropped(nconn, message);
                                            return;
                                        }
                                    }
                                }
                                PlayFabServerAPI.MoveItemToCharacterFromUser( new MoveItemToCharacterFromUserRequest
                                {
                                    CharacterId = select,
                                    ItemInstanceId = item.GetInstanceID(),
                                    PlayFabId = playerData.PlayFabId,
                                }, result =>
                                {
                                    sPlayer.GetCharacterPickedUpItem(select, newItem);
                                }, error =>{
                                    Debug.Log(error.ErrorMessage);
                                });
                            }
                        }
                    }
                }
            }, error =>{
                Debug.Log(error.ErrorMessage);
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
            #endif
        }
        */
        void ServerRemoveItemOnUserResetting(NetworkConnectionToClient nconn, string item){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            if(item == "NewItemGenerated"){
                return;
            }

             PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
        print($"{playerData.PlayFabId} REQUESTED ServerRemoveItemOnUser IDs are item one {item}");
            PlayFabServerAPI.RevokeInventoryItem(new RevokeInventoryItemRequest {
                PlayFabId = playerData.PlayFabId,
                ItemInstanceId = item
            }, result => {
                Debug.Log("Item successfully revoked");
            }, error => {
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void ServerRemoveItemOnUser(NetworkConnectionToClient nconn, ItemSelectable item){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            if(item.GetInstanceID() == "NewItemGenerated"){
                return;
            }

             PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
        print($"{playerData.PlayFabId} REQUESTED ServerRemoveItemOnUser IDs are item one {item.GetInstanceID()}");
            PlayFabServerAPI.RevokeInventoryItem(new RevokeInventoryItemRequest {
                PlayFabId = playerData.PlayFabId,
                ItemInstanceId = item.GetInstanceID()
            }, result => {
                Debug.Log("Item successfully revoked");
            }, error => {
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void ServerRemoveItemOnUserFromCharacter(NetworkConnectionToClient nconn, ItemSelectable item){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
        print($"{playerData.PlayFabId} REQUESTED ServerRemoveItemOnUserFromCharacter IDs are item one {item.GetInstanceID()} on char {item.GetOwnerID()}");
            PlayFabServerAPI.MoveItemToUserFromCharacter( new MoveItemToUserFromCharacterRequest
            {
                CharacterId = item.GetOwnerID(),
                ItemInstanceId = item.GetInstanceID(),
                PlayFabId = playerData.PlayFabId,
            }, result =>
            {
                PlayFabServerAPI.RevokeInventoryItem(new RevokeInventoryItemRequest {
                    PlayFabId = playerData.PlayFabId,
                    ItemInstanceId = item.GetInstanceID()
                }, result => {
                    Debug.Log("Item successfully revoked");
                }, error => {
                    Debug.Log(error.ErrorMessage);
                });
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void ServerAddItemLogout(NetworkConnectionToClient nconn, ItemSelectable item, string charID){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }

            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED ServerAddItemLogout IDs are item one {item.GetItemName()}");
            string ID = string.Empty;
            List<string> itemIDCreation = new List<string>();
            itemIDCreation.Add(item.GetItemID());
            print($"ServerAddItemLogout starting grant for item id {item.GetItemID()}");
            PlayFabServerAPI.GrantItemsToUser(new GrantItemsToUserRequest
            {
                PlayFabId = playerData.PlayFabId,
                ItemIds = itemIDCreation
            }, result =>
            {
                Dictionary<string, string> dataInput = new Dictionary<string, string>();
                if(item.GetTacticianStash()){
                    dataInput.Add("TactStash", "Stashed");
                }
                if(item.GetTacticianInventory()){
                    dataInput.Add("TactInventory", "InventoryItem");
                }
                if(item.GetTacticianBelt()){
                    dataInput.Add("TactBelt", "Belted");
                }
                if(item.GetNFT()){
                    dataInput.Add("NFTID", item.GetNFTID());
                } else {
                    dataInput.Add("Quality_item", item.GetQuality());
                    dataInput.Add("Durability_item", item.GetDurability());
                    dataInput.Add("Engraving", item.GetEngraving());
                }
                if(item.GetEQUIPPED()){
                    dataInput.Add("EquippedSlot", item.GetEQUIPPEDSLOT());
                }
                if(item.GetTacticianEquip()){
                    dataInput.Add("EquippedSlot", item.GetEQUIPPEDSLOT());
                }
                dataInput.Add("Amount", item.GetAmount().ToString());
            print($"ServerAddItemLogout updating granted for item id {item.GetItemID()}");
                foreach(var data in dataInput){
            print($"{data.Key} key and {data.Value} value for granted item id {item.GetItemID()}");
                    
                }
                foreach(var itemBuilt in result.ItemGrantResults){
                    //print($"{choice} is choice {Quality} is quality");
                    print($"ServerAddItemLogout starting UpdateUserInventoryItemCustomData for item INSTANCE id {itemBuilt.ItemInstanceId}");

                    PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest {
                    ItemInstanceId = itemBuilt.ItemInstanceId,
                    PlayFabId = playerData.PlayFabId,
                    Data = dataInput
                    }, result => {
                        if(!item.GetTacticianBelt() && !item.GetTacticianInventory() && !item.GetTacticianEquip() && !item.GetTacticianStash()){
                            PlayFabServerAPI.MoveItemToCharacterFromUser( new MoveItemToCharacterFromUserRequest
                            {
                                CharacterId = charID,
                                ItemInstanceId = itemBuilt.ItemInstanceId,
                                PlayFabId = playerData.PlayFabId,
                            }, result =>
                            {
                                print($"Sent item {item.GetItemName()} on Server add item logout to {charID} character ");
                            }, error =>{
                                Debug.Log(error.ErrorMessage);
                            });
                        }
                    }, error =>{
                        Debug.Log(error.ErrorMessage);
                    });
                }
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        //Transferring items between tactician and characters
        void StackingItemDropped(NetworkConnectionToClient nconn, StackingMessage message){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED StackingItemDropped IDs are item one {message.itemOne.GetItemName()} with a quantity of {message.itemOne.GetAmount()}, item two {message.itemTwo.GetItemName()} with a quantity of {message.itemOne.GetAmount()}");
            if(message.ownerItemOne == TACTICIAN || message.ownerItemOne == "Stash"){
                // if filled we are good to go and just send to tactician and kill other item otherwise we keep going
                TacticianFullDataMessage tactSheet = message.owner.GetTacticianSheet();
                CharacterInventoryListItem ItemOneTact = (new CharacterInventoryListItem{
                    Key = message.itemOne.GetInstanceID(),
                    Value = message.itemOne
                });
                ItemOneTact.Value.amount = message.itemOneAmount + message.itemTwoAmount;
                ItemOneTact.Value.Changed = true;
                if(ItemOneTact.Value.TacticianStash){
                    message.owner.GetStashNewItem(ItemOneTact);
                } else {
                    message.owner.GetTacticianNewItem(ItemOneTact);
                }
                message.owner.TargetSendInventoryItemSelectable(ItemOneTact);
            // we need to take all the info from the message, either change quantities on both or delete the second item. Then we need to send them back to their appropriate owner
           
            } else {
                CharacterInventoryListItem ItemOneTact = (new CharacterInventoryListItem{
                    Key = message.itemOne.GetInstanceID(),
                    Value = message.itemOne
                });
                ItemOneTact.Value.amount = message.itemOneAmount + message.itemTwoAmount;
                ItemOneTact.Value.Changed = true;
                //message.owner.RemoveCharacterItem(message.ownerItemOne, ItemOneTact.Key);
                message.owner.GetCharacterNewItem(message.ownerItemOne, ItemOneTact);
                message.owner.TargetSendInventoryItemSelectable(ItemOneTact);
                //deliver to tactician then change the amount
                //PlayFabServerAPI.MoveItemToUserFromCharacter( new MoveItemToUserFromCharacterRequest
                //{
                //    CharacterId = message.ownerItemOne,
                //    ItemInstanceId = ItemOneTact.Key,
                //    PlayFabId = playerData.PlayFabId,
                //}, result =>
                //{
                //   PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
                //    {
                //        ItemInstanceId = ItemOneTact.Key,
                //        PlayFabId = playerData.PlayFabId,
                //        Data = new Dictionary<string, string>
                //            {
                //                {"Amount", ItemOneTact.Value.amount.ToString()}
                //            }
                //    }, result =>
                //    {
                //        PlayFabServerAPI.MoveItemToCharacterFromUser( new MoveItemToCharacterFromUserRequest
                //        {
                //            CharacterId = message.ownerItemOne,
                //            ItemInstanceId = ItemOneTact.Key,
                //            PlayFabId = playerData.PlayFabId,
                //        }, result =>
                //        {
                //        }, error =>{
                //            Debug.Log(error.ErrorMessage);
                //        });
                //    }, error =>{
                //        Debug.Log(error.ErrorMessage);
                //    });
                //}, error =>{
                //    Debug.Log(error.ErrorMessage);
                //});                
            }
           //CharacterInventoryListItem ItemUpdate = (new CharacterInventoryListItem{
           //         Key = message.itemOne.GetInstanceID(),
           //         Value = message.itemOne
           // });
           // ItemUpdate.Value.amount = message.itemOneAmount + message.itemTwoAmount;
           // message.owner.TargetSendInventoryItemSelectable(ItemUpdate); //we are amost there just gotta update the item and send it back
            #endif
        }
        void RefundSalvage(NetworkConnectionToClient conn, SalvageNetworkList refundItems){
            if(!CheckNullConnection(conn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)conn.authenticationData;
            ScenePlayer sPlayer = conn.identity.gameObject.GetComponent<ScenePlayer>();
            print($"{playerData.PlayFabId} REQUESTED RefundSalvage");
            print("Refunding salvage start");
            Dictionary<string, int> refundList = new Dictionary<string, int>();
            for(int Q = 0; Q < refundItems.Entries.Count; Q++){
                refundList.Add(refundItems.Entries[Q].Key, refundItems.Entries[Q].Value);
            }
            //foreach(var snlistItem in refundItems.Entries){
            //    refundList.Add(snlistItem.Key, snlistItem.Value);
            //}
            //for(int j = 0; j < refundList.Count; j++){
            for(int W = 0; W < refundItems.RemovingTheseItems.Count; W++){
                RemoveThisItem(conn, refundItems.RemovingTheseItems[W], "Tactician");
            }
            StartCoroutine(RefundDelay(conn, refundList, playerData));
            /*
            foreach(var buildItem in refundList){
                print($"Salvage build {buildItem.Key} for {playerData.PlayFabId}");
                (string _itemID, int exp, int energy, int reqSkill, int craftTime, int craftMode, int maxStack) = CraftingRef.Instance.GetCraftingCosts(buildItem.Key);
                if(maxStack == 1){
                    for(int i = 0; i < buildItem.Value; i++){
                        BuildSalvageItem(conn, _itemID, 1); // Call with a value of 1 each time
                    }
                } else {
                    BuildSalvageItem(conn, _itemID, buildItem.Value);
                }
            }
            */
        }
        IEnumerator RefundDelay(NetworkConnectionToClient conn, Dictionary<string, int> refundList, PlayerInfo playerData){
            yield return new WaitForSeconds(.25f);
            foreach(var buildItem in refundList){
                print($"Salvage build {buildItem.Key} for {playerData.PlayFabId}");
                (string _itemID, int exp, int energy, int reqSkill, int craftTime, int craftMode, int maxStack) = CraftingRef.Instance.GetCraftingCosts(buildItem.Key);
                if(maxStack == 1){
                    for(int i = 0; i < buildItem.Value; i++){
                        BuildSalvageItem(conn, _itemID, 1); // Call with a value of 1 each time
                    }
                } else {
                    BuildSalvageItem(conn, _itemID, buildItem.Value);
                }
            }
        }
        
        void ConsumeItemFully(NetworkConnectionToClient conn, ItemSelectable itemConsumingFully, string serial){
            if(!CheckNullConnection(conn)){
                return;
            }
            //CharacterBuffListItem newBuff = new CharacterBuffListItem {
            //        Key = "there is no spoon"
            //    };
            ScenePlayer sPlayer = conn.identity.gameObject.GetComponent<ScenePlayer>();
            bool charInMatch = false;
            if(serial != "Tactician" && serial != "Stash"){
                if(sPlayer.inMatch){
                    if(sPlayer.currentMatch != null){
                        foreach(var playerSlot in sPlayer.currentMatch.playerSlotPairs){
                            if(playerSlot.slot == serial){
                                charInMatch = true;
                                break;
                            }
                        }
                    }
                }
            }
            PlayerInfo playerData = (PlayerInfo)conn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED ConsumeItemFully IDs are item one {itemConsumingFully.GetItemName()}");
            print($"Starting Remove item");
            ConsumableEffects.Consumable consumableType = ConsumableEffects.Consumable.HealingPotion;
            ConsumableEffects.ConsumableEffect effect = consumableEffects.GetConsumableEffect(consumableType);
            if(itemConsumingFully.GetItemName() == "Arudine Pie"){
                consumableType = ConsumableEffects.Consumable.ArudinePie;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Snake Pie"){
                consumableType = ConsumableEffects.Consumable.SnakePie;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Rat Skewer"){
                consumableType = ConsumableEffects.Consumable.RatSkewer;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Sauerkraut"){
                consumableType = ConsumableEffects.Consumable.Sauerkraut;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Lobster Jerky"){
                consumableType = ConsumableEffects.Consumable.LobsterJerky;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Shishkabob"){
                consumableType = ConsumableEffects.Consumable.Shishkabob;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Sticky Rat Skewer"){
                consumableType = ConsumableEffects.Consumable.StickyRatSkewer;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Healing Potion"){
                consumableType = ConsumableEffects.Consumable.HealingPotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Arudine Pie"){
                consumableType = ConsumableEffects.Consumable.MagicPotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Haste Potion"){
                consumableType = ConsumableEffects.Consumable.HastePotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Greater Haste Potion"){
                consumableType = ConsumableEffects.Consumable.GreaterHastePotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Antidote"){
                consumableType = ConsumableEffects.Consumable.Antidote;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Defense Potion"){
                consumableType = ConsumableEffects.Consumable.DefensePotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Greater Defense Potion"){
                consumableType = ConsumableEffects.Consumable.GreaterDefensePotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Energy Potion"){
                consumableType = ConsumableEffects.Consumable.EnergyPotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
                sPlayer.Energy += effect.energyRestore;
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
            }
            if(itemConsumingFully.GetItemName() == "Lifesteal Potion"){
                consumableType = ConsumableEffects.Consumable.LifestealPotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Rejuvenation Potion"){
                consumableType = ConsumableEffects.Consumable.RejuvenationPotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            string buffName = effect.ConsumableName;
            int Buffhp = effect.hpHeal;
            int Buffmp = effect.mpHeal;
            int Buffarcana = effect.arcanaBuff;
            int Buffagility = effect.agilityBuff;
            int Buffstrength = effect.strengthBuff;
            int Bufffortitude = effect.fortitudeBuff;
            int BuffpoisonResist = effect.poisonResistBuff;
            int BuffdiseaseResist = effect.diseaseResistBuff;
            int Bufflifesteal = effect.lifesteal;
            int Buffarmor = effect.armorBuff;
            int Buffenergy = effect.energyRestore;
            if(consumableType == ConsumableEffects.Consumable.HealingPotion){
                Buffhp = UnityEngine.Random.Range(35, 56); //
            }
            if(consumableType == ConsumableEffects.Consumable.MagicPotion){
                Buffmp = UnityEngine.Random.Range(5, 8); //
            }
            int minuteAddtion = 30;
            if(consumableType == ConsumableEffects.Consumable.LifestealPotion){
                minuteAddtion = 5;
            }
            // Get the current UTC time
            DateTime currentTimeUtc = DateTime.UtcNow;
            // Add 30 minutes to the current time
            DateTime expirationTimeUtc = currentTimeUtc.AddMinutes(minuteAddtion);
            // Convert the expiration time to the desired string format
            string expirationTimeString = expirationTimeUtc.ToString("o");
            //Build the buffs and insert into the full char data structure list for buffs
            (bool potionCheck, bool foodCheck) = PotionFoodCheck(buffName);
            minuteAddtion *= 60;

            CharacterBuffListItem newBuff = new CharacterBuffListItem {
                Key = buffName,
                //Value = buffValueString,
                //Time = expirationTimeString
                Duration = minuteAddtion.ToString(),
                FoodBuff = foodCheck,
                PotionBuff = potionCheck,
                Rank = 1
            };
            if(consumableType == ConsumableEffects.Consumable.HealingPotion){
                newBuff.Value = Buffhp.ToString();
            }
            if(consumableType == ConsumableEffects.Consumable.MagicPotion){
                newBuff.Value = Buffmp.ToString();
            }
            //newBuff.FoodBuff = foodCheck;
            //newBuff.PotionBuff = potionCheck;
            if(consumableType != ConsumableEffects.Consumable.EnergyPotion && consumableType != ConsumableEffects.Consumable.RejuvenationPotion && consumableType != ConsumableEffects.Consumable.Antidote
            && consumableType != ConsumableEffects.Consumable.HealingPotion && consumableType != ConsumableEffects.Consumable.MagicPotion){
                List<string> buffParts = new List<string>();
                // Add each buff to the list only if it's greater than 0
                if (Buffarcana > 0) buffParts.Add(Buffarcana + " Arcana");
                if (Buffagility > 0) buffParts.Add(Buffagility + " Agility");
                if (Buffstrength > 0) buffParts.Add(Buffstrength + " Strength");
                if (Bufffortitude > 0) buffParts.Add(Bufffortitude + " Fortitude");
                if (BuffpoisonResist > 0) buffParts.Add(BuffpoisonResist + " Poison Resistance");
                if (BuffdiseaseResist > 0) buffParts.Add(BuffdiseaseResist + " Disease Resistance");
                if (Bufflifesteal > 0) buffParts.Add(Bufflifesteal + " Lifesteal");
                if (Buffarmor > 0) buffParts.Add(Buffarmor + " Armor");
                // Join the parts into a single string
                string buffValueString = string.Join(" | ", buffParts);
                //newBuff.Key = buffName;
                newBuff.Value = buffValueString;
                newBuff.Time = expirationTimeString;
                if(!string.IsNullOrEmpty(buffValueString)){
                    print($"{newBuff.PotionBuff} {newBuff.FoodBuff} are the potionbuff and foodbuff bools for  " + buffName);
                    sPlayer.ServerAddBuff(serial, newBuff);
                }
            }
            /*
            if(Buffhp > 0 || Buffmp > 0){
                TacticianFullDataMessage tacticianSheet = sPlayer.GetTacticianSheet();
                int tacticianBonusFortitude = int.Parse(tacticianSheet.FortitudeBonus);
                int tacticianBonusArcana = int.Parse(tacticianSheet.ArcanaBonus);
                CharacterStatListItem Health = (new CharacterStatListItem{
                    Key = "currentHP",
                    Value = "1"
                });
                CharacterStatListItem Mana = (new CharacterStatListItem{
                    Key = "currentMP",
                    Value = "1"
                });
                foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                    if(tacticianEquipped.Value.Deleted){
                        continue;
                    }
                    if (tacticianEquipped.Value.GetTacticianEquip())
                    {
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                        {
                            tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                        }
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                        {
                            tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                        }
                    }
                }
                foreach(var sheet in sPlayer.GetInformationSheets()){
                    string _class = string.Empty;
                    int _level = 1;
                    string _core = string.Empty;
                    int curHP = 1;
                    int curMP = 1;
                    int equippedFort = 0;
                    int equippedArcana = 0;
                    if(sheet.CharacterID == serial){
                        foreach(var invItem in sheet.CharInventoryData){
                            if(invItem.Value.Deleted || invItem.Value.amount == 0){
                                continue;
                            }
                            if(invItem.Value.EQUIPPED){
                                int tempValue;
                                if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
                                {
                                    equippedFort += tempValue;
                                }
                                if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
                                {
                                    equippedArcana += tempValue;
                                }
                            }
                        }
                        foreach(var stat in sheet.CharStatData){
                            if(stat.Key == "currentHP"){
                                curHP = int.Parse(stat.Value);
                            }
                            if(stat.Key == "currentMP"){
                                curMP = int.Parse(stat.Value);
                            }
                            if (stat.Key == "Class") {
                                _class = stat.Value;
                            }
                            if (stat.Key == "LVL") {
                                _level = int.Parse(stat.Value);
                            }
                            if (stat.Key == "CORE") {
                                _core = stat.Value;
                            }
                        }
                        int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < sPlayer.GetInformationSheets().Count; _char++){
                            if(sPlayer.GetInformationSheets()[_char].CharacterID == serial){
                                for(int ability = 0; ability < sPlayer.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + Bufffortitude + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + Buffarcana + PASSIVE_Arcana) / 7;
                        curHP += Buffhp.ToString();
                        curMP += Buffmp;
                        if(curHP > maxHP ){
                            curHP = maxHP;
                        }
                        if(curMP > maxMP){
                            curMP = maxMP;
                        }
                        List<CharacterStatListItem> CharList = new List<CharacterStatListItem>();
                        Health.Value = curHP.ToString();
                        Mana.Value = curMP.ToString();
                    }
                }
                sPlayer.GetCharacterUpdateHPMP(serial, Health, Mana);
            }
            */
            if(charInMatch){
                ConsumedItemInMatch.Invoke(serial, sPlayer, sPlayer.currentMatch, newBuff);
            }
            //if(consumableType != ConsumableEffects.Consumable.EnergyPotion && consumableType != ConsumableEffects.Consumable.EnergyPotion && consumableType != ConsumableEffects.Consumable.EnergyPotion){
            //    
            //}
            itemConsumingFully.amount = 0;
            itemConsumingFully.Deleted = true;
            itemConsumingFully.Changed = true;
            CharacterInventoryListItem DeletingItem = (new CharacterInventoryListItem{
                Key = itemConsumingFully.GetInstanceID(),
                Value = itemConsumingFully
            });
            print($"{DeletingItem.Value.amount} is our amount for the item and changed is {DeletingItem.Value.Changed} and Deleted is {DeletingItem.Value.Deleted}");
            if(serial == "Tactician"){
                print($"Starting Tact delete call");
                sPlayer.GetTacticianDeletingItem(DeletingItem);
                return;
            }
            if(serial == "Stash"){
                sPlayer.GetStashDeletingItem(DeletingItem);
                return;
            }
            if(serial != "Stash" && serial != "Tactician"){
                foreach(var sheet in sPlayer.GetInformationSheets()){
                    if(sheet.CharacterID == serial){
                        sPlayer.GetCharacterDeletingItem(serial, DeletingItem);
                        return;
                    }
                }
            }
        }
        void ConsumeItemPartially(NetworkConnectionToClient conn, ItemSelectable itemConsumingFully, string serial){
            if(!CheckNullConnection(conn)){
                return;
            }
            ScenePlayer sPlayer = conn.identity.gameObject.GetComponent<ScenePlayer>();
            bool charInMatch = false;
            if(serial != "Tactician" && serial != "Stash"){
                if(sPlayer.inMatch){
                    if(sPlayer.currentMatch != null){
                        foreach(var playerSlot in sPlayer.currentMatch.playerSlotPairs){
                            if(playerSlot.slot == serial){
                                charInMatch = true;
                                break;
                            }
                        }
                    }
                }
            }
            PlayerInfo playerData = (PlayerInfo)conn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED ConsumeItemPartially IDs are item one {itemConsumingFully.GetItemName()}");
            print($"Starting Remove item");
            ConsumableEffects.Consumable consumableType = ConsumableEffects.Consumable.HealingPotion;
            ConsumableEffects.ConsumableEffect effect = consumableEffects.GetConsumableEffect(consumableType);
            if(itemConsumingFully.GetItemName() == "Arudine Pie"){
                consumableType = ConsumableEffects.Consumable.ArudinePie;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Snake Pie"){
                consumableType = ConsumableEffects.Consumable.SnakePie;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Rat Skewer"){
                consumableType = ConsumableEffects.Consumable.RatSkewer;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Sauerkraut"){
                consumableType = ConsumableEffects.Consumable.Sauerkraut;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Lobster Jerky"){
                consumableType = ConsumableEffects.Consumable.LobsterJerky;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Shishkabob"){
                consumableType = ConsumableEffects.Consumable.Shishkabob;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Sticky Rat Skewer"){
                consumableType = ConsumableEffects.Consumable.StickyRatSkewer;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Healing Potion"){
                consumableType = ConsumableEffects.Consumable.HealingPotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Arudine Pie"){
                consumableType = ConsumableEffects.Consumable.MagicPotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Haste Potion"){
                consumableType = ConsumableEffects.Consumable.HastePotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Greater Haste Potion"){
                consumableType = ConsumableEffects.Consumable.GreaterHastePotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Antidote"){
                consumableType = ConsumableEffects.Consumable.Antidote;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Defense Potion"){
                consumableType = ConsumableEffects.Consumable.DefensePotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Greater Defense Potion"){
                consumableType = ConsumableEffects.Consumable.GreaterDefensePotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Energy Potion"){
                consumableType = ConsumableEffects.Consumable.EnergyPotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
                sPlayer.Energy += effect.energyRestore;
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
            }
            if(itemConsumingFully.GetItemName() == "Lifesteal Potion"){
                consumableType = ConsumableEffects.Consumable.LifestealPotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            if(itemConsumingFully.GetItemName() == "Rejuvenation Potion"){
                consumableType = ConsumableEffects.Consumable.RejuvenationPotion;
                effect = consumableEffects.GetConsumableEffect(consumableType);
            }
            string buffName = effect.ConsumableName;
            int Buffhp = effect.hpHeal;
            int Buffmp = effect.mpHeal;
            int Buffarcana = effect.arcanaBuff;
            int Buffagility = effect.agilityBuff;
            int Buffstrength = effect.strengthBuff;
            int Bufffortitude = effect.fortitudeBuff;
            int BuffpoisonResist = effect.poisonResistBuff;
            int BuffdiseaseResist = effect.diseaseResistBuff;
            int Bufflifesteal = effect.lifesteal;
            int Buffarmor = effect.armorBuff;
            int Buffenergy = effect.energyRestore;
            
            int minuteAddtion = 30;
            if(consumableType == ConsumableEffects.Consumable.LifestealPotion){
                minuteAddtion = 5;
            }
            // Get the current UTC time
            DateTime currentTimeUtc = DateTime.UtcNow;
            // Add 30 minutes to the current time
            DateTime expirationTimeUtc = currentTimeUtc.AddMinutes(minuteAddtion);
            // Convert the expiration time to the desired string format
            string expirationTimeString = expirationTimeUtc.ToString("o");
            //Build the buffs and insert into the full char data structure list for buffs
            (bool potionCheck, bool foodCheck) = PotionFoodCheck(buffName);
            minuteAddtion *= 60;
            if(consumableType == ConsumableEffects.Consumable.HealingPotion){
                Buffhp = UnityEngine.Random.Range(35, 56); //
            }
            if(consumableType == ConsumableEffects.Consumable.MagicPotion){
                Buffmp = UnityEngine.Random.Range(5, 8); //
            }
            CharacterBuffListItem newBuff = new CharacterBuffListItem {
                Key = buffName,
                FoodBuff = foodCheck,
                PotionBuff = potionCheck,
                Duration = minuteAddtion.ToString(),
                Rank = 1
                //Value = buffValueString,
                //Time = expirationTimeString
            };
            if(consumableType == ConsumableEffects.Consumable.HealingPotion){
                newBuff.Value = Buffhp.ToString();
            }
            if(consumableType == ConsumableEffects.Consumable.MagicPotion){
                newBuff.Value = Buffmp.ToString();
            }
            if(consumableType != ConsumableEffects.Consumable.EnergyPotion && consumableType != ConsumableEffects.Consumable.RejuvenationPotion && consumableType != ConsumableEffects.Consumable.Antidote
            && consumableType != ConsumableEffects.Consumable.HealingPotion && consumableType != ConsumableEffects.Consumable.MagicPotion){
                List<string> buffParts = new List<string>();
                // Add each buff to the list only if it's greater than 0
                if (Buffarcana > 0) buffParts.Add(Buffarcana + " Arcana");
                if (Buffagility > 0) buffParts.Add(Buffagility + " Agility");
                if (Buffstrength > 0) buffParts.Add(Buffstrength + " Strength");
                if (Bufffortitude > 0) buffParts.Add(Bufffortitude + " Fortitude");
                if (BuffpoisonResist > 0) buffParts.Add(BuffpoisonResist + " Poison Resistance");
                if (BuffdiseaseResist > 0) buffParts.Add(BuffdiseaseResist + " Disease Resistance");
                if (Bufflifesteal > 0) buffParts.Add(Bufflifesteal + " Lifesteal");
                if (Buffarmor > 0) buffParts.Add(Buffarmor + " Armor");
                // Join the parts into a single string
                string buffValueString = string.Join(" | ", buffParts);
                //newBuff.Key = buffName;
                newBuff.Value = buffValueString;
                newBuff.Time = expirationTimeString;
                if(!string.IsNullOrEmpty(buffValueString)){
                    sPlayer.ServerAddBuff(serial, newBuff);
                }
            }
            /*
            if(Buffhp > 0 || Buffmp > 0){
                TacticianFullDataMessage tacticianSheet = sPlayer.GetTacticianSheet();
                int tacticianBonusFortitude = int.Parse(tacticianSheet.FortitudeBonus);
                int tacticianBonusArcana = int.Parse(tacticianSheet.ArcanaBonus);
                CharacterStatListItem Health = (new CharacterStatListItem{
                    Key = "currentHP",
                    Value = "1"
                });
                CharacterStatListItem Mana = (new CharacterStatListItem{
                    Key = "currentMP",
                    Value = "1"
                });
                foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                    if(tacticianEquipped.Value.Deleted){
                        continue;
                    }
                    if (tacticianEquipped.Value.GetTacticianEquip())
                    {
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                        {
                            tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                        }
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                        {
                            tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                        }
                    }
                }
                foreach(var sheet in sPlayer.GetInformationSheets()){
                    string _class = string.Empty;
                    int _level = 1;
                    string _core = string.Empty;
                    int curHP = 1;
                    int curMP = 1;
                    int equippedFort = 0;
                    int equippedArcana = 0;
                    if(sheet.CharacterID == serial){
                        foreach(var invItem in sheet.CharInventoryData){
                            if(invItem.Value.Deleted || invItem.Value.amount == 0){
                                continue;
                            }
                            if(invItem.Value.EQUIPPED){
                                int tempValue;
                                if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
                                {
                                    equippedFort += tempValue;
                                }
                                if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
                                {
                                    equippedArcana += tempValue;
                                }
                            }
                        }
                        foreach(var stat in sheet.CharStatData){
                            if(stat.Key == "currentHP"){
                                curHP = int.Parse(stat.Value);
                            }
                            if(stat.Key == "currentMP"){
                                curMP = int.Parse(stat.Value);
                            }
                            if (stat.Key == "Class") {
                                _class = stat.Value;
                            }
                            if (stat.Key == "LVL") {
                                _level = int.Parse(stat.Value);
                            }
                            if (stat.Key == "CORE") {
                                _core = stat.Value;
                            }
                        }
                        int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < sPlayer.GetInformationSheets().Count; _char++){
                            if(sPlayer.GetInformationSheets()[_char].CharacterID == serial){
                                for(int ability = 0; ability < sPlayer.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + Bufffortitude  + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + Buffarcana + PASSIVE_Arcana) / 7;
                        curHP += Buffhp;
                        curMP += Buffmp;
                        if(curHP > maxHP ){
                            curHP = maxHP;
                        }
                        if(curMP > maxMP){
                            curMP = maxMP;
                        }
                        List<CharacterStatListItem> CharList = new List<CharacterStatListItem>();
                        Health.Value = curHP.ToString();
                        Mana.Value = curMP.ToString();
                    }
                }
                sPlayer.GetCharacterUpdateHPMP(serial, Health, Mana);
            }
            */
            if(charInMatch){
                ConsumedItemInMatch.Invoke(serial, sPlayer, sPlayer.currentMatch, newBuff);
            }
            
            CharacterInventoryListItem ModifiedItem = (new CharacterInventoryListItem{
                Key = itemConsumingFully.GetInstanceID(),
                Value = itemConsumingFully
            });
            ModifiedItem.Value.amount -= 1;
            ModifiedItem.Value.Changed = true;
            print($"{ModifiedItem.Value.amount} is our amount for the item and changed is {ModifiedItem.Value.Changed} and Deleted is {ModifiedItem.Value.Deleted} serial is {serial}");
            if(serial == "Tactician"){
                print($"Starting Tact delete call");
                sPlayer.GetTacticianNewItem(ModifiedItem);
                return;
            }
            if(serial == "Stash"){
                sPlayer.GetStashNewItem(ModifiedItem);
                return;
            }
            if(serial != "Stash" && serial != "Tactician"){
                foreach(var sheet in sPlayer.GetInformationSheets()){
                    if(sheet.CharacterID == serial){
                        sPlayer.GetCharacterNewItem(serial, ModifiedItem);
                        return;
                    }
                }
            }
        }
        void RemoveThisItem(NetworkConnectionToClient conn, ItemSelectable itemDeleting, string serial){
            if(!CheckNullConnection(conn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)conn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED RemoveThisItem IDs are item one {itemDeleting.GetItemName()}");
            print($"Starting Remove item");
            itemDeleting.amount = 0;
            itemDeleting.Deleted = true;
            itemDeleting.Changed = true;
            CharacterInventoryListItem DeletingItem = (new CharacterInventoryListItem{
                Key = itemDeleting.GetInstanceID(),
                Value = itemDeleting
            });
            print($"{DeletingItem.Value.amount} is our amount for the item and changed is {DeletingItem.Value.Changed} and Deleted is {DeletingItem.Value.Deleted}");
            
            ScenePlayer sPlayer = conn.identity.gameObject.GetComponent<ScenePlayer>();
            if(serial == "Tactician"){
            print($"Starting Tact delete call");
                sPlayer.GetTacticianDeletingItem(DeletingItem);
                return;
            }
            if(serial == "Stash"){
                sPlayer.GetStashDeletingItem(DeletingItem);
                return;
            }
            if(serial != "Stash" && serial != "Tactician"){
                foreach(var sheet in sPlayer.GetInformationSheets()){
                    if(sheet.CharacterID == serial){
                        sPlayer.GetCharacterDeletingItem(serial, DeletingItem);
                        return;
                    }
                }
            }
        }
        void StackingItem(NetworkConnectionToClient nconn, StackingMessage message){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED StackingItem IDs are item one {message.itemOne.GetItemName()} with a quantity of {message.itemOne.GetAmount()}, item two {message.itemTwo.GetItemName()} with a quantity of {message.itemOne.GetAmount()}");
            // we need to take all the info from the message, either change quantities on both or delete the second item. Then we need to send them back to their appropriate owner
            if(message.ownerItemOne == TACTICIAN || message.ownerItemOne == "Stash"){
                // if filled we are good to go and just send to tactician and kill other item otherwise we keep going
                TacticianFullDataMessage tactSheet = message.owner.GetTacticianSheet();
                CharacterInventoryListItem ItemOneTact = (new CharacterInventoryListItem{
                    Key = message.itemOne.GetInstanceID(),
                    Value = message.itemOne
                });
                ItemOneTact.Value.amount = message.itemOneAmount;
                ItemOneTact.Value.Changed = true;
                if(ItemOneTact.Value.TacticianStash){
                    message.owner.GetStashNewItem(ItemOneTact);
                } else {
                    message.owner.GetTacticianNewItem(ItemOneTact);
                }
                message.owner.TargetSendInventoryItemSelectable(ItemOneTact);
                //PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest {
                //    ItemInstanceId = ItemOneTact.Key,
                //    PlayFabId = playerData.PlayFabId,
                //    Data = new Dictionary<string, string> {
                //        {"Amount", message.itemOneAmount.ToString()}
                //    }
                //}, result => {
                //    //print($"moved and doneskies with item one going on to item two now, new amount is {message.itemOneAmount}");
                //}, error =>{
                //    Debug.Log(error.ErrorMessage);
                //});
            } else {
                CharacterInventoryListItem ItemOneTact = (new CharacterInventoryListItem{
                    Key = message.itemOne.GetInstanceID(),
                    Value = message.itemOne
                });
                ItemOneTact.Value.amount = message.itemOneAmount;
                ItemOneTact.Value.Changed = true;
                message.owner.GetCharacterNewItem(message.ownerItemOne, ItemOneTact);
                message.owner.TargetSendInventoryItemSelectable(ItemOneTact);
                //deliver to tactician then change the amount
                //PlayFabServerAPI.MoveItemToUserFromCharacter( new MoveItemToUserFromCharacterRequest
                //{
                //    CharacterId = message.ownerItemOne,
                //    ItemInstanceId = ItemOneTact.Key,
                //    PlayFabId = playerData.PlayFabId,
                //}, result =>
                //{
                //   PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
                //    {
                //        ItemInstanceId = ItemOneTact.Key,
                //        PlayFabId = playerData.PlayFabId,
                //        Data = new Dictionary<string, string>
                //            {
                //                {"Amount", message.itemOneAmount.ToString()}
                //            }
                //    }, result =>
                //    {
                //        PlayFabServerAPI.MoveItemToCharacterFromUser( new MoveItemToCharacterFromUserRequest
                //        {
                //            CharacterId = message.ownerItemOne,
                //            ItemInstanceId = ItemOneTact.Key,
                //            PlayFabId = playerData.PlayFabId,
                //        }, result =>
                //        {
                //        }, error =>{
                //            Debug.Log(error.ErrorMessage);
                //        });
                //    }, error =>{
                //        Debug.Log(error.ErrorMessage);
                //    });
                //}, error =>{
                //    Debug.Log(error.ErrorMessage);
                //});                
            }
            if(message.ownerItemTwo == TACTICIAN || message.ownerItemTwo == "Stash"){
                    TacticianFullDataMessage tactSheet = message.owner.GetTacticianSheet();
                if(message.itemTwoAmount == 0){
                    CharacterInventoryListItem ItemTwoTactRemove = (new CharacterInventoryListItem{
                        Key = message.itemTwo.GetInstanceID(),
                        Value = message.itemTwo
                    });
                    ItemTwoTactRemove.Value.amount = 0;
                    ItemTwoTactRemove.Value.Changed = true;
                    ItemTwoTactRemove.Value.Deleted = true;
                    message.owner.TargetSendInventoryItemSelectable(ItemTwoTactRemove);
                    //PlayFabServerAPI.RevokeInventoryItem(new RevokeInventoryItemRequest {
                    //    PlayFabId = playerData.PlayFabId,
                    //    ItemInstanceId = message.itemTwo.GetInstanceID()
                    //}, result => {
                    //    Debug.Log("Item successfully revoked");
                    //}, error => {
                    //    Debug.Log(error.ErrorMessage);
                    //});
                    if(ItemTwoTactRemove.Value.TacticianStash){
                        message.owner.GetStashNewItem(ItemTwoTactRemove);
                    } else {
                        message.owner.GetTacticianNewItem(ItemTwoTactRemove);
                    }
                } else {
                    CharacterInventoryListItem ItemTwoTact = (new CharacterInventoryListItem{
                        Key = message.itemTwo.GetInstanceID(),
                        Value = message.itemTwo
                    });
                    ItemTwoTact.Value.amount = message.itemTwoAmount;
                    ItemTwoTact.Value.Changed = true;
                    if(ItemTwoTact.Value.TacticianStash){
                        message.owner.GetStashNewItem(ItemTwoTact);
                    } else {
                        message.owner.GetTacticianNewItem(ItemTwoTact);
                    }
                    message.owner.TargetSendInventoryItemSelectable(ItemTwoTact);
                    //PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest {
                    //    ItemInstanceId = ItemTwoTact.Key,
                    //    PlayFabId = playerData.PlayFabId,
                    //    Data = new Dictionary<string, string> {
                    //        {"Amount", message.itemTwoAmount.ToString()}
                    //    }
                    //}, result => {
                    //    //print("moved and doneskies with item one going on to item two now");
                    //}, error =>{
                    //    Debug.Log(error.ErrorMessage);
                    //});
                }
            } else {
                if(message.itemTwoAmount == 0){
                    CharacterInventoryListItem ItemRemove = (new CharacterInventoryListItem{
                        Key = message.itemTwo.GetInstanceID(),
                        Value = message.itemTwo
                    });
                    ItemRemove.Value.amount = message.itemTwoAmount;
                    ItemRemove.Value.Changed = true;
                    ItemRemove.Value.Deleted = true;
                    message.owner.GetCharacterNewItem(message.ownerItemTwo, ItemRemove);
                    message.owner.TargetSendInventoryItemSelectable(ItemRemove);
                    //PlayFabServerAPI.RevokeInventoryItem(new RevokeInventoryItemRequest {
                    //    PlayFabId = playerData.PlayFabId,
                    //    CharacterId = message.ownerItemTwo, // The ID of the character from which to revoke the item
                    //    ItemInstanceId = message.itemTwo.GetInstanceID()
                    //}, result => {
                    //    Debug.Log("Item successfully revoked from character");
                    //}, error => {
                    //    Debug.Log(error.ErrorMessage);
                    //});
                } else {
                    //change characters items amount and resend
                    CharacterInventoryListItem ItemTwoTact = (new CharacterInventoryListItem{
                        Key = message.itemTwo.GetInstanceID(),
                        Value = message.itemTwo
                    });
                    ItemTwoTact.Value.amount = message.itemTwoAmount;
                    ItemTwoTact.Value.Changed = true;
                    message.owner.GetCharacterNewItem(message.ownerItemTwo, ItemTwoTact);
                    message.owner.TargetSendInventoryItemSelectable(ItemTwoTact);
                    //deliver to tactician then change the amount
                    //PlayFabServerAPI.MoveItemToUserFromCharacter( new MoveItemToUserFromCharacterRequest
                    //{
                    //    CharacterId = message.ownerItemTwo,
                    //    ItemInstanceId = ItemTwoTact.Key,
                    //    PlayFabId = playerData.PlayFabId,
                    //}, result =>
                    //{
                    //   PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
                    //    {
                    //        ItemInstanceId = ItemTwoTact.Key,
                    //        PlayFabId = playerData.PlayFabId,
                    //        Data = new Dictionary<string, string>
                    //            {
                    //                {"Amount", message.itemOneAmount.ToString()}
                    //            }
                    //    }, result =>
                    //    {
                    //        PlayFabServerAPI.MoveItemToCharacterFromUser( new MoveItemToCharacterFromUserRequest
                    //        {
                    //            CharacterId = message.ownerItemTwo,
                    //            ItemInstanceId = ItemTwoTact.Key,
                    //            PlayFabId = playerData.PlayFabId,
                    //        }, result =>
                    //        {
                    //        }, error =>{
                    //            Debug.Log(error.ErrorMessage);
                    //        });
                    //    }, error =>{
                    //        Debug.Log(error.ErrorMessage);
                    //    });
                    //}, error =>{
                    //    Debug.Log(error.ErrorMessage);
                    //}); 
                }
            }
            #endif
        }
        void AuthenticateThenSavePFCharacters(NetworkConnectionToClient nconn, ItemSelectable item, string request, string characterID){
            #if UNITY_SERVER //|| UNITY_EDITOR
            //print($"{item.GetItemName()} is being transfered to slot {characterID}");
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED AuthenticateThenSavePFCharacters IDs are item one {item.GetItemName()}");
            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {
                if(request == "TactEquipCharInv"){
                    TactEquipCharInv(nconn, item, playerData, characterID);//changed
                    //ChangedInMatch
                }
                if(request == "TactInvCharInv"){
                    TactInvCharInv(nconn, item, playerData, characterID);//changed
                }
                if(request == "TactBeltCharInv"){
                    TactBeltCharInv(nconn, item, playerData, characterID);//changed
                }
                if(request == "StashToCharInv"){
                    StashToCharInv(nconn, item, playerData, characterID);//changed
                }
                if(request == "CharInvTactInv"){
                    CharInvTactInv(nconn, item, playerData, characterID);//changed
                }
                if(request == "CharInvTactBelt"){
                    CharInvTactBelt(nconn, item, playerData, characterID);//changed
                }
                if(request == "CharEquipTactInv"){
                    CharEquipTactInv(nconn, item, playerData, characterID);//changed
                    //ChangeInMatchAdded
                }
                if(request == "CharEquipTactBelt"){
                    CharEquipTactBelt(nconn, item, playerData, characterID);//changed
                    //ChangeInMatchAdded
                }
                if(request == "CharInvStash"){
                    CharInvStash(nconn, item, playerData, characterID);//changed
                }
                if(request == "CharEquipStash"){
                    CharEquipStash(nconn, item, playerData, characterID);//changed
                }
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void AuthenticateDropBox(NetworkConnectionToClient nconn, string itemOne, string itemTwo, EquippingData equippedData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED AuthenticateDropBox  IDs are item one {itemOne} and item two {itemTwo}");

            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {
                if(equippedData.Request == "CharacterUnequipToTactStash"){
                    CharUnequipCharEquipSendTactStash(nconn, itemOne, itemTwo, playerData, equippedData);//changed
                }
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void AuthenticateThenSavePFCharactersSwap(NetworkConnectionToClient nconn, ItemSelectable itemOne, ItemSelectable itemTwo, EquippingData equippedData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED AuthenticateThenSavePFCharactersSwap  IDs are item one {itemOne.GetItemName()} and item Two {itemTwo.GetItemName()}");

            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {
                if(equippedData.Request == "CharUnequipCharEquipSame"){
                    CharUnequipCharEquipSame(nconn, itemOne, itemTwo, playerData, equippedData);//changed
                    //changedInMatch
                }
                if(equippedData.Request == "CharacterOneUnequipToCharEquipSendTwo"){
                    CharUnequipCharEquipOneSendTwo(nconn, itemOne, itemTwo, playerData, equippedData);//changed
                    //changedInMatch
                }
                if(equippedData.Request == "CharacterTwoUnequipToCharEquipSendOne"){
                    CharUnequipCharEquipTwoSendOne(nconn, itemOne, itemTwo, playerData, equippedData);//changed
                    //changedInMatch
                }
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void AuthenticateThenSavePFCharactersEquip(NetworkConnectionToClient nconn, ItemSelectable item, string request, EquippingData equippedData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            //print($"{item.GetItemName()} is being transfered to slot {equippedData.Slot} {request} was the request, {equippedData.CharacterSlot} was slot ");
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {
                if(request == "TactBeltToCharEquip"){
                    TactBeltToCharEquip(nconn, item, playerData, equippedData);//changed
                    //changedInMatch
                }
                if(request == "TactInvToCharEquip"){
                    TactInvToCharEquip(nconn, item, playerData, equippedData);//changed
                    //changedINMatch
                }
                if(request == "StashToCharEquip"){
                    StashToCharEquip(nconn, item, playerData, equippedData);//changed
                }
                if(request == "CharInvTactEquip"){
                    CharInvTactEquip(nconn, item, playerData, equippedData);//changed
                    //changedInMatch
                }
                if(request == "CharInvCharInv"){
                    CharInvCharInv(nconn, item, playerData, equippedData);//changed
                }
                if(request == "CharEquipCharInv"){
                    CharEquipCharInv(nconn, item, playerData, equippedData);//changed
                    //changedInMatch
                }
                if(request == "CharInvCharEquip"){
                    CharInvCharEquip(nconn, item, playerData, equippedData);//changed
                    //changedInMatch
                }
                if(request == "CharEquipCharEquip"){
                    CharEquipCharEquip(nconn, item, playerData, equippedData);//changed
                    //changedINMatch
                }
                if(request == "CharEquipEquipSame"){
                    CharEquipEquipSame(nconn, item, playerData, equippedData);//changed
                }
                if(request == "CharInvEquipSame"){
                    CharInvEquipSame(nconn, item, playerData, equippedData);//changed
                    //changedInMatch
                }
                if(request == "CharEquipInvSame"){
                    CharEquipInvSame(nconn, item, playerData, equippedData);//changed
                    //changedInMatch
                }

            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void AuthenticateThenSavePF(NetworkConnectionToClient nconn, ItemSelectable item, string request){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED AuthenticateThenSavePF  IDs are item one {item.GetItemName()}");

            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {
                if(request == "StashToTactInventory"){
                    StashToTactInventory(nconn, item, playerData);//changed
                }
                if(request == "StashToTactBelt"){
                    StashToTactBelt(nconn, item, playerData);//changed
                }
                if(request == "TactInventoryToStash"){
                    TactInventoryToStash(nconn, item, playerData);//changed
                }
                if(request == "TactInvToTactBelt"){
                    TactInvToTactBelt(nconn, item, playerData);//changed
                }
                if(request == "TactEquipToStash"){
                    TactEquipToStash(nconn, item, playerData);//changed
                }
                if(request == "TactBeltToStash"){
                    TactBeltToStash(nconn, item, playerData);//changed
                } 
                if(request == "TactEquipToTactInv"){
                    TactEquipToTactInv(nconn, item, playerData);//changed

                }
                if(request == "TactEquipToTactBelt"){
                    TactEquipToTactBelt(nconn, item, playerData);//changed
                    //changeInMatchAdded
                }
                if(request == "TactBeltToTactInv"){
                    TactBeltToTactInv(nconn, item, playerData);//changed
                }
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void AuthenticateThenSavePFEquip(NetworkConnectionToClient nconn, ItemSelectable item, string request, string SlotName){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED AuthenticateThenSavePFEquip  IDs are item one {item.GetItemName()}");
            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {
                if(request == "StashToTactEquip"){
                    StashToTactEquip(nconn, item, playerData, SlotName);//changed
                }
                if(request == "TacticianInvToTacticianEquip"){
                    TactInvToTactEquip(nconn, item, playerData, SlotName);//changed
                    //changeInMatchAdded
                }
                if(request == "TactBeltToTactEquip"){
                    TactBeltToTactEquip(nconn, item, playerData, SlotName);//changed
                    //changeInMatchAdded
                }
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
            #if UNITY_SERVER //|| UNITY_EDITOR

        void SendItemToUserForUpdatingThenBackToDesiredSerial(NetworkConnectionToClient nconn, ItemSelectable item, EquipmentSaveData data){
            if(!CheckNullConnection(nconn)){
                return;
            }
            print("Launching SendItemToUserForUpdatingThenBackToDesiredSerial");

            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED SendItemToUserForUpdatingThenBackToDesiredSerial  IDs are item one {item.GetItemName()}");

            string slot = null;
            slot = item.EQUIPPEDSLOT;
            string durability = null;
            durability = item.Durability;
            Dictionary<string, string> DATA = new Dictionary<string, string>();
            if(item.OGTacticianBelt){
                DATA.Add("TactBelt", null);
            }
            if(item.OGTacticianInventory){
                DATA.Add("TactInventory", null);
            }
            if(item.OGTacticianStash){
                DATA.Add("TactStash", null);
            }
            if(!item.GetNFT()){
                DATA.Add("Durability_item", durability);
            }
            DATA.Add("Amount", item.amount.ToString());
            DATA.Add("EquippedSlot", slot);
            print("Position 1");
            PlayFabServerAPI.MoveItemToUserFromCharacter( new MoveItemToUserFromCharacterRequest
            {
                CharacterId = data.CharacterSlotOne,
                ItemInstanceId = item.GetInstanceID(),
                PlayFabId = playerData.PlayFabId,
            }, result =>
            {
            print("Position 2");

                PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest {
                ItemInstanceId = item.GetInstanceID(),
                PlayFabId = playerData.PlayFabId,
                Data = DATA
            }, result => {
            print("Position 3");

                PlayFabServerAPI.MoveItemToCharacterFromUser( new MoveItemToCharacterFromUserRequest
                {
                    CharacterId = data.CharacterSlotTwo,
                    ItemInstanceId = item.GetInstanceID(),
                    PlayFabId = playerData.PlayFabId,
                }, result =>
                {
            print("Position 4");
                }, error =>{
                    Debug.Log(error.ErrorMessage);
                });
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
        }
        void SendItemFromTacticianToCharacter(NetworkConnectionToClient nconn, ItemSelectable item, EquipmentSaveData data){
            if(!CheckNullConnection(nconn)){
                return;
            }
            print("Launching SendItemFromTacticianToCharacter");

            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED SendItemFromTacticianToCharacter  IDs are item one {item.GetItemName()}");
            string slot = null;
            if(item.EQUIPPEDSLOT == "Unequipped" || item.EQUIPPEDSLOT == "0"){

            } else {
                slot = item.EQUIPPEDSLOT;
            }
            string durability = null;
            durability = item.Durability;
            Dictionary<string, string> DATA = new Dictionary<string, string>();
            if(data.OGTactBelt && !data.TactBelt){
                DATA.Add("TactBelt", null);
            }
            if(data.OGTactInv  && !data.TactInv){
                DATA.Add("TactInventory", null);
            }
            if(data.OGStash && !data.Stash){
                DATA.Add("TactStash", null);
            }
            if(durability != null){
                DATA.Add("Durability_item", durability);
            }
            DATA.Add("Amount", item.amount.ToString());
            if(slot != null){
                DATA.Add("EquippedSlot", slot);
            } else {
                DATA.Add("EquippedSlot", null);
            }
            print("Position 1 tact to char");
            print($"{data.CharacterSlotOne} was CharID");
            foreach(var dataitem in DATA){
                print($"{dataitem.Key} is our key and {dataitem.Value} is our value in the Data dictionary");
            }
            PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest {
            ItemInstanceId = item.GetInstanceID(),
            PlayFabId = playerData.PlayFabId,
            Data = DATA
            }, result => {
            print("Position 2");

                PlayFabServerAPI.MoveItemToCharacterFromUser( new MoveItemToCharacterFromUserRequest
                {
                    CharacterId = data.CharacterSlotOne,
                    ItemInstanceId = item.GetInstanceID(),
                    PlayFabId = playerData.PlayFabId,
                }, result =>
                {
            print("Position 3");

                }, error =>{
                    Debug.Log(error.ErrorMessage);
                });
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
        }
        void SaveTacticianChange(NetworkConnectionToClient nconn, ItemSelectable item){
            print("Launching SaveTacticianChange");
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED SaveTacticianChange  IDs are item one {item.GetItemName()}");
            string durability = null;
            durability = item.Durability;
            Dictionary<string, string> DATA = new Dictionary<string, string>();
            if(item.OGTacticianBelt && !item.GetTacticianBelt()){
                DATA.Add("TactBelt", null);
            }
            if(item.OGTacticianInventory && !item.GetTacticianInventory()){
                DATA.Add("TactInventory", null);
            }
            if(item.OGTacticianStash && !item.GetTacticianStash()){
                DATA.Add("TactStash", null);
            }
            if(item.GetTacticianStash()){
                if(DATA.ContainsKey("TactStash")){
                    DATA.Remove("TactStash");
                }
                DATA.Add("TactStash", "Stashed");
            }
            if(item.GetTacticianInventory()){
                if(DATA.ContainsKey("TactInventory")){
                    DATA.Remove("TactInventory");
                }
                DATA.Add("TactInventory", "InventoryItem");
            }
            if(item.GetTacticianBelt()){
                if(DATA.ContainsKey("TactBelt")){
                    DATA.Remove("TactBelt");
                }
                DATA.Add("TactBelt", "Belted");
            }
            if(!item.GetNFT()){
                DATA.Add("Durability_item", durability);
            }
            DATA.Add("Amount", item.amount.ToString());
            DATA.Add("EquippedSlot", item.EQUIPPEDSLOT);
            PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest {
            ItemInstanceId = item.GetInstanceID(),
            PlayFabId = playerData.PlayFabId,
            Data = DATA
            }, result => {
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
        }
        void SendItemFromCharacterToTactician(NetworkConnectionToClient nconn, ItemSelectable item, EquipmentSaveData data){
            if(!CheckNullConnection(nconn)){
                return;
            }
            print("Launching SendItemFromCharacterToTactician");
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED SendItemFromCharacterToTactician  IDs are item one {item.GetItemName()}");
            string slot = null;
            slot = item.EQUIPPEDSLOT;
            string durability = null;
            durability = item.Durability;
            Dictionary<string, string> DATA = new Dictionary<string, string>();
            if(item.OGTacticianBelt && !item.GetTacticianBelt()){
                DATA.Add("TactBelt", null);
            }
            if(item.OGTacticianInventory && !item.GetTacticianInventory()){
                DATA.Add("TactInventory", null);
            }
            if(item.OGTacticianStash && !item.GetTacticianStash()){
                DATA.Add("TactStash", null);
            }
            if(item.GetTacticianStash()){
                if(DATA.ContainsKey("TactStash")){
                    DATA.Remove("TactStash");
                }
                DATA.Add("TactStash", "Stashed");
            }
            if(item.GetTacticianInventory()){
                if(DATA.ContainsKey("TactInventory")){
                    DATA.Remove("TactInventory");
                }
                DATA.Add("TactInventory", "InventoryItem");
            }
            if(item.GetTacticianBelt()){
                if(DATA.ContainsKey("TactBelt")){
                    DATA.Remove("TactBelt");
                }
                DATA.Add("TactBelt", "Belted");
            }
            if(durability != null){
                DATA.Add("Durability_item", durability);
            }
            DATA.Add("Amount", item.amount.ToString());
            if(slot != null){
                DATA.Add("EquippedSlot", slot);
            } else {
                DATA.Add("EquippedSlot", null);
            }
            print($"Position 1 char to tact equip data includes {data.TactInv} TactInv, {data.TactBelt} TactBelt, {data.TactEquipped} TactEquip, {data.Stash} stash, {data.OGStash} is og stash, {data.OGTactInv} OGTactInv, {data.OGTactEquipped} OGTactEquipped, {data.OGTactBelt} OGTactBelt");
            print($"{data.CharacterSlotOne} was CharID");
            foreach(var dataitem in DATA){
                print($"{dataitem.Key} is our key and {dataitem.Value} is our value in the Data dictionary");
            }
                PlayFabServerAPI.MoveItemToUserFromCharacter( new MoveItemToUserFromCharacterRequest
                {
                    CharacterId = data.CharacterSlotOne,
                    ItemInstanceId = item.GetInstanceID(),
                    PlayFabId = playerData.PlayFabId,
                }, result =>
                {
                    print("Position 2 char to tact");
                    PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest {
                    ItemInstanceId = item.GetInstanceID(),
                    PlayFabId = playerData.PlayFabId,
                    Data = DATA
                    }, result => {
                    print("Position 3 char to tact");

                    }, error =>{
                        Debug.Log(error.ErrorMessage);
                    });
                }, error =>{
                    Debug.Log(error.ErrorMessage);
                });
        }
        #endif
        //Stash Calls
        void StashToTactInventory(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED StashToTactInventory IDs are item one {item.GetItemName()}");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem itemTransferring = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().StashInventoryData){
                if(stashitem.Value.customID == item.customID){
                    itemTransferring = stashitem;
                    break;
                }
            }
            stash.GetStashRemoveItem(itemTransferring);
            itemTransferring.Value.TacticianStash = false;
            itemTransferring.Value.TacticianInventory = true;
            itemTransferring.Value.Changed = true;
            stash.GetTacticianNewItem(itemTransferring);
            #endif
        }
        void StashToTactBelt(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED StashToTactBelt IDs are item one {item.GetItemName()}");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem itemTransferring = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().StashInventoryData){
                if(stashitem.Value.customID == item.customID){
                    itemTransferring = stashitem;
                    break;
                }
            }
            itemTransferring.Value.TacticianStash = false;
            itemTransferring.Value.TacticianBelt = true;
            itemTransferring.Value.Changed = true;
            stash.GetStashRemoveItem(itemTransferring);
            stash.GetTacticianNewItem(itemTransferring);
            #endif
        }
        void StashToTactEquip(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string SlotName){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED StashToTactEquip IDs are item one {item.GetItemName()} and {SlotName} is our slotName");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem itemTransferring = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().StashInventoryData){
                if(stashitem.Value.customID == item.customID){
                    itemTransferring = stashitem;
                    break;
                }
            }
            stash.GetStashRemoveItem(itemTransferring);
            itemTransferring.Value.TacticianStash = false;
            itemTransferring.Value.TacticianEquip = true;
            itemTransferring.Value.EQUIPPEDSLOT = SlotName;
            itemTransferring.Value.Changed = true;
            
            stash.GetTacticianNewItem(itemTransferring);
            #endif
        }
        void TactInvCharInv(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string characterSlot){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactInvCharInv IDs are item one {item.GetItemName()} and {characterSlot} is char slot");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianInventory = false;
            stashItem.Value.INVENTORY = true;
            stashItem.Value.Changed = true;
            stash.GetCharacterNewItem(characterSlot, stashItem);
            #endif
        }
        void TactEquipCharInv(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string characterSlot){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactEquipCharInv IDs are item one {item.GetItemName()} and {characterSlot} is char slot");
            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianEquip = false;
            stashItem.Value.EQUIPPEDSLOT = "Unequipped";
            stashItem.Value.INVENTORY = true;
            stashItem.Value.Changed = true;
            int ItemFort = 0;
            int ItemArcana = 0;
            if(!string.IsNullOrEmpty(stashItem.Value.FORTITUDE_item)){
                if(int.Parse(stashItem.Value.FORTITUDE_item) > 0){
                    ItemFort = int.Parse(stashItem.Value.FORTITUDE_item);
                }
            }
            if(!string.IsNullOrEmpty(stashItem.Value.ARCANA_item)){
                if(int.Parse(stashItem.Value.ARCANA_item) > 0){
                    ItemArcana = int.Parse(stashItem.Value.ARCANA_item);
                }
            }
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            if(ItemFort > 0 || ItemArcana > 0 || ItemFort > 0 && ItemArcana > 0){
                TacticianFullDataMessage tacticianSheet = stash.GetTacticianSheet();
                tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
                tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);
                foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                    if(tacticianEquipped.Value.Deleted || tacticianEquipped.Value.amount == 0){
                        continue;
                    }
                    if (tacticianEquipped.Value.GetTacticianEquip())
                    {
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                        {
                            tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                        }
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                        {
                            tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                        }
                    }
                }
                if(ItemFort > 0 || ItemArcana > 0){
                    Dictionary<string, List<CharacterStatListItem>> charDictionary = new Dictionary<string, List<CharacterStatListItem>>();

                    foreach(var sheet in stash.GetInformationSheets()){
                        string _class = string.Empty;
                        int _level = 1;
                        string _core = string.Empty;
                        int curHP = 1;
                        int curMP = 1;
                        int equippedFort = 0;
                        int equippedArcana = 0;
                        foreach(var invItem in sheet.CharInventoryData){
                            if(invItem.Value.Deleted || invItem.Value.amount == 0){
                                continue;
                            }
                            if(invItem.Value.customID != item.customID && invItem.Value.EQUIPPED){
                                int tempValue;

                                if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
                                {
                                    equippedFort += tempValue;
                                }

                                if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
                                {
                                    equippedArcana += tempValue;
                                }
                            }
                        }
                        foreach(var stat in sheet.CharStatData){
                            if(stat.Key == "currentHP"){
                                curHP = int.Parse(stat.Value);
                            }
                            if(stat.Key == "currentMP"){
                                curMP = int.Parse(stat.Value);
                            }
                            if (stat.Key == "Class") {
                                _class = stat.Value;
                            }
                            if (stat.Key == "LVL") {
                                _level = int.Parse(stat.Value);
                            }
                            if (stat.Key == "CORE") {
                                _core = stat.Value;
                            }
                        }
                        int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < stash.GetInformationSheets().Count; _char++){
                            if(stash.GetInformationSheets()[_char].CharacterID == sheet.CharacterID){
                                for(int ability = 0; ability < stash.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(stash.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(stash.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(stash.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(stash.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + PASSIVE_Arcana) / 7;
                        if(curHP > maxHP ){
                            curHP = maxHP;
                        }
                        if(curMP > maxMP){
                            curMP = maxMP;
                        }
                        List<CharacterStatListItem> CharList = new List<CharacterStatListItem>();
                        CharacterStatListItem Health = (new CharacterStatListItem{
                            Key = "currentHP",
                            Value = curHP.ToString()
                        });
                        CharacterStatListItem Mana = (new CharacterStatListItem{
                            Key = "currentMP",
                            Value = curMP.ToString()
                        });
                        CharList.Add(Health);
                        CharList.Add(Mana);
                        charDictionary.Add(sheet.CharacterID, CharList);
                    }
                    foreach(var key in charDictionary){
                        CharacterStatListItem Health = (new CharacterStatListItem{
                            Key = "currentHP"
                        });
                        CharacterStatListItem Mana = (new CharacterStatListItem{
                            Key = "currentMP"
                        });
                        foreach(var listKey in key.Value){
                            if(listKey.Key == "currentHP"){
                                Health = listKey;
                            }
                            if(listKey.Key == "currentMP"){
                                Mana = listKey;
                            }
                        }
                        stash.GetCharacterUpdateHPMP(key.Key, Health, Mana);
                    }
                }
            }
            stash.GetCharacterNewItem(characterSlot, stashItem);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
            }
            ChangedGearMessage gearMessage = new ChangedGearMessage(string.Empty, "Unequipped", matchRef, false, stashItem.Value);
            tactGearChangeMatch.Invoke(gearMessage, stash);
            
            #endif
        }
        void TactBeltCharInv(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string characterSlot){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactBeltCharInv IDs are item one {item.GetItemName()} and {characterSlot} is char slot");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianBelt = false;
            stashItem.Value.INVENTORY = true;
            stashItem.Value.Changed = true;
            stash.GetCharacterNewItem(characterSlot, stashItem);
            #endif
        }
        void StashToCharInv(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string characterSlot){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED StashToCharInv IDs are item one {item.GetItemName()} and {characterSlot} is char slot");
            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().StashInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetStashRemoveItem(stashItem);
            stashItem.Value.TacticianStash = false;
            stashItem.Value.INVENTORY = true;
            stashItem.Value.Changed = true;
            stash.GetCharacterNewItem(characterSlot, stashItem);
            #endif
        }
        void StashToCharEquip(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, EquippingData equippedData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED StashToCharEquip IDs are item one {item.GetItemName()} and {equippedData.CharacterSlot} is char slot and {item.customID} is our custom ID we are looking for");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().StashInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetStashRemoveItem(stashItem);
            stashItem.Value.TacticianStash = false;
            stashItem.Value.EQUIPPED = true;
            stashItem.Value.EQUIPPEDSLOT = equippedData.Slot;
            stashItem.Value.Changed = true;
            stash.GetCharacterNewItem(equippedData.CharacterSlot, stashItem);
            #endif
        }
        //Tactician calls
        void TactInvToCharEquip(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, EquippingData equippedData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactInvToCharEquip IDs are item one {item.GetItemName()} and {equippedData.CharacterSlot} is char slot and {item.customID} is our custom ID we are looking for");
            
            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianInventory = false;
            stashItem.Value.EQUIPPED = true;
            stashItem.Value.EQUIPPEDSLOT = equippedData.Slot;
            stashItem.Value.Changed = true;
            stash.GetCharacterNewItem(equippedData.CharacterSlot, stashItem);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
                ChangedGearMessage gearMessage = new ChangedGearMessage(equippedData.CharacterSlot, equippedData.Slot, matchRef, true, stashItem.Value);
                charGearChangeMatch.Invoke(gearMessage);
            }
            
            #endif
        }
        void TactBeltToCharEquip(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, EquippingData equippedData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactBeltToCharEquip IDs are item one {item.GetItemName()} and {equippedData.CharacterSlot} is char slot and {item.customID} is our custom ID we are looking for");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianInventory = false;
            stashItem.Value.TacticianBelt = false;
            stashItem.Value.EQUIPPED = true;
            stashItem.Value.EQUIPPEDSLOT = equippedData.Slot;
            stashItem.Value.Changed = true;
            stash.GetCharacterNewItem(equippedData.CharacterSlot, stashItem);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
                ChangedGearMessage gearMessage = new ChangedGearMessage(equippedData.CharacterSlot, equippedData.Slot, matchRef, true, stashItem.Value);

                charGearChangeMatch.Invoke(gearMessage);
            }
            #endif
        }
        void TactInventoryToStash(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactInventoryToStash IDs are item one {item.GetItemName()}");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianStash = true;
            stashItem.Value.Changed = true;
            stashItem.Value.TacticianInventory = false;
            stash.GetStashNewItem(stashItem);
            #endif
        }
        void TactBeltToStash(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactBeltToStash IDs are item one {item.GetItemName()}");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianStash = true;
            stashItem.Value.TacticianBelt = false;
            stashItem.Value.Changed = true;
            stash.GetStashNewItem(stashItem);
            #endif
        }
        void TactEquipToStash(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactEquipToStash IDs are item one {item.GetItemName()}");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianStash = true;
            stashItem.Value.Changed = true;
            stashItem.Value.TacticianEquip = false;
            stashItem.Value.EQUIPPEDSLOT = "Unequipped";
            int ItemFort = 0;
            int ItemArcana = 0;
            if(!string.IsNullOrEmpty(stashItem.Value.FORTITUDE_item)){
                if(int.Parse(stashItem.Value.FORTITUDE_item) > 0){
                    ItemFort = int.Parse(stashItem.Value.FORTITUDE_item);
                }
            }
            if(!string.IsNullOrEmpty(stashItem.Value.ARCANA_item)){
                if(int.Parse(stashItem.Value.ARCANA_item) > 0){
                    ItemArcana = int.Parse(stashItem.Value.ARCANA_item);
                }
            }
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            if(ItemFort > 0 || ItemArcana > 0 || ItemFort > 0 && ItemArcana > 0){
                TacticianFullDataMessage tacticianSheet = stash.GetTacticianSheet();
                tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
                tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);
                foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                    if(tacticianEquipped.Value.Deleted){
                        continue;
                    }
                    if (tacticianEquipped.Value.GetTacticianEquip())
                    {
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                        {
                            tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                        }
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                        {
                            tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                        }
                    }
                }
                if(ItemFort > 0 || ItemArcana > 0){
                    Dictionary<string, List<CharacterStatListItem>> charDictionary = new Dictionary<string, List<CharacterStatListItem>>();

                    foreach(var sheet in stash.GetInformationSheets()){
                        string _class = string.Empty;
                        int _level = 1;
                        string _core = string.Empty;
                        int curHP = 1;
                        int curMP = 1;
                        int equippedFort = 0;
                        int equippedArcana = 0;
                        foreach(var invItem in sheet.CharInventoryData){
                            if(invItem.Value.Deleted || invItem.Value.amount == 0){
                                continue;
                            }
                            if(invItem.Value.customID != item.customID && invItem.Value.EQUIPPED){
                                int tempValue;

                                if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
                                {
                                    equippedFort += tempValue;
                                }

                                if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
                                {
                                    equippedArcana += tempValue;
                                }
                            }
                        }
                        foreach(var stat in sheet.CharStatData){
                            if(stat.Key == "currentHP"){
                                curHP = int.Parse(stat.Value);
                            }
                            if(stat.Key == "currentMP"){
                                curMP = int.Parse(stat.Value);
                            }
                            if (stat.Key == "Class") {
                                _class = stat.Value;
                            }
                            if (stat.Key == "LVL") {
                                _level = int.Parse(stat.Value);
                            }
                            if (stat.Key == "CORE") {
                                _core = stat.Value;
                            }
                        }
                        int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < stash.GetInformationSheets().Count; _char++){
                            if(stash.GetInformationSheets()[_char].CharacterID == sheet.CharacterID){
                                for(int ability = 0; ability < stash.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(stash.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(stash.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(stash.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(stash.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + PASSIVE_Arcana) / 7;
                        if(curHP > maxHP ){
                            curHP = maxHP;
                        }
                        if(curMP > maxMP){
                            curMP = maxMP;
                        }
                        List<CharacterStatListItem> CharList = new List<CharacterStatListItem>();
                        CharacterStatListItem Health = (new CharacterStatListItem{
                            Key = "currentHP",
                            Value = curHP.ToString()
                        });
                        CharacterStatListItem Mana = (new CharacterStatListItem{
                            Key = "currentMP",
                            Value = curMP.ToString()
                        });
                        CharList.Add(Health);
                        CharList.Add(Mana);
                        charDictionary.Add(sheet.CharacterID, CharList);
                    }
                    foreach(var key in charDictionary){
                        CharacterStatListItem Health = (new CharacterStatListItem{
                            Key = "currentHP"
                        });
                        CharacterStatListItem Mana = (new CharacterStatListItem{
                            Key = "currentMP"
                        });
                        foreach(var listKey in key.Value){
                            if(listKey.Key == "currentHP"){
                                Health = listKey;
                            }
                            if(listKey.Key == "currentMP"){
                                Mana = listKey;
                            }
                        }
                        stash.GetCharacterUpdateHPMP(key.Key, Health, Mana);
                    }
                }
            }
            stash.GetStashNewItem(stashItem);
            #endif
        }
        void TactInvToTactBelt(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactInvToTactBelt IDs are item one {item.GetItemName()}");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianBelt = true;
            stashItem.Value.Changed = true;
            stashItem.Value.TacticianInventory = false;
            stash.GetTacticianNewItem(stashItem);
            #endif
        }
        void TactInvToTactEquip(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string SlotName){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactInvToTactEquip IDs are item one {item.GetItemName()}");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianInventory = false;
            stashItem.Value.TacticianEquip = true;
            stashItem.Value.EQUIPPEDSLOT = SlotName;
            stashItem.Value.Changed = true;
            stash.GetTacticianNewItem(stashItem);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
            }
            ChangedGearMessage gearMessage = new ChangedGearMessage(string.Empty, "Unequipped", matchRef, true, stashItem.Value);
            tactGearChangeMatch.Invoke(gearMessage, stash);

            #endif
        }
        void TactEquipToTactInv(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactEquipToTactInv IDs are item one {item.GetItemName()}");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianInventory = true;
            stashItem.Value.TacticianEquip = false;
            stashItem.Value.Changed = true;
            stashItem.Value.EQUIPPEDSLOT = "Unequipped";
            int ItemFort = 0;
            int ItemArcana = 0;
            if(!string.IsNullOrEmpty(stashItem.Value.FORTITUDE_item)){
                if(int.Parse(stashItem.Value.FORTITUDE_item) > 0){
                    ItemFort = int.Parse(stashItem.Value.FORTITUDE_item);
                }
            }
            if(!string.IsNullOrEmpty(stashItem.Value.ARCANA_item)){
                if(int.Parse(stashItem.Value.ARCANA_item) > 0){
                    ItemArcana = int.Parse(stashItem.Value.ARCANA_item);
                }
            }
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            if(ItemFort > 0 || ItemArcana > 0 || ItemFort > 0 && ItemArcana > 0){
                TacticianFullDataMessage tacticianSheet = stash.GetTacticianSheet();
                tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
                tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);
                foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                    if(tacticianEquipped.Value.Deleted){
                        continue;
                    }
                    if (tacticianEquipped.Value.GetTacticianEquip())
                    {
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                        {
                            tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                        }
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                        {
                            tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                        }
                    }
                }
                if(ItemFort > 0 || ItemArcana > 0){
                    Dictionary<string, List<CharacterStatListItem>> charDictionary = new Dictionary<string, List<CharacterStatListItem>>();
                    
                    foreach(var sheet in stash.GetInformationSheets()){
                        string _class = string.Empty;
                        int _level = 1;
                        string _core = string.Empty;
                        int curHP = 1;
                        int curMP = 1;
                        int equippedFort = 0;
                        int equippedArcana = 0;
                        foreach(var invItem in sheet.CharInventoryData){
                            if(invItem.Value.Deleted || invItem.Value.amount == 0){
                                continue;
                            }
                            if(invItem.Value.customID != item.customID && invItem.Value.EQUIPPED){
                                int tempValue;

                                if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
                                {
                                    equippedFort += tempValue;
                                }

                                if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
                                {
                                    equippedArcana += tempValue;
                                }
                            }
                        }
                        foreach(var stat in sheet.CharStatData){
                            if(stat.Key == "currentHP"){
                                curHP = int.Parse(stat.Value);
                            }
                            if(stat.Key == "currentMP"){
                                curMP = int.Parse(stat.Value);
                            }
                            if (stat.Key == "Class") {
                                _class = stat.Value;
                            }
                            if (stat.Key == "LVL") {
                                _level = int.Parse(stat.Value);
                            }
                            if (stat.Key == "CORE") {
                                _core = stat.Value;
                            }
                        }
                        int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < stash.GetInformationSheets().Count; _char++){
                            if(stash.GetInformationSheets()[_char].CharacterID == sheet.CharacterID){
                                for(int ability = 0; ability < stash.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(stash.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(stash.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(stash.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(stash.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + PASSIVE_Arcana) / 7;
                        if(curHP > maxHP ){
                            curHP = maxHP;
                        }
                        if(curMP > maxMP){
                            curMP = maxMP;
                        }
                        List<CharacterStatListItem> CharList = new List<CharacterStatListItem>();
                        CharacterStatListItem Health = (new CharacterStatListItem{
                            Key = "currentHP",
                            Value = curHP.ToString()
                        });
                        CharacterStatListItem Mana = (new CharacterStatListItem{
                            Key = "currentMP",
                            Value = curMP.ToString()
                        });
                        CharList.Add(Health);
                        CharList.Add(Mana);
                        charDictionary.Add(sheet.CharacterID, CharList);
                    }
                    foreach(var key in charDictionary){
                        CharacterStatListItem Health = (new CharacterStatListItem{
                            Key = "currentHP"
                        });
                        CharacterStatListItem Mana = (new CharacterStatListItem{
                            Key = "currentMP"
                        });
                        foreach(var listKey in key.Value){
                            if(listKey.Key == "currentHP"){
                                Health = listKey;
                            }
                            if(listKey.Key == "currentMP"){
                                Mana = listKey;
                            }
                        }
                        stash.GetCharacterUpdateHPMP(key.Key, Health, Mana);
                    }
                }
            }
            stash.GetTacticianNewItem(stashItem);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
            }
            ChangedGearMessage gearMessage = new ChangedGearMessage(string.Empty, "Unequipped", matchRef, false, stashItem.Value);
            tactGearChangeMatch.Invoke(gearMessage, stash);
            
            #endif
        }
        void TactEquipToTactEquip(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string SlotName){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            
            print($"{playerData.PlayFabId} REQUESTED TactEquipToTactEquip IDs are item one {item.GetItemName()}");
            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = (new CharacterInventoryListItem{
                Key = item.GetInstanceID(),
                Value = item
            });
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianEquip = true;
            stashItem.Value.Changed = true;
            stashItem.Value.EQUIPPEDSLOT = SlotName;
            stash.GetTacticianNewItem(stashItem);
            //PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest {
            //    ItemInstanceId = item.GetInstanceID(),
            //    PlayFabId = playerData.PlayFabId,
            //    Data = new Dictionary<string, string> {
            //        {"EquippedSlot", SlotName}
            //    }
            //}, result => {
            //    //print("moved and doneskies");
            //}, error =>{
            //    Debug.Log(error.ErrorMessage);
            //});
            #endif
        }
        void TactEquipToTactBelt(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactEquipToTactBelt IDs are item one {item.GetItemName()}");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianEquip = false;
            stashItem.Value.EQUIPPEDSLOT = "Unequipped";
            stashItem.Value.TacticianBelt = true;
            stashItem.Value.Changed = true;
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            int ItemFort = 0;
            int ItemArcana = 0;
            if(!string.IsNullOrEmpty(stashItem.Value.FORTITUDE_item)){
                if(int.Parse(stashItem.Value.FORTITUDE_item) > 0){
                    ItemFort = int.Parse(stashItem.Value.FORTITUDE_item);
                }
            }
            if(!string.IsNullOrEmpty(stashItem.Value.ARCANA_item)){
                if(int.Parse(stashItem.Value.ARCANA_item) > 0){
                    ItemArcana = int.Parse(stashItem.Value.ARCANA_item);
                }
            }
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            if(ItemFort > 0 || ItemArcana > 0 || ItemFort > 0 && ItemArcana > 0){
                TacticianFullDataMessage tacticianSheet = stash.GetTacticianSheet();
                tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
                tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);
                foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                    if(tacticianEquipped.Value.Deleted){
                        continue;
                    }
                    if (tacticianEquipped.Value.GetTacticianEquip())
                    {
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                        {
                            tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                        }
                        if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                        {
                            tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                        }
                    }
                }
                if(ItemFort > 0 || ItemArcana > 0){
                    Dictionary<string, List<CharacterStatListItem>> charDictionary = new Dictionary<string, List<CharacterStatListItem>>();

                    foreach(var sheet in stash.GetInformationSheets()){
                        string _class = string.Empty;
                        int _level = 1;
                        string _core = string.Empty;
                        int curHP = 1;
                        int curMP = 1;
                        int equippedFort = 0;
                        int equippedArcana = 0;
                        foreach(var invItem in sheet.CharInventoryData){
                            if(invItem.Value.Deleted || invItem.Value.amount == 0){
                                continue;
                            }
                            if(invItem.Value.customID != item.customID && invItem.Value.EQUIPPED){
                                int tempValue;

                                if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
                                {
                                    equippedFort += tempValue;
                                }

                                if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
                                {
                                    equippedArcana += tempValue;
                                }
                            }
                        }
                        foreach(var stat in sheet.CharStatData){
                            if(stat.Key == "currentHP"){
                                curHP = int.Parse(stat.Value);
                            }
                            if(stat.Key == "currentMP"){
                                curMP = int.Parse(stat.Value);
                            }
                            if (stat.Key == "Class") {
                                _class = stat.Value;
                            }
                            if (stat.Key == "LVL") {
                                _level = int.Parse(stat.Value);
                            }
                            if (stat.Key == "CORE") {
                                _core = stat.Value;
                            }
                        }
                        
                       int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < stash.GetInformationSheets().Count; _char++){
                            if(stash.GetInformationSheets()[_char].CharacterID == sheet.CharacterID){
                                for(int ability = 0; ability < stash.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(stash.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(stash.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(stash.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(stash.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + PASSIVE_Arcana) / 7;
                        if(curHP > maxHP ){
                            curHP = maxHP;
                        }
                        if(curMP > maxMP){
                            curMP = maxMP;
                        }
                        List<CharacterStatListItem> CharList = new List<CharacterStatListItem>();
                        CharacterStatListItem Health = (new CharacterStatListItem{
                            Key = "currentHP",
                            Value = curHP.ToString()
                        });
                        CharacterStatListItem Mana = (new CharacterStatListItem{
                            Key = "currentMP",
                            Value = curMP.ToString()
                        });
                        CharList.Add(Health);
                        CharList.Add(Mana);
                        charDictionary.Add(sheet.CharacterID, CharList);
                    }
                    foreach(var key in charDictionary){
                        CharacterStatListItem Health = (new CharacterStatListItem{
                            Key = "currentHP"
                        });
                        CharacterStatListItem Mana = (new CharacterStatListItem{
                            Key = "currentMP"
                        });
                        foreach(var listKey in key.Value){
                            if(listKey.Key == "currentHP"){
                                Health = listKey;
                            }
                            if(listKey.Key == "currentMP"){
                                Mana = listKey;
                            }
                        }
                        stash.GetCharacterUpdateHPMP(key.Key, Health, Mana);
                    }
                }
            }
            stash.GetTacticianNewItem(stashItem);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
            }
            ChangedGearMessage gearMessage = new ChangedGearMessage(string.Empty, "Unequipped", matchRef, false, stashItem.Value);
            tactGearChangeMatch.Invoke(gearMessage, stash);
            #endif
        }
        void TactBeltToTactInv(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactBeltToTactInv IDs are item one {item.GetItemName()}");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.TacticianInventory = true;
            stashItem.Value.TacticianBelt = false;
            stashItem.Value.Changed = true;
            stash.GetTacticianNewItem(stashItem);
            #endif
        }
        void TactBeltToTactEquip(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string SlotName){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED TactBeltToTactEquip IDs are item one {item.GetItemName()} and {SlotName} is slot");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            if(stash == null){
                return;
            }
            TacticianFullDataMessage tactSheet = stash.GetTacticianSheet();
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var stashitem in stash.GetTacticianSheet().TacticianInventoryData){
                if(stashitem.Value.customID == item.customID){
                    stashItem = stashitem;
                    break;
                }
            }
            stash.GetTacticianRemoveItem(stashItem);
            stashItem.Value.EQUIPPED = true;
            stashItem.Value.EQUIPPEDSLOT = SlotName;
            stashItem.Value.TacticianBelt = false;
            stashItem.Value.Changed = true;
            stash.GetTacticianNewItem(stashItem);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
            }
            ChangedGearMessage gearMessage = new ChangedGearMessage(string.Empty, "Unequipped", matchRef, true, stashItem.Value);
            tactGearChangeMatch.Invoke(gearMessage, stash);
            #endif
        }
        //Char calls 
        void CharInvTactInv(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string characterSlot){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharInvTactInv IDs are item one {item.GetItemName()} and {characterSlot} is char slot");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == characterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == item.customID){
                            stashItem = invItem;
                            print($"Found our {stashItem.Value.Item_Name}!! its id is {stashItem.Value.customID} ");
                        }
                    }
                }
            }
            stash.RemoveCharacterItem(characterSlot, stashItem);
            stashItem.Value.INVENTORY = false;
            stashItem.Value.TacticianInventory = true;
            stashItem.Value.Changed = true;
            stash.GetTacticianNewItem(stashItem);
            #endif
        }
        void CharInvTactEquip(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharInvTactEquip IDs are item one {item.GetItemName()} and {equippedData.CharacterSlot} is char slot and {item.customID} is our custom ID we are looking for");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == item.customID){
                            stashItem = invItem;
                            print($"Found our {stashItem.Value.Item_Name}!! its id is {stashItem.Value.customID} ");
                        }
                    }
                }
            }
            stash.RemoveCharacterItem(equippedData.CharacterSlot, stashItem);
            stashItem.Value.INVENTORY = false;
            stashItem.Value.TacticianEquip = true;
            stashItem.Value.EQUIPPEDSLOT = equippedData.Slot;
            stashItem.Value.Changed = true;
            stash.GetTacticianNewItem(stashItem);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
            }
            ChangedGearMessage gearMessage = new ChangedGearMessage(string.Empty, "Unequipped", matchRef, true, stashItem.Value);
            tactGearChangeMatch.Invoke(gearMessage, stash);
            #endif
        }
        void CharInvTactBelt(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string characterSlot){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharInvTactBelt IDs are item one {item.GetItemName()} and {characterSlot} is char slot");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == characterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == item.customID){
                            stashItem = invItem;
                            print($"Found our {stashItem.Value.Item_Name}!! its id is {stashItem.Value.customID} ");
                        }
                    }
                }
            }
            stash.RemoveCharacterItem(characterSlot, stashItem);
            stashItem.Value.INVENTORY = false;
            stashItem.Value.TacticianBelt = true;
            stashItem.Value.Changed = true;
            stash.GetTacticianNewItem(stashItem);
            #endif
        }
        void CharInvStash(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string characterSlot){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharInvStash IDs are item one {item.GetItemName()} and {characterSlot} is char slot");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem stashItem = new CharacterInventoryListItem();
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == characterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == item.customID){
                            stashItem = invItem;
                            print($"Found our {stashItem.Value.Item_Name}!! its id is {stashItem.Value.customID} ");
                        }
                    }
                }
            }
            stash.RemoveCharacterItem(characterSlot, stashItem);
            stashItem.Value.INVENTORY = false;
            stashItem.Value.TacticianStash = true;
            stashItem.Value.Changed = true;
            stash.GetStashNewItem(stashItem);
            #endif
        }
        void CharEquipStash(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string characterSlot){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharEquipStash IDs are item one {item.GetItemName()} and {characterSlot} is char slot");

            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterInventoryListItem CharItem = new CharacterInventoryListItem();
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            TacticianFullDataMessage tacticianSheet = sPlayer.GetTacticianSheet();
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);

            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                }
            }
            string cHP = string.Empty;
            string mHP = string.Empty;
            string _class = string.Empty;
            string _core = string.Empty;
            int _level = 1;
            int equippedFort = 0;
            int equippedArcana = 0;
            foreach(var sheet in sPlayer.GetInformationSheets()){
                if(sheet.CharacterID == characterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.Deleted){
                            continue;
                        }
                        if(invItem.Value.customID == item.customID){
                            CharItem = invItem;
                            //print($"Found our {CharItem.Value.Item_Name}!! its id is {CharItem.Value.customID} ");
                        }
                        if(invItem.Value.customID != item.customID && invItem.Value.EQUIPPED){
                            int tempValue;

    if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
    {
        equippedFort += tempValue;
    }

    if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
    {
        equippedArcana += tempValue;
    }
                        }
                    }
                    foreach(var stat in sheet.CharStatData){
                        if(stat.Key == "currentHP"){
                            cHP = stat.Value;
                        }
                        if(stat.Key == "currentMP"){
                            mHP = stat.Value;
                        }
                        if(stat.Key == "Class"){
                            _class = stat.Value;
                        }
                        if(stat.Key == "LVL"){
                            _level = int.Parse(stat.Value);
                        }
                        if(stat.Key == "CORE"){
                            _core = stat.Value;
                        }
                    }
                }
            }
            int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < sPlayer.GetInformationSheets().Count; _char++){
                            if(sPlayer.GetInformationSheets()[_char].CharacterID == characterSlot){
                                for(int ability = 0; ability < sPlayer.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + PASSIVE_Arcana) / 7;
            sPlayer.RemoveCharacterItem(characterSlot, CharItem);
            CharItem.Value.EQUIPPED = false;
            CharItem.Value.TacticianStash = true;
            CharItem.Value.EQUIPPEDSLOT = "Unequipped";
            CharItem.Value.Changed = true;
            sPlayer.GetStashNewItem(CharItem);
            string finalHPValue = "1";
            string finalMPValue = "1";
            
            if(maxHP < int.Parse(cHP)){
                finalHPValue = maxHP.ToString();
            } else {
                finalHPValue = cHP;
            }
            if(maxMP < int.Parse(mHP)){
                finalMPValue = maxMP.ToString();
            } else {
                finalMPValue = mHP;
            }
            CharacterStatListItem Health = (new CharacterStatListItem {
                Key = "currentHP",
                Value = finalHPValue
            });
            CharacterStatListItem Magic = (new CharacterStatListItem {
                Key = "currentMP",
                Value = finalMPValue
            });
            sPlayer.GetINNServer(characterSlot, Health, Magic);
            #endif
        }
        void CharEquipTactBelt(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string characterSlot){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharEquipTactBelt IDs are item one {item.GetItemName()} and {characterSlot} is char slot");

            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterInventoryListItem CharItem = new CharacterInventoryListItem();
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            TacticianFullDataMessage tacticianSheet = sPlayer.GetTacticianSheet();
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);

            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                }
            }
            string cHP = string.Empty;
            string mHP = string.Empty;
            string _class = string.Empty;
            string _core = string.Empty;
            int _level = 1;
            int equippedFort = 0;
            int equippedArcana = 0;
            foreach(var sheet in sPlayer.GetInformationSheets()){
                if(sheet.CharacterID == characterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.Deleted){
                            continue;
                        }
                        if(invItem.Value.customID == item.customID){
                            CharItem = invItem;
                            //print($"Found our {CharItem.Value.Item_Name}!! its id is {CharItem.Value.customID} ");
                        }
                        if(invItem.Value.customID != item.customID && invItem.Value.EQUIPPED){
                            int tempValue;

    if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
    {
        equippedFort += tempValue;
    }

    if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
    {
        equippedArcana += tempValue;
    }
                        }
                    }
                    foreach(var stat in sheet.CharStatData){
                        if(stat.Key == "currentHP"){
                            cHP = stat.Value;
                        }
                        if(stat.Key == "currentMP"){
                            mHP = stat.Value;
                        }
                        if(stat.Key == "Class"){
                            _class = stat.Value;
                        }
                        if(stat.Key == "LVL"){
                            _level = int.Parse(stat.Value);
                        }
                        if(stat.Key == "CORE"){
                            _core = stat.Value;
                        }
                    }
                }
            }
            int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < sPlayer.GetInformationSheets().Count; _char++){
                            if(sPlayer.GetInformationSheets()[_char].CharacterID == characterSlot){
                                for(int ability = 0; ability < sPlayer.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + PASSIVE_Arcana) / 7;
            string itemSlot = CharItem.Value.EQUIPPEDSLOT;
            sPlayer.RemoveCharacterItem(characterSlot, CharItem);
            CharItem.Value.EQUIPPED = false;
            CharItem.Value.TacticianBelt = true;
            CharItem.Value.EQUIPPEDSLOT = "Unequipped";
            CharItem.Value.Changed = true;
            sPlayer.GetTacticianNewItem(CharItem);
            string finalHPValue = "1";
            string finalMPValue = "1";
            
            if(maxHP < int.Parse(cHP)){
                finalHPValue = maxHP.ToString();
            } else {
                finalHPValue = cHP;
            }
            if(maxMP < int.Parse(mHP)){
                finalMPValue = maxMP.ToString();
            } else {
                finalMPValue = mHP;
            }
            CharacterStatListItem Health = (new CharacterStatListItem {
                Key = "currentHP",
                Value = finalHPValue
            });
            CharacterStatListItem Magic = (new CharacterStatListItem {
                Key = "currentMP",
                Value = finalMPValue
            });
            sPlayer.GetINNServer(characterSlot, Health, Magic);
            Match matchRef = null;
            if(sPlayer.currentMatch != null){
                matchRef = sPlayer.currentMatch;
                ChangedGearMessage gearMessage = new ChangedGearMessage(characterSlot, itemSlot, matchRef, false, CharItem.Value);
                charGearChangeMatch.Invoke(gearMessage);
            }
            
            #endif
        }
        void CharEquipTactInv(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, string characterSlot){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharEquipTactInv IDs are item one {item.GetItemName()} and {characterSlot} is char slot");

            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterInventoryListItem CharItem = new CharacterInventoryListItem();
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            TacticianFullDataMessage tacticianSheet = sPlayer.GetTacticianSheet();
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);

            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                }
            }
            string cHP = string.Empty;
            string mHP = string.Empty;
            string _class = string.Empty;
            string _core = string.Empty;
            int _level = 1;
            int equippedFort = 0;
            int equippedArcana = 0;
            foreach(var sheet in sPlayer.GetInformationSheets()){
                if(sheet.CharacterID == characterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.Deleted){
                            continue;
                        }
                        if(invItem.Value.customID == item.customID){
                            CharItem = invItem;
                            //print($"Found our {CharItem.Value.Item_Name}!! its id is {CharItem.Value.customID} ");
                        }
                        if(invItem.Value.customID != item.customID && invItem.Value.EQUIPPED){
                            int tempValue;

    if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
    {
        equippedFort += tempValue;
    }

    if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
    {
        equippedArcana += tempValue;
    }
                        }
                    }
                    foreach(var stat in sheet.CharStatData){
                        if(stat.Key == "currentHP"){
                            cHP = stat.Value;
                        }
                        if(stat.Key == "currentMP"){
                            mHP = stat.Value;
                        }
                        if(stat.Key == "Class"){
                            _class = stat.Value;
                        }
                        if(stat.Key == "LVL"){
                            _level = int.Parse(stat.Value);
                        }
                        if(stat.Key == "CORE"){
                            _core = stat.Value;
                        }
                    }
                }
            }
            int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < sPlayer.GetInformationSheets().Count; _char++){
                            if(sPlayer.GetInformationSheets()[_char].CharacterID == characterSlot){
                                for(int ability = 0; ability < sPlayer.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + PASSIVE_Arcana) / 7;

            string itemSlot = CharItem.Value.EQUIPPEDSLOT;
            sPlayer.RemoveCharacterItem(characterSlot, CharItem);
            CharItem.Value.EQUIPPED = false;
            CharItem.Value.TacticianInventory = true;
            CharItem.Value.EQUIPPEDSLOT = "Unequipped";
            CharItem.Value.Changed = true;
            sPlayer.GetTacticianNewItem(CharItem);
            string finalHPValue = "1";
            string finalMPValue = "1";
            
            if(maxHP < int.Parse(cHP)){
                finalHPValue = maxHP.ToString();
            } else {
                finalHPValue = cHP;
            }
            if(maxMP < int.Parse(mHP)){
                finalMPValue = maxMP.ToString();
            } else {
                finalMPValue = mHP;
            }
            CharacterStatListItem Health = (new CharacterStatListItem {
                Key = "currentHP",
                Value = finalHPValue
            });
            CharacterStatListItem Magic = (new CharacterStatListItem {
                Key = "currentMP",
                Value = finalMPValue
            });
            sPlayer.GetINNServer(characterSlot, Health, Magic);
            
            Match matchRef = null;
            if(sPlayer.currentMatch != null){
                matchRef = sPlayer.currentMatch;
                ChangedGearMessage gearMessage = new ChangedGearMessage(characterSlot, itemSlot, matchRef, false, CharItem.Value);
                charGearChangeMatch.Invoke(gearMessage);
            }
            
            #endif
        }
        //Character To Character
        void CharInvCharInv(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharInvCharInv IDs are item one {item.GetItemName()} and {equippedData.CharacterSlot} is char slot and {item.customID} is our custom ID we are looking for");

            //print("CharInvCharInv");
            string charOneID = equippedData.CharacterSlotOne;;
            string charTwoID = equippedData.CharacterSlotTwo;
            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem CharItem = new CharacterInventoryListItem();
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlotOne){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == item.customID){
                            CharItem = invItem;
                            //print($"Found our {CharItem.Value.Item_Name}!! its id is {CharItem.Value.customID} ");
                            break;
                        }
                    }
                    break;
                }
            }
            stash.RemoveCharacterItem(charOneID, CharItem);
            CharItem.Value.Changed = true;
            stash.GetCharacterNewItem(charTwoID, CharItem);
            #endif                   
        }
        void CharEquipCharInv(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharEquipCharInv IDs are item one {item.GetItemName()} and {equippedData.CharacterSlot} is char slot and {item.customID} is our custom ID we are looking for");

            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterInventoryListItem CharItem = new CharacterInventoryListItem();
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            TacticianFullDataMessage tacticianSheet = sPlayer.GetTacticianSheet();
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);

            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                }
            }
            string cHP = string.Empty;
            string mHP = string.Empty;
            string _class = string.Empty;
            string _core = string.Empty;
            int _level = 1;
            int equippedFort = 0;
            int equippedArcana = 0;
            string charOneID = equippedData.CharacterSlotOne;
            string charTwoID = equippedData.CharacterSlotTwo;
            foreach(var sheet in sPlayer.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlotOne){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.Deleted){
                            continue;
                        }
                        if(invItem.Value.customID == item.customID){
                            CharItem = invItem;
                            //print($"Found our {CharItem.Value.Item_Name}!! its id is {CharItem.Value.customID} ");
                        }
                        if(invItem.Value.customID != item.customID && invItem.Value.EQUIPPED){
                            int tempValue;

    if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
    {
        equippedFort += tempValue;
    }

    if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
    {
        equippedArcana += tempValue;
    }
                        }
                    }
                    foreach(var stat in sheet.CharStatData){
                        if(stat.Key == "currentHP"){
                            cHP = stat.Value;
                        }
                        if(stat.Key == "currentMP"){
                            mHP = stat.Value;
                        }
                        if(stat.Key == "Class"){
                            _class = stat.Value;
                        }
                        if(stat.Key == "LVL"){
                            _level = int.Parse(stat.Value);
                        }
                        if(stat.Key == "CORE"){
                            _core = stat.Value;
                        }
                    }
                }
            }
            int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < sPlayer.GetInformationSheets().Count; _char++){
                            if(sPlayer.GetInformationSheets()[_char].CharacterID == equippedData.CharacterSlotOne){
                                for(int ability = 0; ability < sPlayer.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + PASSIVE_Arcana) / 7;
            string itemSlot = CharItem.Value.EQUIPPEDSLOT;
            sPlayer.RemoveCharacterItem(charOneID, CharItem);
            CharItem.Value.INVENTORY = true;
            CharItem.Value.EQUIPPED = false;
            CharItem.Value.EQUIPPEDSLOT = "Unequipped";
            CharItem.Value.Changed = true;
            sPlayer.GetCharacterNewItem(charTwoID, CharItem);
            string finalHPValue = "1";
            string finalMPValue = "1";
            
            if(maxHP < int.Parse(cHP)){
                finalHPValue = maxHP.ToString();
            } else {
                finalHPValue = cHP;
            }
            if(maxMP < int.Parse(mHP)){
                finalMPValue = maxMP.ToString();
            } else {
                finalMPValue = mHP;
            }
            CharacterStatListItem Health = (new CharacterStatListItem {
                Key = "currentHP",
                Value = finalHPValue
            });
            CharacterStatListItem Magic = (new CharacterStatListItem {
                Key = "currentMP",
                Value = finalMPValue
            });
            sPlayer.GetINNServer(charOneID, Health, Magic);
            Match matchRef = null;
            if(sPlayer.currentMatch != null){
                matchRef = sPlayer.currentMatch;
                ChangedGearMessage gearMessage = new ChangedGearMessage(charOneID, itemSlot, matchRef, false, CharItem.Value);
                charGearChangeMatch.Invoke(gearMessage);
            }
        
            #endif   
        }
        void CharInvCharEquip(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharInvCharEquip IDs are item one {item.GetItemName()} and {equippedData.CharacterSlot} is char slot and {item.customID} is our custom ID we are looking for");

            string charOneID = equippedData.CharacterSlotOne;;
            string charTwoID = equippedData.CharacterSlotTwo;
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterInventoryListItem CharItem = new CharacterInventoryListItem();
            foreach(var sheet in sPlayer.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlotOne){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == item.customID){
                            CharItem = invItem;
                            //print($"Found our {CharItem.Value.Item_Name}!! its id is {CharItem.Value.customID} ");
                            break;
                        }
                    }
                    break;
                }
            }
            sPlayer.RemoveCharacterItem(charOneID, CharItem);
            CharItem.Value.INVENTORY = false;
            CharItem.Value.EQUIPPED = true;
            CharItem.Value.EQUIPPEDSLOT = equippedData.Slot;
            CharItem.Value.Changed = true;
            sPlayer.GetCharacterNewItem(charTwoID, CharItem);
            Match matchRef = null;
            if(sPlayer.currentMatch != null){
                matchRef = sPlayer.currentMatch;
                ChangedGearMessage gearMessage = new ChangedGearMessage(charTwoID, equippedData.Slot, matchRef, true, CharItem.Value);
                charGearChangeMatch.Invoke(gearMessage);
            }
            
            #endif       
        }
        void CharInvEquipSame(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharInvEquipSame  IDs are item one {item.GetItemName()} and {equippedData.CharacterSlot} is char slot and {item.customID} is our custom ID we are looking for");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem CharItem = new CharacterInventoryListItem();
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == item.customID){
                            CharItem = invItem;
                            //print($"Found our {CharItem.Value.Item_Name}!! its id is {CharItem.Value.customID} ");
                            break;
                        }
                    }
                    break;
                }
            }
            stash.RemoveCharacterItem(equippedData.CharacterSlot, CharItem);
            CharItem.Value.INVENTORY = false;
            CharItem.Value.EQUIPPED = true;
            CharItem.Value.Changed = true;
            CharItem.Value.EQUIPPEDSLOT = equippedData.Slot;
            stash.GetCharacterNewItem(equippedData.CharacterSlot, CharItem);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
                ChangedGearMessage gearMessage = new ChangedGearMessage(equippedData.CharacterSlot, equippedData.Slot, matchRef, true, CharItem.Value);
                charGearChangeMatch.Invoke(gearMessage);
            }
            /*
            PlayFabServerAPI.MoveItemToUserFromCharacter( new MoveItemToUserFromCharacterRequest
            {
                CharacterId = equippedData.CharacterSlot,
                ItemInstanceId = item.GetInstanceID(),
                PlayFabId = playerData.PlayFabId,
            }, result =>
            {
               PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
                {
                    ItemInstanceId = item.GetInstanceID(),
                    PlayFabId = playerData.PlayFabId,
                    Data = new Dictionary<string, string>
                        {
                            {"EquippedSlot", equippedData.Slot}
                        }
                }, result =>
                {
                    PlayFabServerAPI.MoveItemToCharacterFromUser( new MoveItemToCharacterFromUserRequest
                    {
                        CharacterId = equippedData.CharacterSlot,
                        ItemInstanceId = item.GetInstanceID(),
                        PlayFabId = playerData.PlayFabId,
                    }, result =>
                    {
                        //print($"{item.GetItemName()} belongs to {item.GetOwnerID()}");
                    }, error =>{
                        Debug.Log(error.ErrorMessage);
                    });
                    //print("moved and doneskies");
                }, error =>{
                    Debug.Log(error.ErrorMessage);
                });
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });         
            */
            #endif          
        }
        void SampleOfPFMoveKEEPTHIS(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
            {
                ItemInstanceId = item.GetInstanceID(),
                PlayFabId = playerData.PlayFabId,
                Data = new Dictionary<string, string>
                    {
                        {"TactStash", null}, {"TactInventory", "InventoryItem"}
                    }
            }, result =>
            {
                //print("moved and doneskies");
                 PlayFabServerAPI.MoveItemToUserFromCharacter( new MoveItemToUserFromCharacterRequest
                    {
                        CharacterId = item.GetOwnerID(),//charOneID,
                        ItemInstanceId = item.GetInstanceID(),
                        PlayFabId = playerData.PlayFabId,

                    }, result =>
                    {
                       PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
                        {
                            ItemInstanceId = item.GetInstanceID(),
                            PlayFabId = playerData.PlayFabId,
                            Data = new Dictionary<string, string>
                                {
                                    {"TactInventory", "InventoryItem"}
                                }
                        }, result =>
                        {
                            PlayFabServerAPI.MoveItemToCharacterFromUser( new MoveItemToCharacterFromUserRequest
                            {
                                CharacterId = item.GetOwnerID(),
                                ItemInstanceId = item.GetInstanceID(),
                                PlayFabId = playerData.PlayFabId,
                            }, result =>
                            {
                                //print($"{item.GetItemName()} belongs to {item.GetOwnerID()}");
                            }, error =>{
                                Debug.Log(error.ErrorMessage);
                            });
                            //print("moved and doneskies");
                        }, error =>{
                            Debug.Log(error.ErrorMessage);
                        });
                    }, error =>{
                        Debug.Log(error.ErrorMessage);
                    });
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void CharEquipEquipSame(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharEquipEquipSame  IDs are item one {item.GetItemName()} and {equippedData.CharacterSlot} is char slot and {item.customID} is our custom ID we are looking for");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem CharItem = new CharacterInventoryListItem();
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == item.customID){
                            CharItem = invItem;
                            //print($"Found our {CharItem.Value.Item_Name}!! its id is {CharItem.Value.customID} ");
                            break;
                        }
                    }
                    break;
                }
            }
            CharItem.Value.EQUIPPEDSLOT = equippedData.Slot;
            CharItem.Value.Changed = true;
            stash.GetCharacterNewItem(equippedData.CharacterSlot, CharItem);
            /*
            PlayFabServerAPI.MoveItemToUserFromCharacter( new MoveItemToUserFromCharacterRequest
            {
                CharacterId = equippedData.CharacterSlot,
                ItemInstanceId = item.GetInstanceID(),
                PlayFabId = playerData.PlayFabId,
            }, result =>
            {
               PlayFabServerAPI.UpdateUserInventoryItemCustomData( new UpdateUserInventoryItemDataRequest
                {
                    ItemInstanceId = item.GetInstanceID(),
                    PlayFabId = playerData.PlayFabId,
                    Data = new Dictionary<string, string>
                        {
                            {"EquippedSlot", equippedData.Slot}
                        }
                }, result =>
                {
                    PlayFabServerAPI.MoveItemToCharacterFromUser( new MoveItemToCharacterFromUserRequest
                    {
                        CharacterId = equippedData.CharacterSlot,
                        ItemInstanceId = item.GetInstanceID(),
                        PlayFabId = playerData.PlayFabId,
                    }, result =>
                    {
                        //print($"{item.GetItemName()} belongs to {item.GetOwnerID()}");
                    }, error =>{
                        Debug.Log(error.ErrorMessage);
                    });
                    //print("moved and doneskies");
                }, error =>{
                    Debug.Log(error.ErrorMessage);
                });
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });    
            */
            #endif
        }
        void CharEquipCharEquip(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharEquipCharEquip  IDs are item one {item.GetItemName()} and {equippedData.CharacterSlot} is char slot and {item.customID} is our custom ID we are looking for");

            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterInventoryListItem CharItem = new CharacterInventoryListItem();
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            TacticianFullDataMessage tacticianSheet = sPlayer.GetTacticianSheet();
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);

            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                }
            }
            string cHP = string.Empty;
            string mHP = string.Empty;
            string _class = string.Empty;
            string _core = string.Empty;
            int _level = 1;
            int equippedFort = 0;
            int equippedArcana = 0;
            string charOneID = equippedData.CharacterSlotOne;
            string charTwoID = equippedData.CharacterSlotTwo;
            foreach(var sheet in sPlayer.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlotOne){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.Deleted){
                            continue;
                        }
                        if(invItem.Value.customID == item.customID){
                            CharItem = invItem;
                            //print($"Found our {CharItem.Value.Item_Name}!! its id is {CharItem.Value.customID} ");
                        }
                        if(invItem.Value.customID != item.customID && invItem.Value.EQUIPPED){
                            int tempValue;

    if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
    {
        equippedFort += tempValue;
    }

    if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
    {
        equippedArcana += tempValue;
    }
                        }
                    }
                    foreach(var stat in sheet.CharStatData){
                        if(stat.Key == "currentHP"){
                            cHP = stat.Value;
                        }
                        if(stat.Key == "currentMP"){
                            mHP = stat.Value;
                        }
                        if(stat.Key == "Class"){
                            _class = stat.Value;
                        }
                        if(stat.Key == "LVL"){
                            _level = int.Parse(stat.Value);
                        }
                        if(stat.Key == "CORE"){
                            _core = stat.Value;
                        }
                    }
                }
            }
            int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < sPlayer.GetInformationSheets().Count; _char++){
                            if(sPlayer.GetInformationSheets()[_char].CharacterID == equippedData.CharacterSlotOne){
                                for(int ability = 0; ability < sPlayer.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + PASSIVE_Arcana) / 7;
            
            sPlayer.RemoveCharacterItem(charOneID, CharItem);
            CharItem.Value.EQUIPPEDSLOT = equippedData.Slot;
            CharItem.Value.Changed = true;
            sPlayer.GetCharacterNewItem(charTwoID, CharItem);
            string finalHPValue = "1";
            string finalMPValue = "1";
            
            if(maxHP < int.Parse(cHP)){
                finalHPValue = maxHP.ToString();
            } else {
                finalHPValue = cHP;
            }
            if(maxMP < int.Parse(mHP)){
                finalMPValue = maxMP.ToString();
            } else {
                finalMPValue = mHP;
            }
            CharacterStatListItem Health = (new CharacterStatListItem {
                Key = "currentHP",
                Value = finalHPValue
            });
            CharacterStatListItem Magic = (new CharacterStatListItem {
                Key = "currentMP",
                Value = finalMPValue
            });
            sPlayer.GetINNServer(charOneID, Health, Magic);
            Match matchRef = null;
            if(sPlayer.currentMatch != null){
                matchRef = sPlayer.currentMatch;
                ChangedGearMessage gearMessageOne = new ChangedGearMessage(charOneID, equippedData.Slot, matchRef, false, item);
                ChangedGearMessage gearMessageTwo = new ChangedGearMessage(charTwoID, equippedData.Slot, matchRef, true, CharItem.Value);
                charGearChangeMatch.Invoke(gearMessageOne);
                charGearChangeMatch.Invoke(gearMessageTwo);
            }
            
            #endif 
        }
        void CharEquipInvSame(NetworkConnectionToClient nconn, ItemSelectable item, PlayerInfo playerData, EquippingData equippedData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharEquipInvSame  IDs are item one {item.GetItemName()} and {equippedData.CharacterSlot} is char slot and {item.customID} is our custom ID we are looking for");

            //print("Starting it up CharEquipInvSame");
            //print($"{equippedData.CharacterSlot} is the char equip data");
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterInventoryListItem CharItem = new CharacterInventoryListItem();
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            TacticianFullDataMessage tacticianSheet = sPlayer.GetTacticianSheet();
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);

            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                }
            }
            string cHP = string.Empty;
            string mHP = string.Empty;
            string _class = string.Empty;
            string _core = string.Empty;
            int _level = 1;
            int equippedFort = 0;
            int equippedArcana = 0;
            string charOneID = equippedData.CharacterSlot;
            foreach(var sheet in sPlayer.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlot){
                            //print($"CharacterID {charOneID} found processing inventory data");

                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.Deleted){
                            continue;
                        }
                           // print($"Item processing {invItem.Value.Item_Name}!! its id is {invItem.Value.customID}");

                        if(invItem.Value.customID == item.customID){
                            CharItem = invItem;
                            ////print($"Found our {CharItem.Value.Item_Name}!! its id is {CharItem.Value.customID} ");
                        }
                        if(invItem.Value.customID != item.customID && invItem.Value.EQUIPPED){
                            //print($"Item {invItem.Value.Item_Name}!! its id is {invItem.Value.customID} check values now to see if we need to modify");

                            int tempValue;

                            if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
                            {
                                equippedFort += tempValue;
                            }

                            if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
                            {
                                equippedArcana += tempValue;
                            }
                        }
                    }
                    foreach(var stat in sheet.CharStatData){
                        if(stat.Key == "currentHP"){
                            cHP = stat.Value;
                        }
                        if(stat.Key == "currentMP"){
                            mHP = stat.Value;
                        }
                        if(stat.Key == "Class"){
                            _class = stat.Value;
                        }
                        if(stat.Key == "LVL"){
                            _level = int.Parse(stat.Value);
                        }
                        if(stat.Key == "CORE"){
                            _core = stat.Value;
                        }
                    }
                }
            }
            int PASSIVE_Arcana = 0;
            int PASSIVE_Fortitude = 0;
            for(int _char = 0; _char < sPlayer.GetInformationSheets().Count; _char++){
                if(sPlayer.GetInformationSheets()[_char].CharacterID == equippedData.CharacterSlot){
                    for(int ability = 0; ability < sPlayer.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                        if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                            var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                            if (abilityRankString.Success) {
                                int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                PASSIVE_Fortitude = abilityRank;
                            }
                        }
                        if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                            var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                            if (abilityRankString.Success) {
                                int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                PASSIVE_Arcana = abilityRank;
                            }
                        }
                    }
                    break;
                }
            }
            (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
            int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + PASSIVE_Fortitude;
            int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + PASSIVE_Arcana) / 7;
            string itemSlot = CharItem.Value.EQUIPPEDSLOT;
            sPlayer.RemoveCharacterItem(equippedData.CharacterSlot, CharItem);
            CharItem.Value.EQUIPPEDSLOT = "Unequipped";
            CharItem.Value.EQUIPPED = false;
            CharItem.Value.INVENTORY = true;
            CharItem.Value.Changed = true;
            //print($"Part 3 equip to inv same, {CharItem.Value.EQUIPPEDSLOT} is equipped slot");
            sPlayer.GetCharacterNewItem(equippedData.CharacterSlot, CharItem);
            string finalHPValue = "1";
            string finalMPValue = "1";
            
            if(maxHP < int.Parse(cHP)){
                finalHPValue = maxHP.ToString();
            } else {
                finalHPValue = cHP;
            }
            if(maxMP < int.Parse(mHP)){
                finalMPValue = maxMP.ToString();
            } else {
                finalMPValue = mHP;
            }
            CharacterStatListItem Health = (new CharacterStatListItem {
                Key = "currentHP",
                Value = finalHPValue
            });
            CharacterStatListItem Magic = (new CharacterStatListItem {
                Key = "currentMP",
                Value = finalMPValue
            });
            sPlayer.GetINNServer(charOneID, Health, Magic);
            
            Match matchRef = null;
            if(sPlayer.currentMatch != null){
                matchRef = sPlayer.currentMatch;
                ChangedGearMessage gearMessage = new ChangedGearMessage(equippedData.CharacterSlot, itemSlot, matchRef, false, item);
                charGearChangeMatch.Invoke(gearMessage);
            }
            #endif
        }
        void CharUnequipCharEquipOneSendTwo(NetworkConnectionToClient nconn, ItemSelectable itemOne, ItemSelectable itemTwo, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharUnequipCharEquipSame  IDs are item one {itemOne.GetItemName()}, item two {itemTwo.GetItemName()} {equippedData.CharacterSlot} is char slot");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem CharItemOne = new CharacterInventoryListItem();
            CharacterInventoryListItem CharItemTwo = new CharacterInventoryListItem();
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlotOne){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == itemOne.customID){
                            CharItemOne = invItem;
                            ////print($"Found our item one !! its id is {CharItemOne.Value.customID}");
                            break;
                        }
                    }
                }
                if(sheet.CharacterID == equippedData.CharacterSlotTwo){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == itemTwo.customID){
                            CharItemTwo = invItem;
                            //print($"Found our item Two !! its id is {CharItemTwo.Value.customID}");
                            break;
                        }
                    }
                }

            }
            
            CharItemOne.Value.EQUIPPEDSLOT = "Unequipped";
            CharItemOne.Value.EQUIPPED = false;
            CharItemOne.Value.INVENTORY = true;
            CharItemOne.Value.Changed = true;
            stash.GetCharacterNewItem(equippedData.CharacterSlotTwo, CharItemOne);
            CharItemTwo.Value.EQUIPPEDSLOT = equippedData.Slot;
            CharItemTwo.Value.EQUIPPED = true;
            CharItemTwo.Value.Changed = true;
            CharItemTwo.Value.INVENTORY = false;
            stash.GetCharacterNewItem(equippedData.CharacterSlotOne, CharItemTwo);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
                ChangedGearMessage gearMessageOne = new ChangedGearMessage(equippedData.CharacterSlotOne, equippedData.Slot, matchRef, false, itemOne);
                ChangedGearMessage gearMessageTwo = new ChangedGearMessage(equippedData.CharacterSlotOne, equippedData.Slot, matchRef, true, CharItemTwo.Value);
                charGearChangeMatch.Invoke(gearMessageOne);
                charGearChangeMatch.Invoke(gearMessageTwo);
            }
            
            #endif
        }
        void CharUnequipCharEquipTwoSendOne(NetworkConnectionToClient nconn, ItemSelectable itemOne, ItemSelectable itemTwo, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharUnequipCharEquipSame  IDs are item one {itemOne.GetItemName()}, item two {itemTwo.GetItemName()} {equippedData.CharacterSlot} is char slot");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem CharItemOne = new CharacterInventoryListItem();
            CharacterInventoryListItem CharItemTwo = new CharacterInventoryListItem();
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlotTwo){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == itemOne.customID){
                            CharItemOne = invItem;
                            ////print($"Found our item one !! its id is {CharItemOne.Value.customID}");
                            break;
                        }
                    }
                }
                if(sheet.CharacterID == equippedData.CharacterSlotOne){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == itemTwo.customID){
                            CharItemTwo = invItem;
                           // print($"Found our item Two !! its id is {CharItemTwo.Value.customID}");
                            break;
                        }
                    }
                }

            }
            
            CharItemOne.Value.EQUIPPEDSLOT = "Unequipped";
            CharItemOne.Value.EQUIPPED = false;
            CharItemOne.Value.INVENTORY = true;
            CharItemOne.Value.Changed = true;
            stash.GetCharacterNewItem(equippedData.CharacterSlotOne, CharItemOne);
            CharItemTwo.Value.EQUIPPEDSLOT = equippedData.Slot;
            CharItemTwo.Value.EQUIPPED = true;
            CharItemTwo.Value.Changed = true;
            CharItemTwo.Value.INVENTORY = false;
            stash.GetCharacterNewItem(equippedData.CharacterSlotTwo, CharItemTwo);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
                ChangedGearMessage gearMessageOne = new ChangedGearMessage(equippedData.CharacterSlotOne, equippedData.Slot, matchRef, false, itemOne);
                ChangedGearMessage gearMessageTwo = new ChangedGearMessage(equippedData.CharacterSlotTwo, equippedData.Slot, matchRef, true, CharItemTwo.Value);
                charGearChangeMatch.Invoke(gearMessageOne);
                charGearChangeMatch.Invoke(gearMessageTwo);
            }
            
            #endif
        }
        void CharUnequipCharEquipSame(NetworkConnectionToClient nconn, ItemSelectable itemOne, ItemSelectable itemTwo, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharUnequipCharEquipSame  IDs are item one {itemOne.GetItemName()}, item two {itemTwo.GetItemName()} {equippedData.CharacterSlot} is char slot");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem CharItemOne = new CharacterInventoryListItem();
            CharacterInventoryListItem CharItemTwo = new CharacterInventoryListItem();
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == itemOne.customID){
                            CharItemOne = invItem;
                            //print($"Found our item one !! its id is {CharItemOne.Value.customID}");
                        }
                        if(invItem.Value.customID == itemTwo.customID){
                            CharItemTwo = invItem;
                            //print($"Found our item one !! its id is {CharItemTwo.Value.customID}");
                        }
                    }
                }
            }
            
            CharItemOne.Value.EQUIPPEDSLOT = "Unequipped";
            CharItemOne.Value.EQUIPPED = false;
            CharItemOne.Value.INVENTORY = true;
            CharItemOne.Value.Changed = true;
            stash.GetCharacterNewItem(equippedData.CharacterSlot, CharItemOne);
            CharItemTwo.Value.EQUIPPEDSLOT = equippedData.Slot;
            CharItemTwo.Value.EQUIPPED = true;
            CharItemTwo.Value.Changed = true;
            CharItemTwo.Value.INVENTORY = false;
            stash.GetCharacterNewItem(equippedData.CharacterSlot, CharItemTwo);
            Match matchRef = null;
            if(stash.currentMatch != null){
                matchRef = stash.currentMatch;
                ChangedGearMessage gearMessageOne = new ChangedGearMessage(equippedData.CharacterSlot, equippedData.Slot, matchRef, false, itemOne);
                ChangedGearMessage gearMessageTwo = new ChangedGearMessage(equippedData.CharacterSlot, equippedData.Slot, matchRef, true, CharItemTwo.Value);
                charGearChangeMatch.Invoke(gearMessageOne);
                charGearChangeMatch.Invoke(gearMessageTwo);
            }
            //charGearChangeMatch.Invoke(false, equippedData.CharacterSlot, matchRef, itemOne);
            //charGearChangeMatch.Invoke(true, equippedData.CharacterSlot, matchRef, CharItemTwo.Value);

            
            #endif
        }
        /*
        void CharUnequipCharEquipSendTactStash(NetworkConnectionToClient nconn, string itemOne, string itemTwo, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharUnequipCharEquipSendTactStash  IDs are item one {itemOne}, item two {itemTwo} {equippedData.CharacterSlot} is char slot, {equippedData.Slot} is the slot");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem CharItemOne = new CharacterInventoryListItem();
            CharacterInventoryListItem CharItemTwo = new CharacterInventoryListItem();
            print($"CharUnequipCharEquipSendTactStash pos 1, IDs are item one {itemOne}, item two {itemTwo} {equippedData.CharacterSlot} is char slot, {equippedData.Slot} is the slot");
            if(equippedData.CharacterSlotOne == "Stash"){
                foreach(var invItem in stash.GetTacticianSheet().StashInventoryData){
                    if(invItem.Value.customID == itemTwo){
                        CharItemOne = invItem;
                        print($"Found our item two !! its id is {CharItemOne.Value.customID}");

                    }
                }
            }
            if(equippedData.CharacterSlotOne == "Tactician"){
                foreach(var invItem in stash.GetTacticianSheet().TacticianInventoryData){
                    if(invItem.Value.customID == itemTwo){
                        CharItemOne = invItem;
                        print($"Found our item two !! its id is {CharItemOne.Value.customID}");

                    }
                }
            }
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == itemOne){
                            CharItemTwo = invItem;
                            //print($"Found our item one !! its id is {CharItemTwo.Value.customID}");
                        }
                    }
                }
            }
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            TacticianFullDataMessage tacticianSheet = stash.GetTacticianSheet();
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);

            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                }
            }
            string cHP = string.Empty;
            string mHP = string.Empty;
            string _class = string.Empty;
            string _core = string.Empty;
            int _level = 1;
            int equippedFort = 0;
            int equippedArcana = 0;
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.Deleted){
                            continue;
                        }
                        
                        if(invItem.Value.customID != CharItemTwo.Value.customID && invItem.Value.EQUIPPED){
                            int tempValue;

    if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
    {
        equippedFort += tempValue;
    }

    if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
    {
        equippedArcana += tempValue;
    }
                        }
                    }
                    foreach(var stat in sheet.CharStatData){
                        if(stat.Key == "currentHP"){
                            cHP = stat.Value;
                        }
                        if(stat.Key == "currentMP"){
                            mHP = stat.Value;
                        }
                        if(stat.Key == "Class"){
                            _class = stat.Value;
                        }
                        if(stat.Key == "LVL"){
                            _level = int.Parse(stat.Value);
                        }
                        if(stat.Key == "CORE"){
                            _core = stat.Value;
                        }
                    }
                }
            }
            (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
            int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude;
            int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana) / 7;
            print($"Removing character item {CharItemTwo.Value.GetItemName()} from inventory");
            stash.RemoveCharacterItem(equippedData.CharacterSlot, CharItemTwo);
            CharItemTwo.Value.TacticianStash = equippedData.Stash;
            CharItemTwo.Value.TacticianInventory = equippedData.TactInv;
            CharItemTwo.Value.TacticianBelt = equippedData.TactBelt;
            CharItemTwo.Value.EQUIPPEDSLOT = "Unequipped";
            CharItemTwo.Value.EQUIPPED = false;
            CharItemTwo.Value.INVENTORY = false;
            CharItemTwo.Value.Changed = true;
            print("CharUnequipCharEquipSendTactStash pos 2");
            print($"Removing {equippedData.CharacterSlotOne} item from inventory");

            if(equippedData.CharacterSlotOne == "Stash"){
                stash.GetStashRemoveItem(CharItemOne);
                stash.GetStashNewItem(CharItemTwo);
            }
            if(equippedData.CharacterSlotOne == "Tactician"){
                stash.GetTacticianRemoveItem(CharItemOne);
                stash.GetTacticianNewItem(CharItemTwo);
            }
            print("CharUnequipCharEquipSendTactStash pos 3");

            CharItemOne.Value.EQUIPPEDSLOT = equippedData.Slot;
            CharItemOne.Value.EQUIPPED = true;
            CharItemOne.Value.Changed = true;
            CharItemOne.Value.INVENTORY = false;
            stash.GetCharacterNewItem(equippedData.CharacterSlot, CharItemOne);
            string finalHPValue = "1";
            string finalMPValue = "1";
            
            if(maxHP < int.Parse(cHP)){
                finalHPValue = maxHP.ToString();
            } else {
                finalHPValue = cHP;
            }
            if(maxMP < int.Parse(mHP)){
                finalMPValue = maxMP.ToString();
            } else {
                finalMPValue = mHP;
            }
            CharacterStatListItem Health = (new CharacterStatListItem {
                Key = "currentHP",
                Value = finalHPValue
            });
            CharacterStatListItem Magic = (new CharacterStatListItem {
                Key = "currentMP",
                Value = finalMPValue
            });
            stash.GetINNServer(equippedData.CharacterSlot, Health, Magic);
            #endif
        }
        */
        void CharUnequipCharEquipSendTactStash(NetworkConnectionToClient nconn, string itemOne, string itemTwo, PlayerInfo playerData, EquippingData equippedData ){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print($"{playerData.PlayFabId} REQUESTED CharUnequipCharEquipSendTactStash  IDs are item one {itemOne}, item two {itemTwo} {equippedData.CharacterSlot} is char slot, {equippedData.Slot} is the slot");

            ScenePlayer stash = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(stash == null){
                return;
            }
            CharacterInventoryListItem CharItemOne = new CharacterInventoryListItem();
            CharacterInventoryListItem CharItemTwo = new CharacterInventoryListItem();
            print($"CharUnequipCharEquipSendTactStash pos 1, IDs are item one {itemOne}, item two {itemTwo} {equippedData.CharacterSlot} is char slot, {equippedData.Slot} is the slot");
            if(equippedData.CharacterSlotOne == "Stash"){
                foreach(var invItem in stash.GetTacticianSheet().StashInventoryData){
                    if(invItem.Value.customID == itemTwo){
                        CharItemOne = invItem;
                        print($"Found our item two !! its id is {CharItemOne.Value.customID}");

                    }
                }
            }
            if(equippedData.CharacterSlotOne == "Tactician"){
                foreach(var invItem in stash.GetTacticianSheet().TacticianInventoryData){
                    if(invItem.Value.customID == itemTwo){
                        CharItemOne = invItem;
                        print($"Found our item two !! its id is {CharItemOne.Value.customID}");

                    }
                }
            }
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.customID == itemOne){
                            CharItemTwo = invItem;
                            //print($"Found our item one !! its id is {CharItemTwo.Value.customID}");
                        }
                    }
                }
            }
            int tacticianBonusFortitude = 0;
            int tacticianBonusArcana = 0;
            TacticianFullDataMessage tacticianSheet = stash.GetTacticianSheet();
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);

            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                }
            }
            string cHP = string.Empty;
            string mHP = string.Empty;
            string _class = string.Empty;
            string _core = string.Empty;
            int _level = 1;
            int equippedFort = 0;
            int equippedArcana = 0;
            foreach(var sheet in stash.GetInformationSheets()){
                if(sheet.CharacterID == equippedData.CharacterSlot){
                    foreach(var invItem in sheet.CharInventoryData){
                        if(invItem.Value.Deleted){
                            continue;
                        }
                        
                        if(invItem.Value.customID != CharItemTwo.Value.customID && invItem.Value.EQUIPPED){
                            int tempValue;

    if (invItem.Value.GetFORTITUDE_item() != null && int.TryParse(invItem.Value.GetFORTITUDE_item(), out tempValue))
    {
        equippedFort += tempValue;
    }

    if (invItem.Value.GetARCANA_item() != null && int.TryParse(invItem.Value.GetARCANA_item(), out tempValue))
    {
        equippedArcana += tempValue;
    }
                        }
                    }
                    foreach(var stat in sheet.CharStatData){
                        if(stat.Key == "currentHP"){
                            cHP = stat.Value;
                        }
                        if(stat.Key == "currentMP"){
                            mHP = stat.Value;
                        }
                        if(stat.Key == "Class"){
                            _class = stat.Value;
                        }
                        if(stat.Key == "LVL"){
                            _level = int.Parse(stat.Value);
                        }
                        if(stat.Key == "CORE"){
                            _core = stat.Value;
                        }
                    }
                }
            }
            int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < stash.GetInformationSheets().Count; _char++){
                            if(stash.GetInformationSheets()[_char].CharacterID == equippedData.CharacterSlot){
                                for(int ability = 0; ability < stash.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(stash.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(stash.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(stash.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(stash.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equippedFort + tacticianBonusFortitude + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equippedArcana + tacticianBonusArcana + PASSIVE_Arcana) / 7;
            print($"Removing character item {CharItemTwo.Value.GetItemName()} from inventory");
            stash.RemoveCharacterItem(equippedData.CharacterSlot, CharItemTwo);
            CharItemTwo.Value.TacticianStash = equippedData.Stash;
            CharItemTwo.Value.TacticianInventory = equippedData.TactInv;
            CharItemTwo.Value.TacticianBelt = equippedData.TactBelt;
            CharItemTwo.Value.EQUIPPEDSLOT = "Unequipped";
            CharItemTwo.Value.EQUIPPED = false;
            CharItemTwo.Value.INVENTORY = false;
            CharItemTwo.Value.Changed = true;
            print("CharUnequipCharEquipSendTactStash pos 2");
            print($"Removing {equippedData.CharacterSlotOne} item from inventory");

            if(equippedData.CharacterSlotOne == "Stash"){
                stash.GetStashRemoveItem(CharItemOne);
                stash.GetStashNewItem(CharItemTwo);
            }
            if(equippedData.CharacterSlotOne == "Tactician"){
                stash.GetTacticianRemoveItem(CharItemOne);
                stash.GetTacticianNewItem(CharItemTwo);
            }
            print("CharUnequipCharEquipSendTactStash pos 3");
            CharItemOne.Value.TacticianStash = false;
            CharItemOne.Value.TacticianInventory = false;
            CharItemOne.Value.TacticianBelt = false;
            CharItemOne.Value.EQUIPPEDSLOT = equippedData.Slot;
            CharItemOne.Value.EQUIPPED = true;
            CharItemOne.Value.Changed = true;
            CharItemOne.Value.INVENTORY = false;
            stash.GetCharacterNewItem(equippedData.CharacterSlot, CharItemOne);
            string finalHPValue = "1";
            string finalMPValue = "1";
            
            if(maxHP < int.Parse(cHP)){
                finalHPValue = maxHP.ToString();
            } else {
                finalHPValue = cHP;
            }
            if(maxMP < int.Parse(mHP)){
                finalMPValue = maxMP.ToString();
            } else {
                finalMPValue = mHP;
            }
            CharacterStatListItem Health = (new CharacterStatListItem {
                Key = "currentHP",
                Value = finalHPValue
            });
            CharacterStatListItem Magic = (new CharacterStatListItem {
                Key = "currentMP",
                Value = finalMPValue
            });
            stash.GetINNServer(equippedData.CharacterSlot, Health, Magic);
            #endif
        }
        void EndDuel(Match match, TurnManager curatorTM){

            List<ScenePlayer> players = curatorTM.GetPlayers();
            WipeoutMatch(match, players);
        }
        void CharacterDied(NetworkConnectionToClient nconn, string ID, TurnManager curatorTM){
            #if UNITY_SERVER //|| UNITY_EDITOR
            
            if(!CheckNullConnection(nconn)){
                return;
            }
            if(curatorTM.GetDuelMode()){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED CharacterDied {ID}");
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterStatListItem Death = (new CharacterStatListItem{
                Key = "DEATH",
                Value = DateTime.Now.ToString()
            });
            CharacterStatListItem EXPStat = (new CharacterStatListItem{
                Key = "EXP",
                Value = "0"
            });
            float EXP = 0f;
            foreach(var sheet in sPlayer.GetInformationSheets()){
                if(sheet.CharacterID == ID){
                    foreach(var stat in sheet.CharStatData){
                        if(stat.Key == "EXP"){
                            EXP = float.Parse(stat.Value);
                            break;
                        }
                    }
                }
            }
            // Reduce EXP by 10%
            EXP *= 0.9f;
            EXPStat.Value = EXP.ToString("F2");
            sPlayer.GetDEATHCHARACTER(ID, Death, EXPStat);
            List<CharacterInventoryListItem> DurabilityLossItems = new List<CharacterInventoryListItem>();
            for(int x = 0; x < sPlayer.GetInformationSheets().Count; x++){
                if(sPlayer.GetInformationSheets()[x].CharacterID == ID){
                    var validIndices = sPlayer.GetInformationSheets()[x].CharInventoryData
                    .Select((item, index) => new { Item = item, Index = index })
                    .Where(x => x.Item.Value.NFT == false && x.Item.Value.EQUIPPED == true 
                                && x.Item.Value.itemType != ItemSelectable.ItemType.PotionT1 
                                && x.Item.Value.itemType != ItemSelectable.ItemType.PotionT2
                                && x.Item.Value.itemType != ItemSelectable.ItemType.FoodT1 
                                && x.Item.Value.itemType != ItemSelectable.ItemType.CharacterBag 
                                && x.Item.Value.itemType != ItemSelectable.ItemType.TacticianBag
                                && x.Item.Value.Durability != "0")
                    .Select(x => x.Index)
                    .ToList();
                    if (validIndices.Count > 0) {
                        for(int v = 0; v < validIndices.Count; v++){
                            CharacterInventoryListItem damagedItem = (new CharacterInventoryListItem{
                                Key = "LuckyRoll"
                            });
                                // Access and modify the item directly in the original list
                                 int index = validIndices[v];
                                // Access and modify the item directly in the original list
                                var itemToModify = sPlayer.GetInformationSheets()[x].CharInventoryData[index];
                                string dura = itemToModify.Value.Durability;
                                float durability;
                                if (!float.TryParse(dura, out durability)) {
                                    durability = 100f; // Default to 100 if parsing fails
                                }
                                durability = Math.Max(0, durability - 20); // Ensure durability doesn't go below 0
                                dura = durability.ToString();
                                // Since itemToModify is a copy, we need to update the list directly
                                damagedItem = itemToModify;
                                damagedItem.Value.Durability = dura;
                                damagedItem.Value.Changed = true; // Mark the item as changed
                                DurabilityLossItems.Add(damagedItem);
                                if(dura == "0"){
                                    ChangedGearMessage gearMessage = new ChangedGearMessage(ID, damagedItem.Value.EQUIPPEDSLOT, sPlayer.currentMatch, false, damagedItem.Value);
                                    charGearChangeMatch.Invoke(gearMessage);
                                }
                        }
                    }
                    break;
                }
            }
            for(int y = 0; y < DurabilityLossItems.Count; y++){
                sPlayer.GetCharacterUpdateDuraDeath(ID, DurabilityLossItems[y]);

            }
            
            //PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
            //{
            //    PlayFabId = playerData.PlayFabId,
            //    CharacterId = ID,
            //    Data = new Dictionary<string, string>
            //    {
            //        {"DEATH", Death.Value}, {"currentHP", "0"}, {"EXP", EXPStat.Value}, {"currentMP", "0"}
            //    }
            //}, result =>
            //{
            //    
            //    sPlayer.GetDEATHCHARACTER(ID, Death, EXPStat);
            //}, error =>{
            //    Debug.Log(error.ErrorMessage); 
            //    Debug.Log(error.ErrorDetails);
            //    Debug.Log(error.Error);
            //});
            #endif
        }
        void SaveGame(NetworkConnectionToClient nconn, CharacterSaveData savingData){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED SaveGame");
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            print($"SavedGame is beginnning for this char ID {savingData.CharID}");
            sPlayer.GetSavedGame(savingData);

            //PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
            //{
            //    PlayFabId = playerData.PlayFabId,
            //    CharacterId = savingData.CharID,
            //    Data = new Dictionary<string, string>
            //    {
            //        {"currentHP", savingData.CharHealth.ToString()}, {"currentMP", savingData.CharMana.ToString()}, {"EXP", savingData.CharExperience.ToString("F2")}, {"ClassPoints", savingData.CharClassPoints.ToString("F2")}
            //    }
            //}, result =>
            //{
            //    sPlayer.GetSavedGame(savingData);
            //    print($"SavedGame is ending for this char ID {savingData.CharID}");
            //}, error =>{
            //    Debug.Log(error.ErrorMessage); 
            //    Debug.Log(error.ErrorDetails);
            //    Debug.Log(error.Error);
            //});
            #endif
        }
        void RessurectedCharacterCombat(NetworkConnectionToClient nconn, string ID, string hp, string mp){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED RessurectedCharacterCombat");
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterStatListItem Health = (new CharacterStatListItem{
                Key = "currentHP",
                Value = hp
            });
            CharacterStatListItem Mana = (new CharacterStatListItem{
                Key = "currentMP",
                Value = mp
            });
            sPlayer.ServerResurrectCharacterCombat(ID, Health, Mana);
            #endif
        }
        void ResCharacterServer(NetworkConnectionToClient nconn, string ID){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED ResCharacterServer");
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            int _lvl = 1;
            foreach(var sheet in sPlayer.GetInformationSheets()){
                if(sheet.CharacterID == ID){
                    foreach(var stat in sheet.CharStatData){
                        if(stat.Key == "LVL"){
                            _lvl = int.Parse(stat.Value);
                        }
                    }
                }
            }
            int amountDueNow = sPlayer.GetCharacterResCost(_lvl);
            if((long)amountDueNow <= sPlayer.Gold){
                sPlayer.Gold -= (long)amountDueNow;
                CharacterStatListItem Health = (new CharacterStatListItem{
                        Key = "currentHP",
                        Value = "1"
                    });
                sPlayer.ServerResurrectCharacter(ID, Health);
                StartCoroutine(ReScanWallet(sPlayer));
                //PlayFabServerAPI.SubtractUserVirtualCurrency(new SubtractUserVirtualCurrencyRequest
                //{
                //    PlayFabId = playerData.PlayFabId,
                //    Amount = amountDueNow,
                //    VirtualCurrency = "DK"
                //}, result =>
                //{
                //        //stash.GoldAmountSet(nAmount);
                //    sPlayer.TargetWalletAwake();
                //    CharacterStatListItem Health = (new CharacterStatListItem{
                //        Key = "currentHP",
                //        Value = "1"
                //    });
                //    PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
                //    {
                //        PlayFabId = playerData.PlayFabId,
                //        CharacterId = ID,
                //        Data = new Dictionary<string, string>
                //        {
                //            {"currentHP", Health.Value}, {"DEATH", null}
                //        }
                //    }, result =>
                //    {
                //        sPlayer.ServerResurrectCharacter(ID, Health);
                //        sPlayer.TargetWalletAwake();
                //    }, error =>{
                //        Debug.Log(error.ErrorMessage); 
                //        Debug.Log(error.ErrorDetails);
                //        Debug.Log(error.Error);
                //    });
                //    //print($"Client paid for res in the amount of DK coins:{amountDueNow}");
                //}, error =>{
                //    Debug.Log(error.ErrorMessage);
                //});
            }
            #endif
            
        }
        IEnumerator ReScanWallet(ScenePlayer sPlayer){
            yield return new WaitForSeconds(1f);
            sPlayer.TargetWalletAwake();
        }
        void CharacterTakingDamage(NetworkConnectionToClient nconn, int newcurHP, string ID){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterStatListItem Health = (new CharacterStatListItem{
                Key = "currentHP",
                Value = newcurHP.ToString()
            });
            CharacterInventoryListItem damagedItem = (new CharacterInventoryListItem{
                Key = "LuckyRoll"
            });
            print("Starting durability check for char taking damage");
            System.Random rand = new System.Random();
            int chanceRoll = rand.Next(1, 101); // Generates a random number between 1 and 100
            if (chanceRoll <= 6){//6% chance
                for(int x = 0;  x < sPlayer.GetInformationSheets().Count; x++){
            //foreach(var sheet in sPlayer.GetInformationSheets()){
                    if(sPlayer.GetInformationSheets()[x].CharacterID == ID){
                        print("Starting durability check for char taking damage");
                        //List<CharacterInventoryListItem> charInventoryData = sPlayer.GetInformationSheets()[x].CharInventoryData;
                        var validIndices = sPlayer.GetInformationSheets()[x].CharInventoryData
                        .Select((item, index) => new { Item = item, Index = index })
                        .Where(x => x.Item.Value.NFT == false && x.Item.Value.EQUIPPED == true 
                                    && x.Item.Value.itemType != ItemSelectable.ItemType.PotionT1 
                                    && x.Item.Value.itemType != ItemSelectable.ItemType.PotionT2
                                    && x.Item.Value.itemType != ItemSelectable.ItemType.FoodT1 
                                    && x.Item.Value.itemType != ItemSelectable.ItemType.CharacterBag 
                                    && x.Item.Value.itemType != ItemSelectable.ItemType.TacticianBag
                                    && x.Item.Value.Durability != "0")
                        .Select(x => x.Index)
                        .ToList();
                        if (validIndices.Count > 0) {
                            // Select a random index from the valid indices
                            int randomIndex = validIndices[rand.Next(validIndices.Count)];

                            // Access and modify the item directly in the original list
                            var itemToModify = sPlayer.GetInformationSheets()[x].CharInventoryData[randomIndex];
                            string dura = itemToModify.Value.Durability;
                            float durability;
                            if (!float.TryParse(dura, out durability)) {
                                durability = 100f; // Default to 100 if parsing fails
                            }
                            durability = Math.Max(0, durability - 1); // Ensure durability doesn't go below 0
                            dura = durability.ToString();

                            // Since itemToModify is a copy, we need to update the list directly
                            damagedItem = itemToModify;
                            damagedItem.Value.Durability = dura;
                            damagedItem.Value.Changed = true; // Mark the item as changed
                            if(dura == "0"){
                                ChangedGearMessage gearMessage = new ChangedGearMessage(ID, damagedItem.Value.EQUIPPEDSLOT, sPlayer.currentMatch, false, damagedItem.Value);
                                charGearChangeMatch.Invoke(gearMessage); 
                                //charGearChangeMatch.Invoke(false, ID, sPlayer.currentMatch, damagedItem.Value);
                            }
                            //sPlayer.GetInformationSheets()[x].CharInventoryData[randomIndex] = new CharacterInventoryListItem { Key = itemToModify.Key, Value = modifiedValue };

                            print($"{damagedItem.Value.GetItemName()} took a durability loss of 1, its durability is now {damagedItem.Value.Durability}");
                        }
                        
                        break;
                    }
                }
            }
            sPlayer.GetCharacterUpdateHPDurability(ID, Health, damagedItem);
            #endif
        }
        void CharacterHealed(NetworkConnectionToClient nconn, int newcurHP, string ID){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            print("CharacterHealed");

            CharacterStatListItem Health = (new CharacterStatListItem{
                Key = "currentHP",
                Value = newcurHP.ToString()
            });
            sPlayer.ServerCombatHPUpdate(ID, Health);
            #endif
        }
        void CharacterCastedSpell(NetworkConnectionToClient nconn, int newcurMP, string ID){
            //add spell cooldown here
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            print("SpendingMP");
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            CharacterStatListItem Health = (new CharacterStatListItem{
                Key = "currentMP",
                Value = newcurMP.ToString()
            });
            sPlayer.ServerCombatHPUpdate(ID, Health);

            //PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
            //{
            //    PlayFabId = playerData.PlayFabId,
            //    CharacterId = ID,
            //    Data = new Dictionary<string, string>
            //    {
            //        {"currentMP", Health.Value}
            //    }
            //}, result =>
            //{
            //    sPlayer.ServerCombatHPUpdate(ID, Health);
            //}, error =>{
            //    Debug.Log(error.ErrorMessage); 
            //    Debug.Log(error.ErrorDetails);
            //    Debug.Log(error.Error);
            //});
            #endif
        }

        void ServerINNRoomRest(NetworkConnectionToClient nconn){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED ServerINNRoomRest");
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }

            if(sPlayer.Energy >= 100){
                sPlayer.Energy -= 100;
                sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
                StartCoroutine(HealPartyServer(nconn));
                //PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
                //PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
                //{
                //    PlayFabId = playerData.PlayFabId,
                //    Data = new Dictionary<string, string>
                //    {
                //        {"energy", sPlayer.Energy.ToString()},
                //    }
                //}, result =>
                //{
                //    sPlayer.TargetUpdateEnergyDisplay(sPlayer.Energy);
                //    StartCoroutine(HealPartyServer(nconn));
                //}, error =>{
                //    Debug.Log(error.ErrorMessage);
                //});
            }
            #endif
        }
        /*
        IEnumerator HealPartyServer(NetworkConnectionToClient nconn){
            ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(sPlayer == null){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            foreach(var sheet in sPlayer.GetInformationSheets()){
                if(sPlayer.GetParty().Contains(sheet.CharacterID))
                {
                    string _class = string.Empty;
                    int _level = 1;
                    string _core = string.Empty;
                    foreach(var stat in sheet.CharStatData){
                        if(stat.Key == "Class"){
                            _class = stat.Value;
                        }
                        if(stat.Key == "LVL"){
                            _level = int.Parse(stat.Value);
                        }
                        if(stat.Key == "CORE"){
                            _core = stat.Value;
                        }
                    }
                    int equipHP = 0;
                    int equipArcana = 0;
                    foreach(var charItem in sheet.CharInventoryData){
                        if(charItem.Value.EQUIPPED){
                            if(!string.IsNullOrEmpty(charItem.Value.FORTITUDE_item)){
                                if(int.Parse(charItem.Value.FORTITUDE_item) > 0){
                                    equipHP += int.Parse(charItem.Value.FORTITUDE_item);
                                }
                            }
                            if(!string.IsNullOrEmpty(charItem.Value.ARCANA_item)){
                                if(int.Parse(charItem.Value.ARCANA_item) > 0){
                                    equipArcana += int.Parse(charItem.Value.ARCANA_item);
                                }
                            }
                        }
                    }
                    (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                    int maxHP = equipHP + baseFortitude;
                    int maxMP = (equipArcana + baseArcana) / 7;
                    bool returned = false;
                    CharacterStatListItem Health = (new CharacterStatListItem{
                        Key = "currentHP",
                        Value = maxHP.ToString()
                    });
                    CharacterStatListItem Magic = (new CharacterStatListItem{
                        Key = "currentMP",
                        Value = maxMP.ToString()
                    });
                    sPlayer.GetINNServer(sheet.CharacterID, Health, Magic);
                    PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
                    {
                        PlayFabId = playerData.PlayFabId,
                        CharacterId = sheet.CharacterID,
                        Data = new Dictionary<string, string>
                        {
                            {"currentHP", Health.Value},
                            {"currentMP", Magic.Value}
                        }
                    }, result =>
                    {
                        returned = true;
                    }, error =>{
                        Debug.Log(error.ErrorMessage); 
                        Debug.Log(error.ErrorDetails);
                        Debug.Log(error.Error);
                    });
                    while(!returned){
                        yield return new WaitForSeconds(.1f);
                    }
                }
            }
        }
        */
            #if UNITY_SERVER //|| UNITY_EDITOR
            
        IEnumerator HealPartyServer(NetworkConnectionToClient nconn){
            if(!CheckNullConnection(nconn)){
                yield break;
            }

    ScenePlayer sPlayer = nconn.identity.gameObject.GetComponent<ScenePlayer>();
    if(sPlayer == null){
        yield break;
    }
    PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
    int tacticianBonusArmor = 0;
        int tacticianBonusFortitude = 0;
        int tacticianBonusArcana = 0;
         TacticianFullDataMessage tacticianSheet = sPlayer.GetTacticianSheet();
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);

            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                }
            }
    var informationSheets = sPlayer.GetInformationSheets();
    for (int i = 0; i < informationSheets.Count; i++) {
        var sheet = informationSheets[i];
        if (sPlayer.GetParty().Contains(sheet.CharacterID)) {
            string _class = string.Empty;
            int _level = 1;
            string _core = string.Empty;
            bool Dead = false;
            var charStatDataList = sheet.CharStatData;
            for (int j = 0; j < charStatDataList.Count; j++) {
                var stat = charStatDataList[j];
                if (stat.Key == "Class") {
                    _class = stat.Value;
                }
                if (stat.Key == "LVL") {
                    _level = int.Parse(stat.Value);
                }
                if (stat.Key == "CORE") {
                    _core = stat.Value;
                }
                if(stat.Key == "DEATH"){
                    Dead = true;
                    ////print($"{MinHealth}");
                }
            }
            if(Dead){
                continue;
            }
            int equipHP = 0;
            int equipArcana = 0;
            equipHP += tacticianBonusFortitude;
            equipArcana += tacticianBonusArcana;
            var charInventoryDataList = sheet.CharInventoryData;
            for (int k = 0; k < charInventoryDataList.Count; k++) {
                var charItem = charInventoryDataList[k];
                if (charItem.Value.EQUIPPED) {
                    if (!string.IsNullOrEmpty(charItem.Value.FORTITUDE_item)) {
                        if (int.Parse(charItem.Value.FORTITUDE_item) > 0) {
                            equipHP += int.Parse(charItem.Value.FORTITUDE_item);
                        }
                    }
                    if (!string.IsNullOrEmpty(charItem.Value.ARCANA_item)) {
                        if (int.Parse(charItem.Value.ARCANA_item) > 0) {
                            equipArcana += int.Parse(charItem.Value.ARCANA_item);
                        }
                    }
                }
            }
            int PASSIVE_Arcana = 0;
                        int PASSIVE_Fortitude = 0;
                        for(int _char = 0; _char < sPlayer.GetInformationSheets().Count; _char++){
                            if(sPlayer.GetInformationSheets()[_char].CharacterID == sheet.CharacterID){
                                for(int ability = 0; ability < sPlayer.GetInformationSheets()[_char].CharSpellData.Count; ability++){
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3LeftSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Fortitude = abilityRank;
                                        }
                                    }
                                    if(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Key == "SouthT3RightSkill"){
                                        var abilityRankString = System.Text.RegularExpressions.Regex.Match(sPlayer.GetInformationSheets()[_char].CharSpellData[ability].Value, @"\d+$");
                                        if (abilityRankString.Success) {
                                            int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                            PASSIVE_Arcana = abilityRank;
                                        }
                                    }
                                }
                                break;
                            }
                        }
                        (int baseStrength, int baseAgility, int baseFortitude, int baseArcana) = StatAsset.Instance.GetCharacterStats(_class, _level, _core);
                        int maxHP = baseFortitude + equipHP + PASSIVE_Fortitude;
                        int maxMP = (baseArcana + equipArcana + PASSIVE_Arcana) / 7;
            print($"{maxHP} is maxHP, {maxMP} is maxMP");
            CharacterStatListItem Health = (new CharacterStatListItem {
                Key = "currentHP",
                Value = maxHP.ToString()
            });
            CharacterStatListItem Magic = (new CharacterStatListItem {
                Key = "currentMP",
                Value = maxMP.ToString()
            });
            sPlayer.GetINNServer(sheet.CharacterID, Health, Magic);
            //PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest {
            //    PlayFabId = playerData.PlayFabId,
            //    CharacterId = sheet.CharacterID,
            //    Data = new Dictionary<string, string> {
            //        {"currentHP", Health.Value},
            //        {"currentMP", Magic.Value}
            //    }
            //}, result => {
            //    returned = true;
            //}, error => {
            //    Debug.Log(error.ErrorMessage);
            //    Debug.Log(error.ErrorDetails);
            //    Debug.Log(error.Error);
            //});
            //while (!returned) {
                yield return new WaitForSeconds(.1f);
            //}
        }
    }
    sPlayer.TargetInnReset();
}
    #endif

        private void OnMaintenance(DateTime? NextScheduledMaintenanceUtc)
        {
            //Debug.LogFormat("Maintenance scheduled for: {0}", NextScheduledMaintenanceUtc.Value.ToLongDateString());
            //foreach (var conn in PlayFabServer.instance.playerConnections)
            //{
            //    conn.conn.Send<MaintenanceMessage>(new MaintenanceMessage() {
            //        ScheduledMaintenanceUTC = (DateTime)NextScheduledMaintenanceUtc
            //    });
            //}
        }
        //SCENE MANAGEMENT FUNCTIONS /// OTHER FUNCTIONS
        readonly Dictionary<Match, Scene> MatchList = new Dictionary<Match, Scene>();
        readonly List<Scene> Scenes = new List<Scene>();
        [Header("MultiScene Setup")]
        [Scene]
        public string OVM;
        [Scene]
        public string TOWN;
        bool AzureLoaded;
        bool randomUniqueSceneLoaded;
        private Dictionary<string, SceneNode> sceneNodesDictionary;

        IEnumerator LoadSubScenes()
        {
            while (!AzureLoaded)
                yield return null;
            Debug.Log("Loading Scenes");
                GetAllScenes();
                
                // scene 0 = Container
                // scene 1 = OVM
                // scene 2 = TOWN
                // scene 3-x = MATCH

                yield return SceneManager.LoadSceneAsync(OVM, new LoadSceneParameters { loadSceneMode = LoadSceneMode.Additive, localPhysicsMode = LocalPhysicsMode.Physics2D });
                yield return SceneManager.LoadSceneAsync(TOWN, new LoadSceneParameters { loadSceneMode = LoadSceneMode.Additive, localPhysicsMode = LocalPhysicsMode.Physics2D });
                GetAllScenes();

                SceneNode[] allNodes = FindObjectsOfType<SceneNode>();
                sceneNodesDictionary = new Dictionary<string, SceneNode>();
                

                foreach (SceneNode node in allNodes)
                {
                    sceneNodesDictionary.Add(node.nodeName, node);
                    //print($"Added {node.nodeName} to SceneNodesDictionary");
                }
        }
        private List<SpawnInfo> GetSpawnInfo(GameObject parent)
        {
            List<SpawnInfo> spawnInfoList = new List<SpawnInfo>();

            for (int i = 0; i < parent.transform.childCount; i++)
            {
                GameObject group = parent.transform.GetChild(i).gameObject;

                for (int j = 0; j < group.transform.childCount; j++)
                {
                    GameObject point = group.transform.GetChild(j).gameObject;
                    MobPrefabSettings mobSettings = point.GetComponent<MobPrefabSettings>();
                    spawnInfoList.Add(new SpawnInfo 
                    { 
                        MainChestLinked = mobSettings.LinkedToChest,
                        GroupName = group.name, 
                        PointName = point.name, 
                        SpawnTransform = point.transform 
                    });
                    if(mobSettings.LinkedToChest){
                        print($"{point.name} was the name of the prefab that is linked to the chest in group {group.name}");
                    }
                }
            }

            return spawnInfoList;
        }
        public List<Vector2> GeneratePoints(Vector3 spawnPoint, int numPoints)
        {
            print($"GeneratePoints start");
            float spacing = 1f;
            List<Vector2> points = new List<Vector2>();
            Vector2 startPos = spawnPoint;
            startPos.y -= 1; // move 1 unit down on the y-axis
            for (int i = 0; i < numPoints; i++)
            {
                points.Add(startPos);
            print($"GeneratePoint at {startPos}");
                startPos.x += spacing;
            }
            return points;
        }
        /*
        public GameObject GetPrefabByName(string name)
        {
            if (prefabGroups.ContainsKey(name))
            {
                // If so, select a random prefab name from the group
                List<string> group = prefabGroups[name];
                name = group[UnityEngine.Random.Range(0, group.Count)];
            }
            GameObject foundPrefab = System.Array.Find(prefabs, prefab => prefab.name == name);
            if (foundPrefab == null)
            {
                Debug.LogWarning($"Prefab not found for name: {name}");
            }
            return foundPrefab;
        }
        */
    public GameObject GetPrefabByName(string name, Dictionary<string, float> tracker)
{
    if (prefabGroups.ContainsKey(name))
    {
        List<string> group = prefabGroups[name];
        if(tracker != null){
            // Adjust weights for the random selection
            List<float> weights = new List<float>();
            float totalWeight = 0f;
            foreach (string mob in group)
            {
                float weight = 1f;
                if (tracker.ContainsKey(mob))
                {
                    float increasedChance = tracker[mob];
                    weight += increasedChance / 100f;
                }
                weights.Add(weight);
                totalWeight += weight;
            }
            // Normalize weights
            float roll = UnityEngine.Random.Range(0, totalWeight);
            // Select based on adjusted weights
            for (int i = 0; i < group.Count; i++)
            {
                if (roll < weights[i])
                {
                    name = group[i];
                    break;
                }
                roll -= weights[i];
            }
        } else {
            int randomIndex = UnityEngine.Random.Range(0, group.Count);
            name = group[randomIndex];        
        }
    }
    GameObject foundPrefab = prefabs.Find(prefab => prefab.name == name);
    if (foundPrefab == null)
    {
        Debug.LogWarning($"Prefab not found for name: {name}");
    }
    return foundPrefab;
}
//public GameObject GetPrefabByName(string name)
//{
//    if(name == "SpiderGiant"){
//        name = "GiantSpider";
//    }
//    if(name == "MatureSpider"){
//        name = "MatureSpider";
//    }
//    if (prefabGroups.ContainsKey(name))
//    {
//        // If so, select a random prefab name from the group
//        List<string> group = prefabGroups[name];
//        name = group[UnityEngine.Random.Range(0, group.Count)];
//    }
//    GameObject foundPrefab = prefabs.Find(prefab => prefab.name == name);
//    if (foundPrefab == null)
//    {
//        Debug.LogWarning($"Prefab not found for name: {name}");
//    }
//    return foundPrefab;
//}
private void InstantiateDoors(GameObject doorsParent, Scene targetScene, Match match)
{
    // Loop over all direct children of the parent
    for (int i = 0; i < doorsParent.transform.childCount; i++)
    {
        GameObject doorGameObject = doorsParent.transform.GetChild(i).gameObject;
        // Get the name of the child, this should match the name of the prefab
        string prefabName = doorGameObject.name;
        DoorPrefabSettings doorSettings = doorGameObject.GetComponent<DoorPrefabSettings>();
        bool gold = true;
        bool silver = false;
        bool locked = true;
        if(doorSettings){
            gold = doorSettings.Gold;
            silver = doorSettings.Silver;
            locked = doorSettings.Locked;
        }
        // Get the correct prefab based on the name
        GameObject doorPrefab = GetPrefabByName(prefabName, null);
        // Check if a prefab was found
        if (doorPrefab != null){
            // Instantiate a new door at the same position and rotation as the old door
            GameObject newDoor = Instantiate(doorPrefab, doorGameObject.transform.position, doorGameObject.transform.rotation);
            NetworkServer.Spawn(newDoor);
            print($"Spawned door {newDoor.name}");
            // Move the new door to the target scene
            SceneManager.MoveGameObjectToScene(newDoor, targetScene);
            // Get the Door script of the new door
            Door doorScript = newDoor.GetComponent<Door>();
            // Check if the Door script is attached
            if (doorScript != null){
                // Set the match of the Door script
                doorScript.SetMatch(match, locked, gold, silver);
            }
            // Optionally, destroy the old door object
            Destroy(doorGameObject);
        } else {
            Debug.LogWarning($"Door prefab not found for name: {prefabName}");
        }
    }
}
private void InstantiateTraps(List<GameObject> traps, Scene targetScene, Match match)
{
    if(traps == null){
        print("Our list for this was null!");
        return;
    }
    // Loop over all direct children of the parent
    foreach (GameObject trapGameObject in traps)
    {
        // Get the name of the child, this should match the name of the prefab
        string prefabName = trapGameObject.name;
        TrapPrefabSettings trapSettings = trapGameObject.GetComponent<TrapPrefabSettings>();
        int tier = 1;
        bool hp = true;
        bool mp = false;
        bool debuff = false;
        if(trapSettings){
           (tier, hp, mp, debuff) = trapSettings.ReturnTierAndType();
        }
        if(tier <= 0){
            tier = 1;
        }
        if(!mp && !debuff){
            hp = true;
        }
        // Get the correct prefab based on the name
        GameObject trapPrefab = GetPrefabByName(prefabName, null);
        // Check if a prefab was found
        if (trapPrefab != null){
            // Instantiate a new door at the same position and rotation as the old door
            GameObject newTrap = Instantiate(trapPrefab, trapGameObject.transform.position, trapGameObject.transform.rotation);
            NetworkServer.Spawn(newTrap);
            print($"Spawned trap {newTrap.name}");
            // Move the new door to the target scene
            SceneManager.MoveGameObjectToScene(newTrap, targetScene);
            // Get the Door script of the new door
            TrapDrop trapScript = newTrap.GetComponent<TrapDrop>();
            // Check if the Trap script is attached
            if (trapScript != null){
                // Set the match of the Trap script
                trapScript.SetMatch(match, tier, hp, mp, debuff);
            }
            // Optionally, destroy the old door object
        } else {
            Debug.LogWarning($"Trap prefab not found for name: {prefabName}");
        }
    }
    for (int i = traps.Count - 1; i >= 0; i--){
        Destroy(traps[i]);
    }
}
private void InstantiateMiniChests(List<GameObject> miniChests, Scene targetScene, Match match)
{
    if(miniChests == null){
        print("Our list for this was null!");
        return;
    }
    foreach (GameObject miniChestGO in miniChests)
    {
        // Get the name of the child, this should match the name of the prefab
        string prefabName = "MiniChest";
        MiniChestPrefabSettings miniChest = miniChestGO.GetComponent<MiniChestPrefabSettings>();
        int tier = 1;
        if(miniChest){
            tier = miniChest.GetTier();
        }
        GameObject miniChestPrefab = GetPrefabByName(prefabName, null);
        // Check if a prefab was found
        if (miniChestPrefab != null){
            // Instantiate a new door at the same position and rotation as the old door
            GameObject newMiniChest = Instantiate(miniChestPrefab, miniChestGO.transform.position, miniChestGO.transform.rotation);
            NetworkServer.Spawn(newMiniChest);
            print($"Spawned MiniChest {newMiniChest.name}");
            // Move the new door to the target scene
            SceneManager.MoveGameObjectToScene(newMiniChest, targetScene);
            // Get the Door script of the new door
            MiniChest miniChestScript = newMiniChest.GetComponent<MiniChest>();
            // Check if the Trap script is attached
            if (miniChestScript != null){
                miniChestScript.SetMatch(match, tier);
                // Set the match of the Trap script
            }
            // Optionally, destroy the old door object
        } else {
            Debug.LogWarning($"MiniChest prefab not found for name: {prefabName}");
        }
    }
    for (int i = miniChests.Count - 1; i >= 0; i--){
        Destroy(miniChests[i]);
    }
}
private void InstantiateWeaponRacks(List<GameObject> weaponRacks, Scene targetScene, Match match)
{
    if(weaponRacks == null){
        print("Our list for this was null!");
        return;
    }
    // Loop over all direct children of the parent
    foreach (GameObject weaponRackGO in weaponRacks)
    {
        // Get the name of the child, this should match the name of the prefab
        string prefabName = "WeaponRack";
        WeaponRackPrefabSettings weaponRack = weaponRackGO.GetComponent<WeaponRackPrefabSettings>();
        int tier = 1;
        if(weaponRack){
            tier = weaponRack.GetTier();
        }
        GameObject weaponRackPrefab = GetPrefabByName(prefabName, null);
        // Check if a prefab was found
        if (weaponRackPrefab != null){
            // Instantiate a new door at the same position and rotation as the old door
            GameObject newWeaponRack = Instantiate(weaponRackPrefab, weaponRackGO.transform.position, weaponRackGO.transform.rotation);
            NetworkServer.Spawn(newWeaponRack);
            print($"Spawned weaponRack {newWeaponRack.name}");
            // Move the new door to the target scene
            SceneManager.MoveGameObjectToScene(newWeaponRack, targetScene);
            // Get the Door script of the new door
            WeaponDrop weaponRackScript = newWeaponRack.GetComponent<WeaponDrop>();
            // Check if the Trap script is attached
            if (weaponRackScript != null){
                weaponRackScript.SetMatch(match, tier);
                // Set the match of the Trap script
            }
            // Optionally, destroy the old door object
        } else {
            Debug.LogWarning($"weapon rack prefab not found for name: {prefabName}");
        }
    }
    for (int i = weaponRacks.Count - 1; i >= 0; i--){
        Destroy(weaponRacks[i]);
    }
}
private void InstantiateArmorRacks(List<GameObject> armorRacks, Scene targetScene, Match match)
{
    if(armorRacks == null){
        print("Our list for this was null!");
        return;
    }
    if(armorRacks.Count == 0){
        print("Our list for this was empty!");
        return;
    }
    foreach (GameObject armorRackGO in armorRacks)
    {
        string prefabName = "ArmorRack";
        ArmorRackPrefabSettings armorSettings = armorRackGO.GetComponent<ArmorRackPrefabSettings>();
        int tier = 1;
        if(armorSettings)
        {
            tier = armorSettings.GetTier();
        }
        
        GameObject armorRackPrefab = GetPrefabByName(prefabName, null);

        if (armorRackPrefab != null)
        {
            GameObject newArmorRack = Instantiate(armorRackPrefab, armorRackGO.transform.position, armorRackGO.transform.rotation);
            NetworkServer.Spawn(newArmorRack);
            print($"Spawned armor rack {newArmorRack.name}");
            SceneManager.MoveGameObjectToScene(newArmorRack, targetScene);

            ArmorDrop armorRackScript = newArmorRack.GetComponent<ArmorDrop>();
            if (armorRackScript != null)
            {
                armorRackScript.SetMatch(match, tier);
            }
        }
        else
        {
            Debug.LogWarning($"Armor rack prefab not found for name: {prefabName}");
        }
    }
    for (int i = armorRacks.Count - 1; i >= 0; i--){
        Destroy(armorRacks[i]);
    }
}
private void InstantiateWoodNode(List<GameObject> woodNodes, Scene targetScene, Match match)
{
    if(woodNodes == null){
        print("Our list for this was null!");
        return;
    }
     if(woodNodes.Count == 0){
        print("Our list for this was empty!");
        return;
    }
        System.Random rand = new System.Random();

    foreach (GameObject woodNode in woodNodes)
    {
        string prefabName = "TreeNodePrefab";
        TreeNodePrefabSettings treeSettings = woodNode.GetComponent<TreeNodePrefabSettings>();
        int tier = 1;
        if(treeSettings)
        {
            tier = treeSettings.GetTier();
        }
        bool checkRich = treeSettings.GetRich();
        int chanceRoll = rand.Next(1, 101); // Generates a random number between 1 and 100
        if(checkRich){
            if (chanceRoll <= 80){//50% chance{
                
            } else {
                continue;
            }
        } else {
            
            if (chanceRoll <= 50){//50% chance{
                
            } else {
                continue;
            }
        }
        GameObject treeDropPrefab = GetPrefabByName(prefabName, null);

        if (treeDropPrefab != null)
        {
            GameObject newTreeDrop = Instantiate(treeDropPrefab, woodNode.transform.position, woodNode.transform.rotation);
            NetworkServer.Spawn(newTreeDrop);
            print($"Spawned woodNode {newTreeDrop.name}");
            SceneManager.MoveGameObjectToScene(newTreeDrop, targetScene);

            TreeNodeDrop treeNode = newTreeDrop.GetComponent<TreeNodeDrop>();
            if (treeNode != null)
            {
                if(checkRich){
                    int hits = UnityEngine.Random.Range(16, 24);
                    treeNode.SetMatch(match, tier, hits, checkRich);
                } else {
                    int hits = UnityEngine.Random.Range(3, 10);
                    treeNode.SetMatch(match, tier, hits, checkRich);
                }
            }
        }
        else
        {
            Debug.LogWarning($"woodNode prefab not found for name: {prefabName}");
        }
    }
    for (int i = woodNodes.Count - 1; i >= 0; i--){
        Destroy(woodNodes[i]);
    }
}
private void InstantiateStoneNode(List<GameObject> stoneNodes, Scene targetScene, Match match)
{
    if(stoneNodes == null){
        print("Our list for this was null!");
        return;
    }
     if(stoneNodes.Count == 0){
        print("Our list for this was empty!");
        return;
    }
        System.Random rand = new System.Random();

    foreach (GameObject stoneNode in stoneNodes)
    {
        string prefabName = "StoneNodePrefab";
        StoneNodePrefabSettings stoneNodeSettings = stoneNode.GetComponent<StoneNodePrefabSettings>();
        int tier = 1;
        if(stoneNodeSettings)
        {
            tier = stoneNodeSettings.GetTier();
        }
        bool checkRich = stoneNodeSettings.GetRich();
        int chanceRoll = rand.Next(1, 101); // Generates a random number between 1 and 100
        if(checkRich){
            if (chanceRoll <= 80){//50% chance{
                
            } else {
                continue;
            }
        } else {
            
            if (chanceRoll <= 50){//50% chance{
                
            } else {
                continue;
            }
        }
        GameObject stoneNodePrefab = GetPrefabByName(prefabName, null);

        if (stoneNodePrefab != null)
        {
            GameObject newStoneNode = Instantiate(stoneNodePrefab, stoneNode.transform.position, stoneNode.transform.rotation);
            NetworkServer.Spawn(newStoneNode);
            print($"Spawned stoneNode {newStoneNode.name}");
            SceneManager.MoveGameObjectToScene(newStoneNode, targetScene);

            StoneNodeDrop stoneNodeScript = newStoneNode.GetComponent<StoneNodeDrop>();
            if (stoneNodeScript != null)
            {
                if(checkRich){
                    int hits = UnityEngine.Random.Range(16, 24);
                    stoneNodeScript.SetMatch(match, tier, hits, checkRich);
                } else {
                    int hits = UnityEngine.Random.Range(3, 10);
                    stoneNodeScript.SetMatch(match, tier, hits, checkRich);
                }
            }
        }
        else
        {
            Debug.LogWarning($"stoneNode prefab not found for name: {prefabName}");
        }
    }
    for (int i = stoneNodes.Count - 1; i >= 0; i--){
        Destroy(stoneNodes[i]);
    }
}
private void InstantiateOreNode(List<GameObject> OreNodes, Scene targetScene, Match match)
{
    if(OreNodes == null){
        print("Our list for ORE was null!");
        return;
    }
    if(OreNodes.Count == 0){
        print("Our list for ORE was empty!");
        return;
    }
        System.Random rand = new System.Random();

    foreach (GameObject oreNode in OreNodes)
    {
        string prefabName = "OreNodePrefab";
        OreNodePrefabSettings oreNodeSettings = oreNode.GetComponent<OreNodePrefabSettings>();
        int tier = 1;
        if(oreNodeSettings)
        {
            tier = oreNodeSettings.GetTier();
        }
        bool checkRich = oreNodeSettings.GetRich();
        
        int chanceRoll = rand.Next(0, 101); // Generates a random number between 1 and 100
        print($"rolled a {chanceRoll} % on and node is rich {checkRich}");
        if(checkRich){
            if (chanceRoll <= 80){//50% chance{
            } else {
                continue;
            }
        } else {
            
            if (chanceRoll <= 60){//50% chance{
                
            } else {
                continue;
            }
        }
        GameObject oreNodePrefab = GetPrefabByName(prefabName, null);

        if (oreNodePrefab != null)
        {
            GameObject newOreNode = Instantiate(oreNodePrefab, oreNode.transform.position, oreNode.transform.rotation);
            NetworkServer.Spawn(newOreNode);
            print($"Spawned OreNode {newOreNode.name}");
            SceneManager.MoveGameObjectToScene(newOreNode, targetScene);

            OreNodeDrop oreNodeDrop = newOreNode.GetComponent<OreNodeDrop>();
            if (oreNodeDrop != null)
            {
                if(checkRich){
                    int hits = UnityEngine.Random.Range(16, 24);
                    oreNodeDrop.SetMatch(match, tier, hits, checkRich);
                } else {
                    int hits = UnityEngine.Random.Range(3, 10);
                    oreNodeDrop.SetMatch(match, tier, hits, checkRich);
                }
                
            }
        }
        else
        {
            Debug.LogWarning($"OreNode rack prefab not found for name: {prefabName}");
        }
    }
    for (int i = OreNodes.Count - 1; i >= 0; i--){
        Destroy(OreNodes[i]);
    }
}
private void InstantiateClothNode(List<GameObject> clothNodes, Scene targetScene, Match match)
{
    if(clothNodes == null){
        print("Our list for this was null!");
        return;
    }
    if(clothNodes.Count == 0){
        print("Our list for this was empty!");
        return;
    }
        System.Random rand = new System.Random();

    foreach (GameObject clothNodesGO in clothNodes)
    {
        string prefabName = "ClothNodePrefab";
        ClothNodePrefabSettings ClothNodeSettings = clothNodesGO.GetComponent<ClothNodePrefabSettings>();
        int tier = 1;
        if(ClothNodeSettings)
        {
            tier = ClothNodeSettings.GetTier();
        }
        bool checkRich = ClothNodeSettings.GetRich();
        int chanceRoll = rand.Next(1, 101); // Generates a random number between 1 and 100
        if(checkRich){
            if (chanceRoll <= 80){//50% chance{
                
            } else {
                continue;
            }
        } else {
            
            if (chanceRoll <= 50){//50% chance{
                
            } else {
                continue;
            }
        }
        GameObject ClothDropPrefab = GetPrefabByName(prefabName, null);

        if (ClothDropPrefab != null)
        {
            GameObject newClothNode = Instantiate(ClothDropPrefab, clothNodesGO.transform.position, clothNodesGO.transform.rotation);
            NetworkServer.Spawn(newClothNode);
            print($"Spawned ClothNodePrefab {newClothNode.name}");
            SceneManager.MoveGameObjectToScene(newClothNode, targetScene);

            ClothNodeDrop clothNodeScript = newClothNode.GetComponent<ClothNodeDrop>();
            if (clothNodeScript != null)
            {
                if(checkRich){
                    int hits = UnityEngine.Random.Range(16, 24);
                    clothNodeScript.SetMatch(match, tier, hits, checkRich);
                } else {
                    int hits = UnityEngine.Random.Range(3, 10);
                    clothNodeScript.SetMatch(match, tier, hits, checkRich);
                }
            }
        }
        else
        {
            Debug.LogWarning($"ClothNodePrefab prefab not found for name: {prefabName}");
        }
    }
    for (int i = clothNodes.Count - 1; i >= 0; i--){
        Destroy(clothNodes[i]);
    }
}
private void InstantiateRawHideNode(List<GameObject> leatherNodes, Scene targetScene, Match match)
{
    if(leatherNodes == null){
        print("Our list for this was null!");
        return;
    }
    if(leatherNodes.Count == 0){
        print("Our list for this was empty!");
        return;
    }
        System.Random rand = new System.Random();

    foreach (GameObject LeatherNode in leatherNodes)
    {
        string prefabName = "LeatherNodePrefab";
        LeatherNodePrefabSettings LeatherNodeSettings = LeatherNode.GetComponent<LeatherNodePrefabSettings>();
        int tier = 1;
        if(LeatherNodeSettings)
        {
            tier = LeatherNodeSettings.GetTier();
        }
        bool checkRich = LeatherNodeSettings.GetRich();
        int chanceRoll = rand.Next(1, 101); // Generates a random number between 1 and 100
        if(checkRich){
            if (chanceRoll <= 80){//50% chance{
                
            } else {
                continue;
            }
        } else {
            
            if (chanceRoll <= 50){//50% chance{
                
            } else {
                continue;
            }
        }
        GameObject LeatherNodePrefab = GetPrefabByName(prefabName, null);

        if (LeatherNodePrefab != null)
        {
            GameObject newLeatherNode = Instantiate(LeatherNodePrefab, LeatherNode.transform.position, LeatherNode.transform.rotation);
            NetworkServer.Spawn(newLeatherNode);
            print($"Spawned LeatherNodePrefab {newLeatherNode.name}");
            SceneManager.MoveGameObjectToScene(newLeatherNode, targetScene);

            LeatherNodeDrop leatherNodeScript = newLeatherNode.GetComponent<LeatherNodeDrop>();
            if (leatherNodeScript != null)
            {
                if(checkRich){
                    int hits = UnityEngine.Random.Range(16, 24);
                    leatherNodeScript.SetMatch(match, tier, hits, checkRich);
                } else {
                    int hits = UnityEngine.Random.Range(3, 10);
                    leatherNodeScript.SetMatch(match, tier, hits, checkRich);
                }
            }
        }
        else
        {
            Debug.LogWarning($"LeatherNodePrefab prefab not found for name: {prefabName}");
        }
    }
    for (int i = leatherNodes.Count - 1; i >= 0; i--){
        Destroy(leatherNodes[i]);
    }
}
private MainChest CreateMainChest(GameObject mainChestStatic, Scene targetScene, Match match)
{
    // Loop over all direct children of the parent
        MainChest matchMC = null;
        // Get the name of the child, this should match the name of the prefab
        MainChestPrefabSettings mcSettings = mainChestStatic.GetComponent<MainChestPrefabSettings>();
        int tier = 1;
        if(mcSettings){
            if(mcSettings.GetRandom()){
                return null;
            }
            tier = mcSettings.GetTier();
        }
        // Get the correct prefab based on the name
        GameObject mainChestPrefab = GetPrefabByName("MainChestPrefab", null);
        // Check if a prefab was found
        if (mainChestPrefab != null){
            // Instantiate a new door at the same position and rotation as the old door
            GameObject newMainChest = Instantiate(mainChestPrefab, mainChestStatic.transform.position, mainChestStatic.transform.rotation);
            NetworkServer.Spawn(newMainChest);
            print($"Spawned Main Chest {newMainChest.name}");
            // Move the new door to the target scene
            SceneManager.MoveGameObjectToScene(newMainChest, targetScene);
            // Get the Door script of the new door
            MainChest mainChestScript = newMainChest.GetComponent<MainChest>();
            // Check if the Trap script is attached
            if (mainChestScript != null){
                // Set the match of the Trap script
                mainChestScript.SetMatch(match, tier);
                matchMC = mainChestScript;
            }
            // Optionally, destroy the old door object
           // Destroy(mainChestStatic);
        } else {
            Debug.LogWarning($"MainChest prefab not found for name: MainChest");
        }
            return matchMC;

}

    private Dictionary<string, string> GetInspectedCharacterList(ScenePlayer inspectedPlayer, string id)
    {
        Dictionary<string, string> characterStats = new Dictionary<string, string>();
        foreach(var key in inspectedPlayer.GetInformationSheets()){
            if(key.CharacterID == id){
                foreach(var KVP in key.CharStatData){
                    characterStats.Add(KVP.Key, KVP.Value);
                }
                break;
            }
        }
        return characterStats;
    }
    List<PlayerCharacter> SpawnPlayerCharactersDuel(ScenePlayer player, Match match, TurnManager curator, Scene scene, Vector3 spawnPoint){
            //print($"Solo player character start");
        //we need to build the characters using adventureList, which has the scene player and int serial to find their characters
        int tacticianBonusArmor = 0;
        int tacticianBonusStrength = 0;
        int tacticianBonusFortitude = 0;
        int tacticianBonusAgility = 0;
        int tacticianBonusArcana = 0;
        int tacticianBonusMagicResist = 0;
        int tacticianBonusColdResist = 0;
        int tacticianBonusFireResist = 0;
        int tacticianBonusPoisonResist = 0;
        int tacticianBonusDiseaseResist = 0;

         TacticianFullDataMessage tacticianSheet = player.GetTacticianSheet();
            tacticianBonusArmor += int.Parse(tacticianSheet.ArmorBonus);
            tacticianBonusStrength += int.Parse(tacticianSheet.StrengthBonus);
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusAgility += int.Parse(tacticianSheet.AgilityBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);

            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetArmor_item()))
                    {
                        tacticianBonusArmor += int.Parse(tacticianEquipped.Value.GetArmor_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetSTRENGTH_item()))
                    {
                        tacticianBonusStrength += int.Parse(tacticianEquipped.Value.GetSTRENGTH_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetAGILITY_item()))
                    {
                        tacticianBonusAgility += int.Parse(tacticianEquipped.Value.GetAGILITY_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetMagicResist_item()))
                    {
                        tacticianBonusMagicResist += int.Parse(tacticianEquipped.Value.GetMagicResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetColdResist_item()))
                    {
                        tacticianBonusColdResist += int.Parse(tacticianEquipped.Value.GetColdResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFireResist_item()))
                    {
                        tacticianBonusFireResist += int.Parse(tacticianEquipped.Value.GetFireResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetPoisonResist_item()))
                    {
                        tacticianBonusPoisonResist += int.Parse(tacticianEquipped.Value.GetPoisonResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetDiseaseResist_item()))
                    {
                        tacticianBonusDiseaseResist += int.Parse(tacticianEquipped.Value.GetDiseaseResist_item());
                    }
                }
            }
            //print($"Solo player character tactician stats built");

        // use player as the spawn point, then we can use each character from dictionary
        List<Vector2> charSpawnPoints = GeneratePoints(spawnPoint, player.GetParty().Count);
           // print($"Solo player character charSpawnPoints built");
        //spawn points are good now we just need to fix the logic below
        List<PlayerCharacter> PCs = new List<PlayerCharacter>();
        string selectionString = null;
        foreach(var slot in player.GetParty()){
            selectionString = string.Empty;
            int index = UnityEngine.Random.Range(0, charSpawnPoints.Count);
            print($"inded is {index}");
            bool deadChar = false;
            //instantiate the players object and pass it the information to do what it needs to do
            GameObject character = null;
            foreach(var key in player.GetInformationSheets()){
                if(key.CharacterID == slot){
                    foreach(var KVP in key.CharStatData){
                        if(KVP.Key == "CharacterSprite"){
                            selectionString = KVP.Value;
                        }
                        if(KVP.Key == "DEATH"){
                            deadChar = true;
                        }
                    }
                    break;
                }
            }
            //if(deadChar){
            //print($"this char was dead");
            //    continue;
            //}
            //print($"not dead building char pos");
            Vector3 CharPos = new Vector3(charSpawnPoints[index].x, charSpawnPoints[index].y, 0);
            //print($"{CharPos} was our char pos!!!!!!!!!!!!");
            charSpawnPoints.RemoveAt(index);
            //print($"removed from charspawn points");
            if(selectionString == "Player0_18"){
                character = Instantiate(Player18PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "WyvernBaby"){
                character = Instantiate(WyvernBabyPrefabModel, CharPos, Quaternion.identity);
            }
            if(selectionString == "WyvernAdult"){
                character = Instantiate(WyvernAdultPrefabModel, CharPos, Quaternion.identity);
            }
            
            if(selectionString == "Player0_37"){
                character = Instantiate(Player37PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_35"){
                character = Instantiate(Player35PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_7"){
                character = Instantiate(Player7PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_23"){
                character = Instantiate(Player23PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_17"){
                character = Instantiate(Player17PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_36"){
                character = Instantiate(Player36PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_33"){
                character = Instantiate(Player33PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_43"){
                character = Instantiate(Player43PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_26"){
                character = Instantiate(Player26PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_45"){
                character = Instantiate(Player45PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_6"){
                character = Instantiate(Player6PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_22"){
                character = Instantiate(Player22PrefabModel, CharPos, Quaternion.identity);//
            }
            //print($"{selectionString} was our selection!");
            //GameObject character 
            NetworkServer.Spawn(character.gameObject);
            // Give the player ownership of the character
            //print($"Spawned our character");
            PlayerCharacter charScript = character.GetComponent<PlayerCharacter>();
            PCs.Add(charScript);
            //print($"Added our char script to turnmanager vessel");
            Vector2 nully = new Vector2 ();
            charScript.SetUpCharacter(curator, CharPos, nully);
            charScript.armor += tacticianBonusArmor;
            charScript.strength += tacticianBonusStrength;
            charScript.agility += tacticianBonusAgility;
            charScript.fortitude += tacticianBonusFortitude;
            charScript.arcana += tacticianBonusArcana;
            charScript.MagicResist += tacticianBonusMagicResist;
            charScript.ColdResist += tacticianBonusColdResist;
            charScript.FireResist += tacticianBonusFireResist;
            charScript.PoisonResist += tacticianBonusPoisonResist;
            charScript.DiseaseResist += tacticianBonusDiseaseResist;
            int currentFortitude = charScript.fortitude;
            int previousFortitude = currentFortitude - tacticianBonusFortitude;
            int currentResistances = currentFortitude / 50;
            int previousResistances = previousFortitude / 50;
            if (currentResistances > previousResistances)
            {
                int bonusResistances = currentResistances - previousResistances;
                charScript.MagicResist += bonusResistances;
                charScript.ColdResist += bonusResistances;
                charScript.FireResist += bonusResistances;
                charScript.PoisonResist += bonusResistances;
                charScript.DiseaseResist += bonusResistances;
            }
            
            //print($"finished adding tactician stats to cahr");
            SceneManager.MoveGameObjectToScene(charScript.gameObject, scene);
            //print($"Sent char to scene");
            charScript.AssignedPayerAndMatch(player, player.currentMatch, slot, true);
            //print($"Assigned to match");
            NetworkIdentity identity = charScript.GetComponent<NetworkIdentity>();
            identity.AssignClientAuthority(player.connectionToClient);
            //print($"Sending to turn manager");
            SendTurnManagerToPlayerCharacter(match, curator, charScript, deadChar);
        }
        
        return PCs;
        
    }   
    public Dictionary<string, string> GetEnemyToPrefabMapping()
{
    Dictionary<string, string> enemyToPrefabMapping = new Dictionary<string, string>
    {
        // Tiers 5
        {"Black Dragon", "BlackDragon"},
        {"Whale", "Whale"},
        {"Vampire", "Vampire"},
        {"Draco", "Draco"},

        // Tiers 4
        {"Mummy Lord", "MummyLord"},
        {"Zombie King", "ZombieKing"},
        {"Greater Spectre", "GreaterSpectre"},
        {"Octopus", "Octopus"},
        {"Demon Elite", "DemonElite"},
        {"Sea Serpent", "SeaSerpent"},
        {"Greater Ghast", "GreaterGhast"},
        {"Sphinx", "Sphinx"},

        // Tiers 3
        {"Cyclops", "Cyclops"},
        {"Ghast", "Ghast"},
        {"Fire Elemental", "FireElemental"},
        {"Lizard Gladiator", "LizardGladiator"},
        {"Ghoul Warlock", "GhoulWarlock"},
        {"Giant Wolf", "GiantWolf"},
        {"Lizard Warlock", "LizardWarlock"},
        {"Ghoul Noble", "GhoulNoble"},
        {"Greater Mummy", "GreaterMummy"},
        {"Ghoul Treasurer", "GhoulTreasurer"},
        {"Spectre", "Spectre"},
        {"Giant Spider", "GiantSpider"},

        // Tiers 2
        {"Dragon Whelp", "DragonWhelp"},
        {"Skeleton Knight", "SkeletonKnight"},
        {"Giant Rat", "GiantRat"},
        {"Fire Ghoul", "FireGhoul"},
        {"Mummy", "Mummy"},
        {"Ghost", "Ghost"},
        {"Lizard Archer", "LizardArcher"},
        {"Lizard Knight", "LizardKnight"},
        {"Lizard Mage", "LizardMage"},
        {"Poison Ghoul", "PoisonGhoul"},
        {"Diseased Ghoul", "DiseasedGhoul"},
        {"Wolf", "Wolf"},
        {"Lizard Priest", "LizardPriest"},
        {"Mature Spider", "MatureSpider"},

        // Tiers 1
        {"Possessed Plant", "PossessedPlant"},
        {"Deer", "Deer"},
        {"Stone Golem", "StoneGolem"},
        {"Ore Golem", "OreGolem"},
        {"Possessed Tree", "PossessedTree"},
        {"Zombieling", "Zombieling"},
        {"Bone Squire", "BoneSquire"},
        {"Mummyling", "Mummyling"},
        {"Bat", "Bat"},
        {"Rat", "Rat"},
        {"Snake", "Snake"},
        {"Jellyfish", "Jellyfish"},
        {"Lizard Child", "LizardChild"},
        {"Lobster", "Lobster"},
        {"Ghoul", "Ghoul"},
        {"Spider", "Spider"},
        {"Crocodile", "Crocodile"}
    };

    return enemyToPrefabMapping;
}
       (List<MovingObject>, Dictionary<string,float>) SpawnPlayerCharactersTeam(ScenePlayer Host, Vector3 charStart, Match match, TurnManager curator, List<ScenePlayer> additonalPlayers, Scene scene){
        //we need to build the characters using adventureList, which has the scene player and int serial to find their characters
        // use player as the spawn point, then we can use each character from dictionary
        Dictionary<string, float> trackingDictionary = new Dictionary<string, float>();
        List<Vector2> Santaclawz = GeneratePoints(charStart, match.playerSlotPairs.Count);
        //spawn points are good now we just need to fix the logic below
        List<PlayerCharacter> PCs = new List<PlayerCharacter>();
        Dictionary<string, string> charStatsList;
        string selectionString = null;
        foreach(PlayerSlotPair pair in match.playerSlotPairs){
            int tacticianBonusArmor = 0;
            int tacticianBonusStrength = 0;
            int tacticianBonusFortitude = 0;
            int tacticianBonusAgility = 0;
            int tacticianBonusArcana = 0;
            int tacticianBonusMagicResist = 0;
            int tacticianBonusColdResist = 0;
            int tacticianBonusFireResist = 0;
            int tacticianBonusPoisonResist = 0;
            int tacticianBonusDiseaseResist = 0;

            TacticianFullDataMessage tacticianSheet = pair.player.GetTacticianSheet();
            tacticianBonusArmor += int.Parse(tacticianSheet.ArmorBonus);
            tacticianBonusStrength += int.Parse(tacticianSheet.StrengthBonus);
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusAgility += int.Parse(tacticianSheet.AgilityBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);
            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetArmor_item()))
                    {
                        tacticianBonusArmor += int.Parse(tacticianEquipped.Value.GetArmor_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetSTRENGTH_item()))
                    {
                        tacticianBonusStrength += int.Parse(tacticianEquipped.Value.GetSTRENGTH_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetAGILITY_item()))
                    {
                        tacticianBonusAgility += int.Parse(tacticianEquipped.Value.GetAGILITY_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetMagicResist_item()))
                    {
                        tacticianBonusMagicResist += int.Parse(tacticianEquipped.Value.GetMagicResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetColdResist_item()))
                    {
                        tacticianBonusColdResist += int.Parse(tacticianEquipped.Value.GetColdResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFireResist_item()))
                    {
                        tacticianBonusFireResist += int.Parse(tacticianEquipped.Value.GetFireResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetPoisonResist_item()))
                    {
                        tacticianBonusPoisonResist += int.Parse(tacticianEquipped.Value.GetPoisonResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetDiseaseResist_item()))
                    {
                        tacticianBonusDiseaseResist += int.Parse(tacticianEquipped.Value.GetDiseaseResist_item());
                    }
                }
            }
            ScenePlayer charKey = pair.player;
            string charValue = pair.slot;
            int index = UnityEngine.Random.Range(0, Santaclawz.Count);
            Vector2 CharPos = Santaclawz[index];
            Santaclawz.RemoveAt(index);
            //instantiate the players object and pass it the information to do what it needs to do
            GameObject character = null;
            //charStatsList = GetInspectedCharacterList(charKey, charValue);
            //foreach(var statKey in charStatsList){
            //    if(statKey.Key == "CharacterSprite"){
            //        selectionString = statKey.Value;
            //    }
            //}
            //Dictionary<string, int> mobsToSpawn = StatAsset.Instance.GetCompendiumFull();
            string trackedMobName = string.Empty;
            int spellRank = 0;
            print($"charKey is {charKey.playerName} amd charValue is {charValue}");
            foreach(var key in charKey.GetInformationSheets()){
                if(key.CharacterID == charValue){
                    foreach(var KVP in key.CharStatData){
                        if(KVP.Key == "CharacterSprite"){
                            selectionString = KVP.Value;
                            print($"SelectionString is {selectionString}");
                        }
                        if(KVP.Key == "trackingData"){
                            trackedMobName = KVP.Value;
                            print($"trackedMobName is {trackedMobName}");
                        }
                    }
                    foreach(var spell in key.CharSpellData){
                        if(spell.Key == "EastT2BottomSkill"){//track
                            var rankMatch = System.Text.RegularExpressions.Regex.Match(spell.Value, @"\d+$");
                            if (rankMatch.Success) {
                                spellRank = int.Parse(rankMatch.Value); // Parse the rank number
                            }
                            break;
                        }
                    }
                }
            }
            if(!string.IsNullOrEmpty(trackedMobName) && trackedMobName != "None"){
                float increaseChance = 1 + ((spellRank - 1) * .24f);
                if(!trackingDictionary.ContainsKey(GetEnemyToPrefabMapping()[trackedMobName])){
                    trackingDictionary.Add(GetEnemyToPrefabMapping()[trackedMobName], increaseChance);
                }
            }

            if(selectionString == "Player0_18"){
                character = Instantiate(Player18PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "WyvernBaby"){
                character = Instantiate(WyvernBabyPrefabModel, CharPos, Quaternion.identity);
            }
            if(selectionString == "WyvernAdult"){
                character = Instantiate(WyvernAdultPrefabModel, CharPos, Quaternion.identity);
            }
            
            if(selectionString == "Player0_37"){
                character = Instantiate(Player37PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_35"){
                character = Instantiate(Player35PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_7"){
                character = Instantiate(Player7PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_23"){
                character = Instantiate(Player23PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_17"){
                character = Instantiate(Player17PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_36"){
                character = Instantiate(Player36PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_33"){
                character = Instantiate(Player33PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_43"){
                character = Instantiate(Player43PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_26"){
                character = Instantiate(Player26PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_45"){
                character = Instantiate(Player45PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_6"){
                character = Instantiate(Player6PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_22"){
                character = Instantiate(Player22PrefabModel, CharPos, Quaternion.identity);//
            }
            //GameObject character 
            NetworkServer.Spawn(character.gameObject);
            // Give the player ownership of the character
            PlayerCharacter charScript = character.GetComponent<PlayerCharacter>();
            PCs.Add(charScript);
            Vector2 nully = new Vector2 ();
            charScript.SetUpCharacter(curator, CharPos, nully);
            charScript.armor += tacticianBonusArmor;
            charScript.strength += tacticianBonusStrength;
            charScript.agility += tacticianBonusAgility;
            print($"{tacticianBonusArcana} was the bonus tact arcana and our arcana is {charScript.arcana}");
            
            charScript.fortitude += tacticianBonusFortitude;
            charScript.arcana += tacticianBonusArcana;
            print($"{tacticianBonusArcana} was the bonus tact arcana and our arcana is {charScript.arcana}");

            charScript.MagicResist += tacticianBonusMagicResist;
            charScript.ColdResist += tacticianBonusColdResist;
            charScript.FireResist += tacticianBonusFireResist;
            charScript.PoisonResist += tacticianBonusPoisonResist;
            charScript.DiseaseResist += tacticianBonusDiseaseResist;
            int currentFortitude = charScript.fortitude;
            int previousFortitude = currentFortitude - tacticianBonusFortitude;
            int currentResistances = currentFortitude / 50;
            int previousResistances = previousFortitude / 50;
            if (currentResistances > previousResistances)
            {
                int bonusResistances = currentResistances - previousResistances;
                charScript.MagicResist += bonusResistances;
                charScript.ColdResist += bonusResistances;
                charScript.FireResist += bonusResistances;
                charScript.PoisonResist += bonusResistances;
                charScript.DiseaseResist += bonusResistances;
            }
            SceneManager.MoveGameObjectToScene(charScript.gameObject, scene);
            charScript.AssignedPayerAndMatch(charKey, match, charValue, true);
            NetworkIdentity identity = charScript.GetComponent<NetworkIdentity>();
            identity.AssignClientAuthority(charKey.connectionToClient);
            SendTurnManagerToPlayerCharacter(match, curator, charScript, false);
        }
        curator.SetPCList(PCs);
        List<MovingObject> MOs = new List<MovingObject>();
        foreach(var pc in PCs){
            MOs.Add(pc);
        }
        return (MOs, trackingDictionary);
        
    }   
        (List<MovingObject>, Dictionary<string,float>) SpawnPlayerCharactersSolo(ScenePlayer player, Match match, TurnManager curator, Scene scene, Vector3 spawnPoint){
        Dictionary<string, float> trackingDictionary = new Dictionary<string, float>();
         
            //print($"Solo player character start");
        //we need to build the characters using adventureList, which has the scene player and int serial to find their characters
        int tacticianBonusArmor = 0;
        int tacticianBonusStrength = 0;
        int tacticianBonusFortitude = 0;
        int tacticianBonusAgility = 0;
        int tacticianBonusArcana = 0;
        int tacticianBonusMagicResist = 0;
        int tacticianBonusColdResist = 0;
        int tacticianBonusFireResist = 0;
        int tacticianBonusPoisonResist = 0;
        int tacticianBonusDiseaseResist = 0;

         TacticianFullDataMessage tacticianSheet = player.GetTacticianSheet();
            tacticianBonusArmor += int.Parse(tacticianSheet.ArmorBonus);
            tacticianBonusStrength += int.Parse(tacticianSheet.StrengthBonus);
            tacticianBonusFortitude += int.Parse(tacticianSheet.FortitudeBonus);
            tacticianBonusAgility += int.Parse(tacticianSheet.AgilityBonus);
            tacticianBonusArcana += int.Parse(tacticianSheet.ArcanaBonus);

            foreach(var tacticianEquipped in tacticianSheet.TacticianInventoryData){
                if (tacticianEquipped.Value.GetTacticianEquip())
                {
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetArmor_item()))
                    {
                        tacticianBonusArmor += int.Parse(tacticianEquipped.Value.GetArmor_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetSTRENGTH_item()))
                    {
                        tacticianBonusStrength += int.Parse(tacticianEquipped.Value.GetSTRENGTH_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetAGILITY_item()))
                    {
                        tacticianBonusAgility += int.Parse(tacticianEquipped.Value.GetAGILITY_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFORTITUDE_item()))
                    {
                        tacticianBonusFortitude +=  int.Parse(tacticianEquipped.Value.GetFORTITUDE_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetARCANA_item()))
                    {
                        tacticianBonusArcana += int.Parse(tacticianEquipped.Value.GetARCANA_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetMagicResist_item()))
                    {
                        tacticianBonusMagicResist += int.Parse(tacticianEquipped.Value.GetMagicResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetColdResist_item()))
                    {
                        tacticianBonusColdResist += int.Parse(tacticianEquipped.Value.GetColdResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetFireResist_item()))
                    {
                        tacticianBonusFireResist += int.Parse(tacticianEquipped.Value.GetFireResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetPoisonResist_item()))
                    {
                        tacticianBonusPoisonResist += int.Parse(tacticianEquipped.Value.GetPoisonResist_item());
                    }
                    if (!string.IsNullOrEmpty(tacticianEquipped.Value.GetDiseaseResist_item()))
                    {
                        tacticianBonusDiseaseResist += int.Parse(tacticianEquipped.Value.GetDiseaseResist_item());
                    }
                }
            }
            //print($"Solo player character tactician stats built");

        // use player as the spawn point, then we can use each character from dictionary
        List<Vector2> charSpawnPoints = GeneratePoints(spawnPoint, player.GetParty().Count);
           // print($"Solo player character charSpawnPoints built");
        //spawn points are good now we just need to fix the logic below
        List<PlayerCharacter> PCs = new List<PlayerCharacter>();
        string selectionString = null;
            string trackedMobName = string.Empty;
            int spellRank = 0;
        foreach(var slot in player.GetParty()){
            selectionString = string.Empty;
            int index = UnityEngine.Random.Range(0, charSpawnPoints.Count);
            print($"inded is {index}");
            bool deadChar = false;
            //instantiate the players object and pass it the information to do what it needs to do
            GameObject character = null;
            foreach(var key in player.GetInformationSheets()){
                if(key.CharacterID == slot){
                    foreach(var KVP in key.CharStatData){
                        if(KVP.Key == "CharacterSprite"){
                            selectionString = KVP.Value;
                        }
                        if(KVP.Key == "DEATH"){
                            deadChar = true;
                        }
                        if(KVP.Key == "trackingData"){
                            trackedMobName = KVP.Value;
                            print($"trackedMobName is {trackedMobName}");
                        }
                    }
                    foreach(var spell in key.CharSpellData){
                        if(spell.Key == "EastT2BottomSkill"){//track
                            var rankMatch = System.Text.RegularExpressions.Regex.Match(spell.Value, @"\d+$");
                            if (rankMatch.Success) {
                                spellRank = int.Parse(rankMatch.Value); // Parse the rank number
                            }
                            break;
                        }
                    }
                }
            }
             if(!string.IsNullOrEmpty(trackedMobName) && trackedMobName != "None"){
                float increaseChance = 1 + ((spellRank - 1) * .24f);
                if(!trackingDictionary.ContainsKey(GetEnemyToPrefabMapping()[trackedMobName])){
                    trackingDictionary.Add(GetEnemyToPrefabMapping()[trackedMobName], increaseChance);
                }
            }
            //if(deadChar){
            //print($"this char was dead");
            //    continue;
            //}
            //print($"not dead building char pos");
            Vector3 CharPos = new Vector3(charSpawnPoints[index].x, charSpawnPoints[index].y, 0);
            //print($"{CharPos} was our char pos!!!!!!!!!!!!");
            charSpawnPoints.RemoveAt(index);
            //print($"removed from charspawn points");
            if(selectionString == "Player0_18"){
                character = Instantiate(Player18PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "WyvernBaby"){
                character = Instantiate(WyvernBabyPrefabModel, CharPos, Quaternion.identity);
            }
            if(selectionString == "WyvernAdult"){
                character = Instantiate(WyvernAdultPrefabModel, CharPos, Quaternion.identity);
            }
            
            if(selectionString == "Player0_37"){
                character = Instantiate(Player37PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_35"){
                character = Instantiate(Player35PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_7"){
                character = Instantiate(Player7PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_23"){
                character = Instantiate(Player23PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_17"){
                character = Instantiate(Player17PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_36"){
                character = Instantiate(Player36PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_33"){
                character = Instantiate(Player33PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_43"){
                character = Instantiate(Player43PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_26"){
                character = Instantiate(Player26PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_45"){
                character = Instantiate(Player45PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_6"){
                character = Instantiate(Player6PrefabModel, CharPos, Quaternion.identity);//
            }
            if(selectionString == "Player0_22"){
                character = Instantiate(Player22PrefabModel, CharPos, Quaternion.identity);//
            }
            //print($"{selectionString} was our selection!");
            //GameObject character 
            NetworkServer.Spawn(character.gameObject);
            // Give the player ownership of the character
            //print($"Spawned our character");
            PlayerCharacter charScript = character.GetComponent<PlayerCharacter>();
            PCs.Add(charScript);
            //print($"Added our char script to turnmanager vessel");
            Vector2 nully = new Vector2 ();
            charScript.SetUpCharacter(curator, CharPos, nully);
            charScript.armor += tacticianBonusArmor;
            charScript.strength += tacticianBonusStrength;
            charScript.agility += tacticianBonusAgility;
            charScript.fortitude += tacticianBonusFortitude;
            charScript.arcana += tacticianBonusArcana;
            charScript.MagicResist += tacticianBonusMagicResist;
            charScript.ColdResist += tacticianBonusColdResist;
            charScript.FireResist += tacticianBonusFireResist;
            charScript.PoisonResist += tacticianBonusPoisonResist;
            charScript.DiseaseResist += tacticianBonusDiseaseResist;
            int currentFortitude = charScript.fortitude;
            int previousFortitude = currentFortitude - tacticianBonusFortitude;
            int currentResistances = currentFortitude / 50;
            int previousResistances = previousFortitude / 50;
            if (currentResistances > previousResistances)
            {
                int bonusResistances = currentResistances - previousResistances;
                charScript.MagicResist += bonusResistances;
                charScript.ColdResist += bonusResistances;
                charScript.FireResist += bonusResistances;
                charScript.PoisonResist += bonusResistances;
                charScript.DiseaseResist += bonusResistances;
            }
            
            //print($"finished adding tactician stats to cahr");
            SceneManager.MoveGameObjectToScene(charScript.gameObject, scene);
            //print($"Sent char to scene");
            charScript.AssignedPayerAndMatch(player, player.currentMatch, slot, false);
            //print($"Assigned to match");
            NetworkIdentity identity = charScript.GetComponent<NetworkIdentity>();
            //print($"Setting client authority");
            identity.AssignClientAuthority(player.connectionToClient);
            //print($"Sending to turn manager");
            SendTurnManagerToPlayerCharacter(match, curator, charScript, deadChar);
        }
        curator.SetPCList(PCs);
        List<MovingObject> MOs = new List<MovingObject>();
        foreach(var pc in PCs){
            MOs.Add(pc);
        }
        return (MOs, trackingDictionary);
        
    }   
        public void StartTheGame( int matchIndex, string nodeName, Match match, ScenePlayer host, string _matchID, List<ScenePlayer> playerScripts){
            StartCoroutine(CreateMatch(matchIndex, nodeName, match, host, playerScripts));
            //foreach(var play in playerScripts){
            //    if(play.EXPCPRoutine != null){
            //        StopCoroutine(play.EXPCPRoutine);
            //        play.EXPCPRoutine = null;
            //    }
            //    play.EXPCPRoutine = play.StartCoroutine(play.SendRpcQueue());
            //}
            // begin game is givng us the match number so we can pair it with the scene count and find which scene we are creating so we can reference 
            //for the players to join and then later remove it and fix any errors that appear
        }
        public void StartTheGameSolo(ScenePlayer host, int matchIndex, string nodeName, Match match, bool random, bool login){
            StartCoroutine(CreateMatchSolo(matchIndex, nodeName, match, host, random, login));
            //if(host.EXPCPRoutine != null){
            //    StopCoroutine(host.EXPCPRoutine);
            //    host.EXPCPRoutine = null;
            //}
            //host.EXPCPRoutine = host.StartCoroutine(host.SendRpcQueue());
            // begin game is givng us the match number so we can pair it with the scene count and find which scene we are creating so we can reference 
            //for the players to join and then later remove it and fix any errors that appear
        }
        public void PVPDuelMatch( int matchIndex, Match match, string _matchID, ArenaDuel arenaDuelScript){
            StartCoroutine(CreateArenaDuel(matchIndex, match, arenaDuelScript));
            if(arenaDuelScript.PlayerOne.EXPCPRoutine != null){
                StopCoroutine(arenaDuelScript.PlayerOne.EXPCPRoutine);
                arenaDuelScript.PlayerOne.EXPCPRoutine = null;
            }
            if(arenaDuelScript.PlayerTwo.EXPCPRoutine != null){
                StopCoroutine(arenaDuelScript.PlayerTwo.EXPCPRoutine);
                arenaDuelScript.PlayerTwo.EXPCPRoutine = null;
            }
            // begin game is givng us the match number so we can pair it with the scene count and find which scene we are creating so we can reference 
            //for the players to join and then later remove it and fix any errors that appear
        }
        Vector3 CharacterSpawnerPosition(string nodeName, ScenePlayer host){
            Vector3 spawnPos = new Vector3();
            if(nodeName == "Random_Forest_1_1"){
                spawnPos.x = -17.75f;
                spawnPos.y = -8.75f;
            }
            if(nodeName == "Random_Forest_1_2"){
                spawnPos.x = -7.5f;
                spawnPos.y = 0f;
            }
            if(nodeName == "Random_Forest_1_3"){
                spawnPos.x = -57.5f;
                spawnPos.y = 11.5f;
            }
            if(nodeName.Contains("Sewers")){
                spawnPos.x = -21.5f;
                spawnPos.y = 1.5f;
            }
            if(nodeName == "Lake Arudine"){
                if(host.transform.position.x >=-39f){
                    spawnPos.x = 6.5f;
                    spawnPos.y = 20f;
                } else {
                    spawnPos.x = -24.5f;
                    spawnPos.y = -25f;
                }
            }
            if(nodeName == "Sequoia Forest"){
                if(host.transform.position.x >=-31.5f){
                    spawnPos.x = 39f;
                    spawnPos.y = -1f;
                } else {
                    spawnPos.x = -41.5f;
                    spawnPos.y = 6.5f;
                }
            }
            if(nodeName == "Spider Caverns North"){
                spawnPos.x = -51.5f;
                spawnPos.y = 5.5f;
            }
            if(nodeName == "Spider Caverns South"){
                spawnPos.x = 20.5f;
                spawnPos.y = -3f;
            }
            return spawnPos;
        }
public Vector3 GetPlayerPositionWithOffset(List<MovingObject> playerCharacters)
    {
        if (playerCharacters == null || playerCharacters.Count == 0)
        {
            throw new System.ArgumentException("The playerCharacters list cannot be null or empty.");
        }

        // Get the position of the first player character
        Vector3 position = playerCharacters[0].transform.position;

        // Add 1f to the Y axis
        position.y += 1f;

        return position;
    }
        IEnumerator CreateArenaDuel(int matchIndex, Match match, ArenaDuel duelScript)
        {
            duelScript.PlayerOne.CanUpdateOVM = false;
            duelScript.PlayerTwo.CanUpdateOVM = false;
            string nodeName = "ArenaDuelArea";
            print("PVP Start");
            string agentType = "ArenaDuel";
            bool inside = GetInside(nodeName);
            //Vector3 CharacterSpawnStartOne = CharacterSpawnerPosition(nodeName, duelScript.PlayerOne);
            //Vector3 CharacterSpawnStartTwo = CharacterSpawnerPosition(nodeName, duelScript.PlayerTwo);
            Vector3 CharacterSpawnStartOne = new Vector3(-48f, 10.5f, 0);
            Vector3 CharacterSpawnStartTwo = new Vector3(25f, -8.5f, 0);
            //string direction = DetermineDirection(Host.transform, noderect);
            yield return SceneManager.LoadSceneAsync(nodeName, new LoadSceneParameters { loadSceneMode = LoadSceneMode.Additive, localPhysicsMode = LocalPhysicsMode.Physics2D });
            Debug.Log($"Spawned scene {SceneManager.GetSceneAt(matchIndex + 2).name}");
            MatchList.Add(match, SceneManager.GetSceneAt(matchIndex + 2));
            Scene scene = SceneManager.GetSceneAt(matchIndex + 2);
            Vector3 scenePosition = new Vector3(UnityEngine.Random.Range(0, 10000), UnityEngine.Random.Range(0, 10000), 0); // Adjust range as needed
            MoveSceneToPosition(scene, scenePosition);
            GameObject Wall = null;
            GameObject MainChest = null;
            GameObject SpawnPoints = null;
            GameObject[] rootObjects = scene.GetRootGameObjects();
            foreach (GameObject rootObject in rootObjects){
                if(Wall == null){
                    Wall = FindGameObjectInChildren(rootObject, "Walls");
                }
                if(MainChest == null){
                    MainChest = FindGameObjectInChildren(rootObject, "MainChest");
                }
                if(SpawnPoints == null){
                    SpawnPoints = FindGameObjectInChildren(rootObject, "MobSpawnPoints");
                }
                if (MainChest && SpawnPoints && Wall ){
                    break;
                }
            }
            //NavMeshSurface navMeshSurface = scene.GetRootGameObjects().SelectMany(go => go.GetComponentsInChildren<NavMeshSurface>()).FirstOrDefault();
            //if (navMeshSurface == null)
            //{
            //    Debug.LogError("No NavMeshSurface found in the scene.");
            //    yield break;
            //}
            //// Set the AgentTypeID for the NavMeshSurface before baking
            //navMeshSurface.agentTypeID = agentTypeID;
            //// Bake the NavMesh
            //navMeshSurface.BuildNavMesh();
            List<SpawnInfo> mobGroups = new List<SpawnInfo>();
            mobGroups = GetSpawnInfo(SpawnPoints);
            Tilemap Walls = Wall.GetComponent<Tilemap>();
            GameObject newTurnManager = Instantiate (turnManagerPrefab);
            TurnManager turnManager = newTurnManager.GetComponent<TurnManager>();  
            turnManager.SetMatchSerial(match.matchSerial, match, Walls, matchIndex + 2,  null, true, true);
            List<PlayerCharacter> PCListOne = SpawnPlayerCharactersDuel(duelScript.PlayerOne, match, turnManager, scene, CharacterSpawnStartOne);
            List<PlayerCharacter> PCListTwo = SpawnPlayerCharactersDuel(duelScript.PlayerTwo, match, turnManager, scene, CharacterSpawnStartTwo);
            List<MovingObject> MOsOne = new List<MovingObject>();
            foreach(var pc in PCListOne){
                MOsOne.Add(pc);
            }
            List<MovingObject> MOsTwo = new List<MovingObject>();
            foreach(var pc in PCListTwo){
                MOsTwo.Add(pc);
            }
            turnManager.SetPCList(PCListOne);
            turnManager.SetPCList(PCListTwo);
            duelScript.PlayerOne.ServerSetFriends(MOsOne);
            duelScript.PlayerTwo.ServerSetFriends(MOsTwo);
            turnManager.AddPlayer(duelScript.PlayerOne, MOsOne);
            turnManager.AddPlayer(duelScript.PlayerTwo, MOsTwo);
            foreach(var tmPlayer in turnManager.GetPlayers()){
                tmPlayer.TargetWalls(turnManager.reservationWalls);
            }
            SceneManager.MoveGameObjectToScene(newTurnManager, scene);
            if(duelScript.PlayerOne.currentScene == TOWNOFARUDINE){
                duelScript.PlayerOne.connectionToClient.Send(new SceneMessage { sceneName = TOWNOFARUDINE, sceneOperation = SceneOperation.UnloadAdditive});
                duelScript.PlayerOne.lastScene = TOWNOFARUDINE;
            }
            if(duelScript.PlayerOne.currentScene == OVM){
                duelScript.PlayerOne.connectionToClient.Send(new SceneMessage { sceneName = OVM, sceneOperation = SceneOperation.UnloadAdditive});
                duelScript.PlayerOne.lastScene = OVM;
            }
            if(duelScript.PlayerTwo.currentScene == TOWNOFARUDINE){
                duelScript.PlayerTwo.connectionToClient.Send(new SceneMessage { sceneName = TOWNOFARUDINE, sceneOperation = SceneOperation.UnloadAdditive});
                duelScript.PlayerTwo.lastScene = TOWNOFARUDINE;
            }
            if(duelScript.PlayerTwo.currentScene == OVM){
                duelScript.PlayerTwo.connectionToClient.Send(new SceneMessage { sceneName = OVM, sceneOperation = SceneOperation.UnloadAdditive});
                duelScript.PlayerTwo.lastScene = OVM;
            }
            duelScript.PlayerOne.currentScene = nodeName;
            duelScript.PlayerTwo.currentScene = nodeName;
            foreach(var pMember in match.playerSlotPairs){
                for(int pc = 0; pc < duelScript.PlayerOne.GetFriendlyList().Count; pc++){
                    PlayerCharacter pcChecker = duelScript.PlayerOne.GetFriendlyList()[pc].GetComponent<PlayerCharacter>();
                    if(pcChecker){
                        if(pcChecker.CharID == pMember.slot){
                            print($"Added {pcChecker.CharacterName} to match party list One");
                            duelScript.PlayerOne.AddMatchPartyListServer(pMember.slot);
                            break;
                        }
                    }
                }
            }
            foreach(var pMember in match.playerSlotPairs){
                for(int pc = 0; pc < duelScript.PlayerTwo.GetFriendlyList().Count; pc++){
                    PlayerCharacter pcChecker = duelScript.PlayerTwo.GetFriendlyList()[pc].GetComponent<PlayerCharacter>();
                    if(pcChecker){
                        if(pcChecker.CharID == pMember.slot){
                            print($"Added {pcChecker.CharacterName} to match party list Two");
                            duelScript.PlayerTwo.AddMatchPartyListServer(pMember.slot);
                            break;
                        }
                    }
                }
            }
            duelScript.PlayerOne.x = duelScript.PlayerOne.gameObject.transform.position.x.ToString();
            duelScript.PlayerOne.y = duelScript.PlayerOne.gameObject.transform.position.y.ToString();
            NavMeshAgent meshOne = duelScript.PlayerOne.GetComponent<NavMeshAgent>();
            meshOne.enabled = false;
            duelScript.PlayerTwo.x = duelScript.PlayerTwo.gameObject.transform.position.x.ToString();
            duelScript.PlayerTwo.y = duelScript.PlayerTwo.gameObject.transform.position.y.ToString();
            NavMeshAgent meshTwo = duelScript.PlayerTwo.GetComponent<NavMeshAgent>();
            meshTwo.enabled = false;
            SceneManager.MoveGameObjectToScene(duelScript.PlayerOne.gameObject, scene);
            SceneManager.MoveGameObjectToScene(duelScript.PlayerTwo.gameObject, scene);
            List<Mob> mobs = new List<Mob>();
            List<Mob> mainChestMobs = new List<Mob>();
            foreach (var info in mobGroups)
            {
                // Get the correct prefab based on the enemy name saved in the SpawnInfo
                GameObject prefabToSpawn = GetPrefabByName(info.PointName, null);
                // Instantiate the prefab at the SpawnInfo's transform
                if (prefabToSpawn != null)
                {
                    Mob mob = null;
                    GameObject Mob = Instantiate(prefabToSpawn, info.SpawnTransform.position, Quaternion.identity);
                    NetworkServer.Spawn(Mob);
                    mob = Mob.GetComponent<Mob>();
                    //print($"{mob.cur_hp} is {mob.NAME}'s current HP");
                    mobs.Add(mob);
                    if(info.MainChestLinked){
                        mainChestMobs.Add(mob);
                    }
                    mob.groupNumber = info.GroupName;
                    mob.Origin = info.SpawnTransform.position;
                    mob.SetUpCharacter(turnManager, info.SpawnTransform.position, info.SpawnTransform.position);
                    mob.SetMATCH(match);
                    SceneManager.MoveGameObjectToScene(Mob, SceneManager.GetSceneAt(matchIndex + 2));
                    if (!turnManager.MobGroups.ContainsKey(info.GroupName))
                    {
                        // If the group doesn't exist, create a new list for this group
                        turnManager.MobGroups[info.GroupName] = new List<Mob>();
                    }
                    turnManager.MobGroups[info.GroupName].Add(mob);
                }
            }
            duelScript.PlayerOne.connectionToClient.Send(new SceneMessage { sceneName = nodeName, sceneOperation = SceneOperation.LoadAdditive , customHandling = true});
            duelScript.PlayerTwo.connectionToClient.Send(new SceneMessage { sceneName = nodeName, sceneOperation = SceneOperation.LoadAdditive , customHandling = true});
            duelScript.PlayerOne.transform.position = GetPlayerPositionWithOffset(MOsOne);
            duelScript.PlayerTwo.transform.position = GetPlayerPositionWithOffset(MOsTwo);
            //Vector3 nodeCoordinatesOne = GetPlayerPositionWithOffset(MOsOne);
            //Vector3 nodeCoordinatesTwo = GetPlayerPositionWithOffset(MOsTwo);
            //StartCoroutine(PausedOVMMovement(duelScript.PlayerOne.gameObject, nodeCoordinatesOne));
            //StartCoroutine(PausedOVMMovement(duelScript.PlayerTwo.gameObject, nodeCoordinatesTwo));
            StartCoroutine(ToggleLoadBarOffWait(duelScript.PlayerOne));
            StartCoroutine(ToggleLoadBarOffWait(duelScript.PlayerTwo));
            turnManager.SetMobList(mobs);
            List<GameObject> addedObjects = new List<GameObject>();
            foreach(var GO in PCListOne){
                addedObjects.Add(GO.gameObject);
            }
            foreach(var GO in PCListTwo){
                addedObjects.Add(GO.gameObject);
            }
            MoveCharactersAndEnviornment(addedObjects, scenePosition);
            duelScript.PlayerOne.GetConnection().Send<OffsetRecord>(new OffsetRecord {
                SceneName = nodeName,
                SceneOffset = scenePosition
            });
            duelScript.PlayerTwo.GetConnection().Send<OffsetRecord>(new OffsetRecord {
                SceneName = nodeName,
                SceneOffset = scenePosition
            });
            
            yield return new WaitForSeconds(1f);
            duelScript.PlayerOne.RpcSetFriends(MOsOne);
            duelScript.PlayerTwo.RpcSetFriends(MOsTwo);
            List<PlayerCharacter> PCs = turnManager.GetPCList();
            foreach(var pc in PCs){
                pc.EnergySpark(pc, agentType);
            }
            List<Mob> Mobs = turnManager.GetENEMYList();
            List<MovingObject> Enemies = new List<MovingObject>();
            foreach(var mob in Mobs){
                MovingObject mo = mob.GetComponent<MovingObject>();
                Enemies.Add(mo);
            }
            foreach(var mob in Mobs){
                mob.EnergySpark(mob, agentType);
            }
            yield return new WaitForSeconds(1f);
            turnManager.StartUpSendPCUI();
            foreach(var player in turnManager.GetPlayers()){
                player.TargetSendMobList(Enemies);
                player.ServerChangingScenesCheck();
            }
            foreach(var mob in Mobs){
                mob.SetMobReady();
            }
            foreach(var pc in PCs){
                pc.SetPlayerReady();
            }
            duelScript.PlayerOne.TargetShowPartyCombatView();
            duelScript.PlayerTwo.TargetShowPartyCombatView();
            foreach(var mob in Mobs){
                mob.ActivateThreatSystem();
            }
        }
        bool GetInside(string nodeName){
            if(nodeName == "Random_Forest_1_1"){
                return false;
            }
            if(nodeName == "Random_Forest_1_2"){
                return false;
            }
            if(nodeName == "Random_Forest_1_3"){
                return false;
            }
            if(nodeName == "Lake Arudine"){
                return false;
            }
            if(nodeName == "Spider Caverns"){
                return true;
            }
            if(nodeName == "Sequoia Forest"){
                return true;
            }
            if(nodeName == "Sewers level 1 story"){
                return false;
            }
            if(nodeName == "Sewers level 2 story"){
                return false;
            }
            if(nodeName == "Sewers level 3 story"){
                return false;
            }
            if(nodeName == "Sewers level 4 story"){
                return false;
            }
            return false;
        }
        IEnumerator CreateMatchSolo(int matchIndex, string nodeName, Match match, ScenePlayer Host, bool random, bool login)
        {
            Host.CanUpdateOVM = false;
            print("Solo Start");
            SceneNode matchNode = null;
            if(!random){
                foreach(var key in sceneNodesDictionary){
                    if(key.Key == nodeName){
                        matchNode = key.Value;
                        break;
                    }
                }
            }
            print("Solo 1");
            string agentType = "";
            Vector3 CharacterSpawnStart = CharacterSpawnerPosition(nodeName, Host);
            
            string priorSewerMatch = Host.currentScene;            
            if(nodeName == "Spider Caverns South" || nodeName == "Spider Caverns North"){
                nodeName = "Spider Caverns";
            }
            if(nodeName == "Random_Forest_1_1"){
                agentType = "Forest_1_1";
            }
            if(nodeName == "Random_Forest_1_2"){
                agentType = "Forest_1_2";
            }
            if(nodeName == "Random_Forest_1_3"){
                agentType = "Forest_1_3";
            }
            if(nodeName == "Lake Arudine"){
                agentType = "LakeArudine";
            }
            if(nodeName == "Spider Caverns"){
                agentType = "SpiderCaverns";
            }
            if(nodeName == "Sequoia Forest"){
                agentType = "SequoiaForest";
            }
            if(nodeName == "Sewers level 1 story"){
                agentType = "SewersStoryOne";
            }
            if(nodeName == "Sewers level 2 story"){
                agentType = "SewersStoryTwo";
                //priorSewerMatch = "Sewers level 1 story";
            }
            if(nodeName == "Sewers level 3 story"){
                agentType = "SewersStoryThree";
                //priorSewerMatch = "Sewers level 2 story";
            }
            if(nodeName == "Sewers level 4 story"){
                agentType = "SewersStoryFour";
                //priorSewerMatch = "Sewers level 3 story";
            }
            bool inside = GetInside(nodeName);

            print($"Agent type for this solo match was {agentType}");

            print("Solo 2");
            //string direction = DetermineDirection(Host.transform, noderect);
            yield return SceneManager.LoadSceneAsync(nodeName, new LoadSceneParameters { loadSceneMode = LoadSceneMode.Additive, localPhysicsMode = LocalPhysicsMode.Physics2D });
            Debug.Log($"Spawned scene {SceneManager.GetSceneAt(matchIndex + 2).name}");
            // Move the scene to a non-overlapping position
            
            MatchList.Add(match, SceneManager.GetSceneAt(matchIndex + 2));
            Scene scene = SceneManager.GetSceneAt(matchIndex + 2);
            Vector3 scenePosition = new Vector3(UnityEngine.Random.Range(0, 10000), UnityEngine.Random.Range(0, 10000), 0); // Adjust range as needed
            MoveSceneToPosition(scene, scenePosition);
            //GameObject Evacuation = null;
            GameObject Wall = null;
            //GameObject Floor = null;
            GameObject MainChest = null;
            //GameObject Doors = null;
            //GameObject PatrolPaths = null;
            GameObject SpawnPoints = null;
            //GameObject CharacterSpawnPoint = null;

            GameObject[] rootObjects = scene.GetRootGameObjects();
            foreach (GameObject rootObject in rootObjects)
            {
                //if(CharacterSpawnPoint == null){
                //    CharacterSpawnPoint = FindGameObjectInChildren(rootObject, "CharacterSpawner");
                //}
                if(Wall == null){
                    Wall = FindGameObjectInChildren(rootObject, "Walls");
                }
                if(MainChest == null){
                    MainChest = FindGameObjectInChildren(rootObject, "MainChest");
                }
                //if(Doors == null){
                //    Doors = FindGameObjectInChildren(rootObject, "Doors");
                //}
                //if(PatrolPaths == null){
                //    PatrolPaths = FindGameObjectInChildren(rootObject, "PatrolPaths");
                //}
                if(SpawnPoints == null){
                    SpawnPoints = FindGameObjectInChildren(rootObject, "MobSpawnPoints");
                }
                //if (Floor && Wall && Evacuation && MainChest && Doors && SpawnPoints && CharacterSpawnPoint) // && PatrolPaths
                if (MainChest && SpawnPoints && Wall ) // && PatrolPaths && CharacterSpawnPoint && Doors
                {
                    break;
                }
            }
            //int agentTypeID = GenerateUniqueAgentTypeID(match);
            //NavMeshSurface navMeshSurface = scene.GetRootGameObjects().SelectMany(go => go.GetComponentsInChildren<NavMeshSurface>()).FirstOrDefault();
            //if (navMeshSurface == null)
            //{
            //    Debug.LogError("No NavMeshSurface found in the scene.");
            //    yield break;
            //}
            //// Set the AgentTypeID for the NavMeshSurface before baking
            //navMeshSurface.agentTypeID = agentTypeID;
            //// Bake the NavMesh
            //navMeshSurface.BuildNavMesh();
            List<SpawnInfo> mobGroups = new List<SpawnInfo>();
            mobGroups = GetSpawnInfo(SpawnPoints);
            //Tilemap EvacPoints = Evacuation.GetComponent<Tilemap>();
            //Tilemap Floors = Floor.GetComponent<Tilemap>();
            Tilemap Walls = Wall.GetComponent<Tilemap>();
            // Get positions of other objects and their children
            Vector3 mainChestPosition = MainChest.transform.position;
            MainChest mainChest = null;
            DroppableManager dropManager = null;
            if(MainChest != null){
                //print("We had a MainChest!");
                mainChest = CreateMainChest(MainChest, scene, match);
                dropManager = MainChest.GetComponent<DroppableManager>();
                if(dropManager != null){
                   // print("We had a dropManager so far so good");
                    (List<GameObject> armorRacks, List<GameObject> weaponRacks, List<GameObject> miniChests, List<GameObject> traps, List<GameObject> woodNodes, List<GameObject> clothNodes, List<GameObject> oreNodes, List<GameObject> stoneNodes, List<GameObject> leatherNodes) = dropManager.GetPickedObjects();
                    InstantiateArmorRacks(armorRacks, scene, match);
                    InstantiateWeaponRacks(weaponRacks, scene, match);
                    InstantiateMiniChests(miniChests, scene, match);
                    InstantiateTraps(traps, scene, match);
                    InstantiateClothNode(clothNodes, scene, match);
                    InstantiateWoodNode(woodNodes, scene, match);
                    InstantiateOreNode(oreNodes, scene, match);
                    InstantiateStoneNode(stoneNodes, scene, match);
                    InstantiateRawHideNode(leatherNodes, scene, match);
                }
            }
            //List<Vector3> doorPositions = GetChildPositions(Doors);
            //Dictionary<string, HashSet<Vector3>> patrolPathPositions = new Dictionary<string, HashSet<Vector3>>();
            //if(PatrolPaths != null){
            //    patrolPathPositions = GetNestedChildPositions(PatrolPaths).ToDictionary(kvp => kvp.Key, kvp => new HashSet<Vector3>(kvp.Value));
            //}
            //yield return new WaitForSeconds(1f);  
            if(!login && !random && !nodeName.Contains("Sewers")){
                AuthorizeEnergyUpdate(Host, matchNode.EnergyEnterNodeCost);//needs foreach for multiplayer
            }
            if(!login && !random && !nodeName.Contains("Sewers")){
                Host.TargetGetReadyForStart();//needs foreach for mutli
            }
            GameObject newTurnManager = Instantiate (turnManagerPrefab);
            TurnManager turnManager = newTurnManager.GetComponent<TurnManager>();          
            //turnManager.SetMatchSerial(match.matchSerial, match, Floors, Walls, EvacPoints, matchIndex + 2);
            turnManager.SetMatchSerial(match.matchSerial, match, Walls, matchIndex + 2, mainChest, false, inside);

           
            SceneManager.MoveGameObjectToScene(newTurnManager, scene);
            
           // yield return new WaitForEndOfFrame();  
            if(!login){
                if(nodeName.Contains("Sewers")){
                    if(Host.currentScene == "TOWNOFARUDINE"){
                        Host.connectionToClient.Send(new SceneMessage { sceneName = TOWNOFARUDINE, sceneOperation = SceneOperation.UnloadAdditive});
                        Host.lastScene = TOWNOFARUDINE;
                    }// else {
                        //Host.connectionToClient.Send(new SceneMessage { sceneName = priorSewerMatch, sceneOperation = SceneOperation.UnloadAdditive});
                    //}
                } else {
                    Host.connectionToClient.Send(new SceneMessage { sceneName = OVM, sceneOperation = SceneOperation.UnloadAdditive});
                    Host.lastScene = OVM;
                }
            }
            GameObject playerObject = Host.gameObject;
            int playerIndex = Host.playerIndex;
            float xOffset = playerIndex;
            Host.currentScene = nodeName;
            //Host.currentNode = nodeName;
            foreach(var pMember in Host.currentMatch.playerSlotPairs){
                Host.AddMatchPartyListServer(pMember.slot);
            }
            if(!login){
                Host.x = Host.gameObject.transform.position.x.ToString();
                Host.y = Host.gameObject.transform.position.y.ToString();
            }
            print($"{Host.x} is our X start, {Host.y} is our host y start ");
            NavMeshAgent mesh = Host.GetComponent<NavMeshAgent>();
            mesh.enabled = false;
            SceneManager.MoveGameObjectToScene(Host.gameObject, scene);
            (List<MovingObject> PCList, Dictionary<string, float> trackingDict) = SpawnPlayerCharactersSolo(Host, match, turnManager, scene, CharacterSpawnStart);
            turnManager.AddPlayer(Host, PCList);
            Host.ServerSetFriends(PCList);

            foreach(var tmPlayer in turnManager.GetPlayers()){
                tmPlayer.TargetWalls(turnManager.reservationWalls);
            }
            //yield return new WaitForEndOfFrame();  
            List<Mob> mobs = new List<Mob>();
            List<Mob> mainChestMobs = new List<Mob>();
            foreach (var info in mobGroups)
            {
                // Get the correct prefab based on the enemy name saved in the SpawnInfo
                GameObject prefabToSpawn = GetPrefabByName(info.PointName, trackingDict);
                // Instantiate the prefab at the SpawnInfo's transform
                if (prefabToSpawn != null)
                {
                    Mob mob = null;
                    GameObject Mob = Instantiate(prefabToSpawn, info.SpawnTransform.position, Quaternion.identity);
                    NetworkServer.Spawn(Mob);
                    mob = Mob.GetComponent<Mob>();
                    //print($"{mob.cur_hp} is {mob.NAME}'s current HP");
                    mobs.Add(mob);
                    if(info.MainChestLinked){
                        mainChestMobs.Add(mob);
                    }
                    mob.groupNumber = info.GroupName;
                    mob.Origin = info.SpawnTransform.position;
                    mob.SetUpCharacter(turnManager, info.SpawnTransform.position, info.SpawnTransform.position);
                    mob.SetMATCH(match);
                    //foreach (var kvp in patrolPathPositions)
                    //{
                    //    if (kvp.Value.Contains(info.SpawnTransform.position))
                    //    {
                    //        Debug.Log("Path found for group " + kvp.Key);
                    //        mob.PatrolPath = kvp.Value.ToList();
                    //    }
                    //}
                    SceneManager.MoveGameObjectToScene(Mob, SceneManager.GetSceneAt(matchIndex + 2));
                    if (!turnManager.MobGroups.ContainsKey(info.GroupName))
                    {
                        // If the group doesn't exist, create a new list for this group
                        turnManager.MobGroups[info.GroupName] = new List<Mob>();
                    }
                    turnManager.MobGroups[info.GroupName].Add(mob);
                }
            }
            mainChest.FillOutMainChest(mainChestMobs, match);
            string tName = string.Empty;
            foreach(var stat in Host.GetTacticianSheet().TacticianStatData){
                if(stat.Key == "TacticianName"){
                    tName = stat.Value;
                    break;
                }
            }
            print($"Starting game for {tName}");
            Host.connectionToClient.Send(new SceneMessage { sceneName = nodeName, sceneOperation = SceneOperation.LoadAdditive , customHandling = true});
            Host.transform.position  = GetPlayerPositionWithOffset(PCList);
            turnManager.SetMobList(mobs);
            List<GameObject> addedObjects = new List<GameObject>();
            foreach(var GO in PCList){
                addedObjects.Add(GO.gameObject);
            }
            MoveCharactersAndEnviornment(addedObjects, scenePosition);
            Host.GetConnection().Send<OffsetRecord>(new OffsetRecord {
                SceneName = nodeName,
                SceneOffset = scenePosition
            });
            StartCoroutine(ToggleLoadBarOffWait(Host));
            
            yield return new WaitForSeconds(2f);
                Host.RpcSetFriends(PCList);

            List<PlayerCharacter> PCs = turnManager.GetPCList();
            foreach(var pc in PCs){
                pc.EnergySpark(pc, agentType);
            }
            List<Mob> Mobs = turnManager.GetENEMYList();
            List<MovingObject> Enemies = new List<MovingObject>();
            foreach(var mob in Mobs){
                MovingObject mo = mob.GetComponent<MovingObject>();
                Enemies.Add(mo);
            }
            foreach(var mob in Mobs){
                mob.EnergySpark(mob, agentType);
            }
            yield return new WaitForSeconds(1f);
            turnManager.StartUpSendPCUI();

            foreach(var player in turnManager.GetPlayers()){
                player.TargetSendMobList(Enemies);
                player.ServerChangingScenesCheck();
            }
            foreach(var mob in Mobs){
                mob.SetMobReady();
            }
            foreach(var pc in PCs){
                pc.SetPlayerReady();
            }
            
            //if (Doors != null)
            //{
            //    InstantiateDoors(Doors, scene, match);
            //}
            Host.TargetShowPartyCombatView();
            foreach(var mob in Mobs){
                mob.ActivateThreatSystem();
            }
            if(Host.EXPCPRoutine != null){
                StopCoroutine(Host.EXPCPRoutine);
                Host.EXPCPRoutine = null;
            }
            Host.EXPCPRoutine = Host.StartCoroutine(Host.SendRpcQueue());
        }
        private int GenerateUniqueAgentTypeID(Match match)
        {
            // You can use match properties or a unique identifier to generate a unique ID
            return match.GetHashCode(); // This is a simple example, adjust as needed
        }

        private void MoveSceneToPosition(Scene scene, Vector3 position)
        {
            foreach (GameObject rootObject in scene.GetRootGameObjects())
            {
                rootObject.transform.position += position;
            }
        }
        private void MoveCharactersAndEnviornment(List<GameObject> addedObjects, Vector3 position)
        {
            foreach (GameObject addedObject in addedObjects)
            {
                addedObject.transform.position += position;
            }
        }
        IEnumerator CreateMatch(int matchIndex, string nodeName, Match match, ScenePlayer Host, List<ScenePlayer> playerScripts)
        {
            Host.CanUpdateOVM = false;
            foreach(var player in playerScripts){
                if(player.CanUpdateOVM){
                    player.CanUpdateOVM = false;
                }
            }
            SceneNode matchNode = null;
            foreach(var key in sceneNodesDictionary){
                if(key.Key == nodeName){
                    matchNode = key.Value;
                    break;
                }
            }
            Vector3 CharacterSpawnStart = CharacterSpawnerPosition(nodeName, Host);
            string agentType = "";
            if(nodeName == "Spider Caverns South" || nodeName == "Spider Caverns North"){
                nodeName = "Spider Caverns";
            }
            if(nodeName == "Random_Forest_1_1"){
                agentType = "Forest_1_1";
            }
            if(nodeName == "Random_Forest_1_2"){
                agentType = "Forest_1_2";
            }
            if(nodeName == "Random_Forest_1_3"){
                agentType = "Forest_1_3";
            }
            if(nodeName == "Lake Arudine"){
                agentType = "LakeArudine";
            }
            if(nodeName == "Spider Caverns"){
                agentType = "SpiderCaverns";
            }
            if(nodeName == "Sequoia Forest"){
                agentType = "SequoiaForest";
            }
            bool inside = GetInside(nodeName);
            yield return SceneManager.LoadSceneAsync(nodeName, new LoadSceneParameters { loadSceneMode = LoadSceneMode.Additive, localPhysicsMode = LocalPhysicsMode.Physics2D });
            Debug.Log($"Spawned scene {SceneManager.GetSceneAt(matchIndex + 2).name}");
            MatchList.Add(match, SceneManager.GetSceneAt(matchIndex + 2));
            Scene scene = SceneManager.GetSceneAt(matchIndex + 2);
            Vector3 scenePosition = new Vector3(UnityEngine.Random.Range(0, 10000), UnityEngine.Random.Range(0, 10000), 0); // Adjust range as needed
            MoveSceneToPosition(scene, scenePosition);
            //GameObject Evacuation = null;
            GameObject Wall = null;
            //GameObject Floor = null;
            GameObject MainChest = null;
            GameObject Doors = null;
            ////GameObject PatrolPaths = null;
            GameObject SpawnPoints = null;
            //GameObject CharacterSpawnPoint = null;
            GameObject[] rootObjects = scene.GetRootGameObjects();
            foreach (GameObject rootObject in rootObjects)
            {
                //if(CharacterSpawnPoint == null){
                //    CharacterSpawnPoint = FindGameObjectInChildren(rootObject, "CharacterSpawner");
                //}
                if(Wall == null){
                    Wall = FindGameObjectInChildren(rootObject, "Walls");
                }
                if(MainChest == null){
                    MainChest = FindGameObjectInChildren(rootObject, "MainChest");
                }
                if(Doors == null){
                    Doors = FindGameObjectInChildren(rootObject, "Doors");
                }
                //if(PatrolPaths == null){
                //    PatrolPaths = FindGameObjectInChildren(rootObject, "PatrolPaths");
                //}
                if(SpawnPoints == null){
                    SpawnPoints = FindGameObjectInChildren(rootObject, "MobSpawnPoints");
                }
                //if (Floor && Wall && Evacuation && MainChest && Doors && Traps && SpawnPoints && CharacterSpawnPoint) // && PatrolPaths
                if (MainChest && SpawnPoints && Wall && Doors) // && PatrolPaths && CharacterSpawnPoint
                {
                    break;
                }
            }
            //int agentTypeID = GenerateUniqueAgentTypeID(match);
            //NavMeshSurface navMeshSurface = scene.GetRootGameObjects().SelectMany(go => go.GetComponentsInChildren<NavMeshSurface>()).FirstOrDefault();
            //if (navMeshSurface == null)
            //{
            //    Debug.LogError("No NavMeshSurface found in the scene.");
            //    yield break;
            //}
            //// Set the AgentTypeID for the NavMeshSurface before baking
            //navMeshSurface.agentTypeID = agentTypeID;
            //// Bake the NavMesh
            //navMeshSurface.BuildNavMesh();
            List<SpawnInfo> mobGroups = new List<SpawnInfo>();
            mobGroups = GetSpawnInfo(SpawnPoints);
            //Tilemap EvacPoints = Evacuation.GetComponent<Tilemap>();
            //Tilemap Floors = Floor.GetComponent<Tilemap>();
            Tilemap Walls = Wall.GetComponent<Tilemap>();
            // Get positions of other objects and their children
            Vector3 mainChestPosition = MainChest.transform.position;
            MainChest mainChest = null;
            DroppableManager dropManager = null;
            if(MainChest != null){
                mainChest = CreateMainChest(MainChest, scene, match);
                dropManager = MainChest.GetComponent<DroppableManager>();
                if(dropManager != null){
                    //print("We had a dropManager so far so good");
                    
                    (List<GameObject> armorRacks, List<GameObject> weaponRacks, List<GameObject> miniChests, List<GameObject> traps, List<GameObject> woodNodes, List<GameObject> clothNodes, List<GameObject> oreNodes, List<GameObject> stoneNodes, List<GameObject> leatherNodes) = dropManager.GetPickedObjects();
                    //foreach(var ar in armorRacks){
                    //    print($"{ar.gameObject.name} was in armor list");
                    //}
                    //foreach(var wr in weaponRacks){
                    //    print($"{wr.gameObject.name} was in weapon list");
                    //}
                    //foreach(var mc in miniChests){
                    //    print($"{mc.gameObject.name} was in mini chest list");
                    //}
                    //foreach(var trap in traps){
                    //    print($"{trap.gameObject.name} was in trap list");
                    //}
                    InstantiateArmorRacks(armorRacks, scene, match);
                    InstantiateWeaponRacks(weaponRacks, scene, match);
                    InstantiateMiniChests(miniChests, scene, match);
                    InstantiateTraps(traps, scene, match);
                    InstantiateClothNode(clothNodes, scene, match);
                    InstantiateWoodNode(woodNodes, scene, match);
                    InstantiateOreNode(oreNodes, scene, match);
                    InstantiateStoneNode(stoneNodes, scene, match);
                    InstantiateRawHideNode(leatherNodes, scene, match);
                }
            }
            //List<Vector3> doorPositions = GetChildPositions(Doors);
            //Dictionary<string, HashSet<Vector3>> patrolPathPositions = new Dictionary<string, HashSet<Vector3>>();
            //if(PatrolPaths != null){
            //    patrolPathPositions = GetNestedChildPositions(PatrolPaths).ToDictionary(kvp => kvp.Key, kvp => new HashSet<Vector3>(kvp.Value));
            //}
           // yield return new WaitForSeconds(1f);  

            foreach(var tactician in playerScripts){
                //AuthorizeEnergyUpdate(tactician, matchNode.EnergyEnterNodeCost);
                tactician.TargetGetReadyForStart();
                tactician.lastScene = tactician.currentScene;
                tactician.currentScene = nodeName;
                //tactician.currentNode = nodeName;
            }
            foreach(var slot in Host.currentMatch.playerSlotPairs){
                foreach(var splay in playerScripts){
                    splay.AddMatchPartyListServer(slot.slot);
                }
            }
            GameObject newTurnManager = Instantiate (turnManagerPrefab);
            TurnManager turnManager = newTurnManager.GetComponent<TurnManager>();          
            //turnManager.SetMatchSerial(match.matchSerial, match, Floors, Walls, EvacPoints, matchIndex + 2);
            turnManager.SetMatchSerial(match.matchSerial, match, Walls, matchIndex + 2, mainChest, false, inside);

            //turnManager.AddPlayers(playerScripts);
            
            SceneManager.MoveGameObjectToScene(newTurnManager, scene);
            yield return new WaitForEndOfFrame();  
            foreach(var tactician in playerScripts){
                tactician.x = tactician.gameObject.transform.position.x.ToString();
                tactician.y = tactician.gameObject.transform.position.y.ToString();
                NavMeshAgent mesh = tactician.GetComponent<NavMeshAgent>();
                mesh.enabled = false;
                print($"{tactician.x} is our X start, {tactician.y} is our host y start ");
                tactician.connectionToClient.Send(new SceneMessage { sceneName = OVM, sceneOperation = SceneOperation.UnloadAdditive});
                SceneManager.MoveGameObjectToScene(tactician.gameObject, scene);
            }
            
            (List<MovingObject> PCList, Dictionary<string, float> trackingDict) = SpawnPlayerCharactersTeam(Host, CharacterSpawnStart,  match, turnManager, playerScripts, scene);
            foreach(var player in playerScripts){
                turnManager.AddPlayer(player, PCList);
                player.ServerSetFriends(PCList);
            }
            foreach(var tmPlayer in turnManager.GetPlayers()){
                tmPlayer.TargetWalls(turnManager.reservationWalls);
            }
            //turnManager.AddPlayer(Host, PCList);
            yield return new WaitForEndOfFrame();  
            List<Mob> mobs = new List<Mob>();
            List<Mob> mainChestMobs = new List<Mob>();
            foreach (var info in mobGroups)
            {
                // Get the correct prefab based on the enemy name saved in the SpawnInfo
                GameObject prefabToSpawn = GetPrefabByName(info.PointName, trackingDict);
                // Instantiate the prefab at the SpawnInfo's transform
                if (prefabToSpawn != null)
                {
                    Mob mob = null;
                    GameObject Mob = Instantiate(prefabToSpawn, info.SpawnTransform.position, Quaternion.identity);
                    NetworkServer.Spawn(Mob);
                    mob = Mob.GetComponent<Mob>();
                    ////print($"{mob.cur_hp} is {mob.NAME}'s current HP");
                    mobs.Add(mob);
                    if(info.MainChestLinked){
                        mainChestMobs.Add(mob);
                    }
                    mob.groupNumber = info.GroupName;
                    mob.SetUpCharacter(turnManager, info.SpawnTransform.position, info.SpawnTransform.position);
                    mob.SetMATCH(match);
                    //foreach (var kvp in patrolPathPositions)
                    //{
                    //    if (kvp.Value.Contains(info.SpawnTransform.position))
                    //    {
                    //        Debug.Log("Path found for group " + kvp.Key);
                    //        mob.PatrolPath = kvp.Value.ToList();
                    //    }
                    //}
                    SceneManager.MoveGameObjectToScene(Mob, SceneManager.GetSceneAt(matchIndex + 2));
                    if (!turnManager.MobGroups.ContainsKey(info.GroupName))
                    {
                        // If the group doesn't exist, create a new list for this group
                        turnManager.MobGroups[info.GroupName] = new List<Mob>();
                    }
                    turnManager.MobGroups[info.GroupName].Add(mob);
                }
            }
            mainChest.FillOutMainChest(mainChestMobs, match);
            turnManager.SetMobList(mobs);
            foreach(var tactician in playerScripts){
                string tName = string.Empty;
                foreach(var stat in tactician.GetTacticianSheet().TacticianStatData){
                    if(stat.Key == "TacticianName"){
                        tName = stat.Value;
                        break;
                    }
                }
                print($"Starting team game for {tName}");
                tactician.connectionToClient.Send(new SceneMessage { sceneName = nodeName, sceneOperation = SceneOperation.LoadAdditive , customHandling = true});
                StartCoroutine(ToggleLoadBarOffWait(tactician));
            }
            ChatManagerNode chatNode = MatchMaker.instance.GetChatManagerNodeByMatch(match);
            SceneManager.MoveGameObjectToScene(chatNode.gameObject, scene);
            List<GameObject> addedObjects = new List<GameObject>();
            foreach(var GO in PCList){
                addedObjects.Add(GO.gameObject);
            }
            MoveCharactersAndEnviornment(addedObjects, scenePosition);
            foreach(var play in playerScripts){
                //special camera control and scene object placement
                play.GetConnection().Send<OffsetRecord>(new OffsetRecord {
                    SceneName = nodeName,
                    SceneOffset = scenePosition
                });
            }
            //yield return new WaitForSeconds(4f);
            yield return new WaitForSeconds(1f);
            foreach(var player in playerScripts){
                player.RpcSetFriends(PCList);
            }
            List<PlayerCharacter> PCs = turnManager.GetPCList();
            foreach(var pc in PCs){
                pc.EnergySpark(pc, agentType);
            }
            List<Mob> Mobs = turnManager.GetENEMYList();
            List<MovingObject> Enemies = new List<MovingObject>();
            foreach(var mob in Mobs){
                MovingObject mo = mob.GetComponent<MovingObject>();
                Enemies.Add(mo);
            }
            foreach(var mob in Mobs){
                mob.EnergySpark(mob, agentType);
            }
            yield return new WaitForSeconds(1f);
            turnManager.StartUpSendPCUI();

            foreach(var player in turnManager.GetPlayers()){
                player.TargetSendMobList(Enemies);
            }
            foreach(var tactician in playerScripts){
                tactician.TargetShowPartyCombatView();
                tactician.ServerChangingScenesCheck();
            }

            foreach(var mob in Mobs){
                mob.SetMobReady();
            }
            foreach(var pc in PCs){
                pc.SetPlayerReady();
            }
            if (Doors != null)
            {
                InstantiateDoors(Doors, scene, match);
            }
            foreach(var mob in Mobs){
                mob.ActivateThreatSystem();
            }
            foreach(var play in playerScripts){
                if(play.EXPCPRoutine != null){
                    StopCoroutine(play.EXPCPRoutine);
                    play.EXPCPRoutine = null;
                }
                play.EXPCPRoutine = play.StartCoroutine(play.SendRpcQueue());
            }
            
            //add in the floors walls evac point, main chest, min chest, armor droppable, weapon droppable, hp trapsgreen, mp traps blue, Utility traps orange, Doors, patrol paths
        }
        List<Vector3> GetChildPositions(GameObject parent)
        {
            List<Vector3> positions = new List<Vector3>();
            foreach (Transform child in parent.transform)
            {
                positions.Add(child.position);
            }
            return positions;
        }
        Vector3 GetCharacterSpawnPosition(GameObject parent){
            Vector3 position = new Vector3();
            foreach (Transform child in parent.transform)
            {
                position = child.position;
            }
            return position;
        }
        
        Dictionary<string, HashSet<Vector3>> GetNestedChildPositions(GameObject parent)
        {
            Dictionary<string, HashSet<Vector3>> nestedPositions = new Dictionary<string, HashSet<Vector3>>();
            foreach (Transform child in parent.transform)
            {
                nestedPositions.Add(child.name, new HashSet<Vector3>(GetChildPositions(child.gameObject)));
            }
            return nestedPositions;
        }
         private GameObject FindGameObjectInChildren(GameObject parent, string name)
        {
            if (parent.name == name)
                return parent;
    
            for (int i = 0; i < parent.transform.childCount; i++)
            {
                GameObject child = parent.transform.GetChild(i).gameObject;
                GameObject result = FindGameObjectInChildren(child, name);
                if (result != null)
                    return result;
            }
    
            return null;
        }
        void ChatManagerNodeTOWNOFARUDINETransport(ChatManagerNode communicationNode)
        {
            SceneManager.MoveGameObjectToScene(communicationNode.gameObject, SceneManager.GetSceneByName("TOWNOFARUDINE"));
        }
        void ChatManagerNodeOVMTransport(ChatManagerNode communicationNode)
        {
            SceneManager.MoveGameObjectToScene(communicationNode.gameObject, SceneManager.GetSceneByName("OVM"));
        }
        IEnumerator SendingPlayers(ScenePlayer player, string nodeName){
            yield return new WaitForEndOfFrame();
            //print($" {nodeName} is the scene  we are supposed to be going to");
            foreach(var key in MatchList){
                if(key.Key == player.currentMatch){
                    //print($" {nodeName} is the scene  we are supposed to be going to");
                    player.connectionToClient.Send(new SceneMessage { sceneName = OVM, sceneOperation = SceneOperation.UnloadAdditive});
                    SceneManager.MoveGameObjectToScene(player.gameObject, key.Value);
                    yield return new WaitForEndOfFrame();
                    player.connectionToClient.Send(new SceneMessage { sceneName = nodeName, sceneOperation = SceneOperation.LoadAdditive , customHandling = true});
                }
            }
            yield return new WaitForEndOfFrame();
            player.TargetShowPartyCombatView();
            StartCoroutine(ToggleLoadBarOffWait(player));
            //player.TargetGatherSeekers();
        }
        void SendTurnManagerToPlayerCharacter(Match match, TurnManager turnManager, PlayerCharacter player, bool dead){
            player.curatorTM = turnManager;
            if(dead){
                StartCoroutine(SpawnDeathChar(player));
            }
        }
        IEnumerator SpawnDeathChar(PlayerCharacter player){
            yield return new WaitForSeconds(4f);
            player.ServerSpawnDeath();
        }
        public void SendTurnManagerToMatch(TurnManager turnManager, int serial, Match match)
        {
            foreach(var key in MatchList){
                if(key.Key == match){
                    SceneManager.MoveGameObjectToScene(turnManager.gameObject, key.Value);
                    //turnManager.SetMatchSerial(serial, key.Key);
                }
            }
        }
        public void SendChatManagerNodeToMatch(ChatManagerNode chatManager, int serial, Match match)
        {
            //print($"SendingChatManagerNode to match: {serial} at {match.matchNode}");
            foreach(var key in MatchList){
                if(key.Key == match){
                    SceneManager.MoveGameObjectToScene(chatManager.gameObject, key.Value);
                }
            }
        }
        public void SendMobToMatch(Mob mob, Match currentMatch)
        {
            foreach(var key in MatchList){
                if(key.Key == currentMatch){
                    SceneManager.MoveGameObjectToScene(mob.gameObject, key.Value);
                    mob.SetMATCH(key.Key);
                }
            }
        }

        void GetAllScenes(){
            int countLoaded = SceneManager.sceneCount;
            Scene[] loadedScenes = new Scene[countLoaded];
 
            for (int i = 0; i < countLoaded; i++)
            {
                loadedScenes[i] = SceneManager.GetSceneAt(i);
            }
            //print($"*******{countLoaded} is how many sceens are loaded on the server*******");
        }
        
        void UpdatePlayerOVMPosition(NetworkConnectionToClient nconn, string charliesTicket, string direction){
            #if UNITY_SERVER //|| UNITY_EDITOR
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            if(playerData.SessionTicket != charliesTicket)
            {
                //print($"{nconn.identity.gameObject} has been compromised, log information");
                return;
            }
            PlayFabServerAPI.AuthenticateSessionTicket(new AuthenticateSessionTicketRequest
            {
                SessionTicket = playerData.SessionTicket
            }, result =>
            {
                UpdatingPlayerOVM(nconn, playerData, direction);
            }, error =>{
                Debug.Log(error.ErrorMessage);
            });
            #endif
        }
        void UpdatingPlayerOVM(NetworkConnectionToClient nconn, PlayerInfo playerData, string direction){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            
            print($"{playerData.PlayFabId} REQUESTED UpdatingPlayerOVM");
            ScenePlayer player = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            string saveNode = "TOWNOFARUDINE";
            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
                {
                    PlayFabId = playerData.PlayFabId,
                    Data = new Dictionary<string, string>
                    {
                        //{"savedNode", saveNode},
                        {"LastScene", "OVM"}
                    }
                }, result =>
                {
                    player.TargetSendOVMRequest();
                    ClientRequestLoadScene dummy = new ClientRequestLoadScene {
                        oldScene = "TOWNOFARUDINE",
                        newScene = "OVM",
                        node = TOWNOFARUDINE,
                        direction = direction,
                        login = false
                    };
                    GetCleanedSceneName(nconn, dummy);
                }, error =>{
                    Debug.Log(error.ErrorMessage);
                });
                #endif
        }
        void GetCleanedSceneName(NetworkConnectionToClient conn, ClientRequestLoadScene msg){
            if(!CheckNullConnection(conn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)conn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED GetCleanedSceneName");
            GameObject player = conn.identity.gameObject;
            CircleCollider2D collider = player.GetComponent<CircleCollider2D>();
            NavMeshAgent agent = player.GetComponent<NavMeshAgent>();
            ScenePlayer q = player.GetComponent<ScenePlayer>();
            q.CanUpdateOVM = false;
            q.Combat = false;
            string agentTypeName = "TacticianTrack";
            q.CanTravel = false;
            if(msg.newScene != TOWNOFARUDINE){
                agentTypeName = "OVMTrack";
            }
            agent.enabled = false;
            // Find the corresponding agentTypeID
            int agentTypeID = -1;
            for (int i = 0; i < NavMesh.GetSettingsCount(); i++){
                var id = NavMesh.GetSettingsByIndex(i).agentTypeID;
                var name = NavMesh.GetSettingsNameFromID(id);
                if (name == agentTypeName){
                    agentTypeID = id;
                    break;
                }
            }
            if (agentTypeID != -1){
                // Now you can set the agentTypeID on your NavMeshAgent
                agent.agentTypeID = agentTypeID;
            } else {
                // Handle the case where the agent type wasn't found
                Debug.LogError("Could not find agent type: " + agentTypeName);
            }
            print($"{agentTypeName} was our tacticians agentType name");
            if(msg.newScene != "OVM" && msg.newScene != TOWNOFARUDINE){
                if(collider){
                    collider.enabled = false;
                }
            } else {
                if(collider){
                    collider.enabled = true;
                }
            }
            if(msg.oldScene != "Container" && msg.oldScene != msg.newScene){   
                conn.Send(new SceneMessage { sceneName = msg.oldScene, sceneOperation = SceneOperation.UnloadAdditive});
            }
            if(msg.oldScene == "Container"){
                q.lastScene = msg.newScene;
            } else {
                q.lastScene = msg.oldScene;
            }
            q.currentScene = msg.newScene;
            if(msg.oldScene != msg.newScene){
                //print($"{msg.oldScene} was our old msg scene {msg.newScene} was our new msg scene and it resulted in a transport of gameobject");
                SceneManager.MoveGameObjectToScene(conn.identity.gameObject, SceneManager.GetSceneByName(msg.newScene));
            }
            
            if(msg.newScene == "OVM"){
                q.ServerClearFriendly();
                if(msg.login){
                    Vector2 nodeCoordinates = new Vector2(float.Parse(q.x), float.Parse(q.y));
                StartCoroutine(PausedOVMMovement(player, nodeCoordinates));
                    //player.transform.position = nodeCoordinates;
                } else if(msg.oldScene == "TOWNOFARUDINE"){
                    float xnode = 0f;
                    float ynode = 0f;
                    if(msg.direction == "West"){
                        xnode = -37.5f;
                        ynode = -8.5f;
                    }
                    if(msg.direction == "East"){
                        xnode = -35.5f;
                        ynode = -8.5f;
                    }
                    if(msg.direction == "South"){
                        xnode = -36.5f;
                        ynode = -9.5f;
                    }
                    Vector2 nodeCoordinates = new Vector2(xnode, ynode);
                StartCoroutine(PausedOVMMovement(player, nodeCoordinates));
                    //player.transform.position = nodeCoordinates;
                } else {
                    if(msg.direction == "Random"){
                        float xcoord = float.Parse(q.x);
                        float ycoord = float.Parse(q.y);
                        Vector2 nodeCoordinates = new Vector2(xcoord, ycoord);
                        StartCoroutine(PausedOVMMovement(player, nodeCoordinates));
                        //player.transform.position = nodeCoordinates;
                        //print($"Starting from a random match on positions {q.x} and {q.y} in get cleaned, this must have been a from a node or random match!!");
                    } else {
                        string posDirection = msg.direction;
                        if(msg.GMTELEPORT){
                            posDirection = returnProperCoordName(msg.direction);
                        }
                        Vector2 nodeCoords = GetCoordinatesNodeExit(posDirection);
                        StartCoroutine(PausedOVMMovement(player, nodeCoords));
                        //player.transform.position = nodeCoords;
                        if(msg.GMTELEPORT){
                            q.TargetUpdateFogWorldTeleport(nodeCoords);
                        }
                    }
                }
                agent.speed = .25f;
                agent.obstacleAvoidanceType = ObstacleAvoidanceType.NoObstacleAvoidance; // No Avoidance
                agent.isStopped = false;
                q.ServerResetRandomChance();
                //q.TargetToggleSprite(true, q.loadSprite);
                //q.ServerMapSelect(false);
                q.SetOurNode(sceneNodesDictionary);
                agent.enabled = true;
            }
            if(msg.newScene == TOWNOFARUDINE){
                q.ServerClearFriendly();
                float playersX = 5.5f;
                float playersY = -5.5f;
                if(!string.IsNullOrEmpty(q.x)){
                    playersX = float.Parse(q.x);
                }
                if(!string.IsNullOrEmpty(q.y)){
                    playersY = float.Parse(q.y);
                }
                Vector2 nodeCoordinates = new Vector2(playersX, playersY);
                //player.transform.position = nodeCoordinates;
                if(msg.direction == "West"){
                    nodeCoordinates.x = -50.5f;
                    nodeCoordinates.y = 7f;
                }
                if(msg.direction == "South"){
                    nodeCoordinates.x = 8.5f;
                    nodeCoordinates.y = -52.5f;
                }
                if(msg.direction == "East"){
                    nodeCoordinates.x = 68f;
                    nodeCoordinates.y = 7f;
                }
                if(msg.direction == "Sewers"){
                    nodeCoordinates.x = 10.5f;
                    nodeCoordinates.y = 43.5f;
                }
                if(msg.direction == "Death"){
                    nodeCoordinates.x = -44.5f;
                    nodeCoordinates.y = -4.5f;
                }
                StartCoroutine(PausedOVMMovement(player, nodeCoordinates));
                //player.transform.position = nodeCoordinates;
                agent.obstacleAvoidanceType = ObstacleAvoidanceType.NoObstacleAvoidance; // No Avoidance
                agent.speed = 12f;
                agent.isStopped = false;
                //q.ServerMapSelect(true);
                agent.enabled = true;
                //print(agentTypeID + " was our agent id int");
                StartCoroutine(UnlockExits(q));
                //q.TargetToggleSprite(true, q.loadSprite);
                //agent.obstacleAvoidanceType = ObstacleAvoidanceType.LowQualityObstacleAvoidance; 
                //agent.obstacleAvoidanceType = ObstacleAvoidanceType.MedQualityObstacleAvoidance; 
                //agent.obstacleAvoidanceType = ObstacleAvoidanceType.GoodQualityObstacleAvoidance; 
                //agent.obstacleAvoidanceType = ObstacleAvoidanceType.HighQualityObstacleAvoidance; 
            }
            //if(q.currentScene == TOWNOFARUDINE && !msg.login){
            //    //q.TargetToggleSprite(false, q.loadSprite);
            //    q.TargetToggleSprite(true, q.loadSprite);
//
            //}
            if(msg.oldScene != msg.newScene){
                conn.Send(new SceneMessage { sceneName = msg.newScene, sceneOperation = SceneOperation.LoadAdditive , customHandling = true});
                q.ServerChangingScenesCheck();
                StartCoroutine(ToggleLoadBarOffWait(q));
            }
        }
        IEnumerator PausedOVMMovement(GameObject player, Vector2 nodeCoords){
            yield return new WaitForSeconds(.5f);
            NavMeshAgent agent = player.GetComponent<NavMeshAgent>();
            agent.Warp(nodeCoords);
            //player.transform.position = nodeCoords;
        }
        public Vector2 GetCoordinatesNodeExit(string direction)
        {
            // Hardcode your Vector2 coordinates for each direction
            Dictionary<string, Vector2> nodeCoordinatesMap = new Dictionary<string, Vector2>
            {
                { "Spider Caverns_North", new Vector2(-31.5f, 5.5f) },
                { "Spider Caverns_South", new Vector2(-32.5f, 2f) },
                { "Lake Arudine_South", new Vector2(-39.5f, -14.5f) },
                { "Lake Arudine_East", new Vector2(-38.5f, -13.5f) },
                { "Sequoia Forest_East", new Vector2(-30.5f, -8.5f) },
                { "Sequoia Forest_West", new Vector2(-32.5f, -8.5f) },
                { "TOWNOFARUDINE", new Vector2(-37.5f, -6.5f) }
                //{ "", new Vector2(-32.5f, -8.5f) }
                //{ "", new Vector2(-32.5f, -8.5f) }

                // Add more nodes as needed
            };

            // Check if the direction exists in the dictionary
            if (nodeCoordinatesMap.TryGetValue(direction, out Vector2 coordinates))
            {
                print(direction + coordinates + " were our direction and coordinates here for this node exit");
                return coordinates;
            }
            else
            {
                // Handle the case where the direction is not found.
                // You can either return a default value or throw an exception.
                return Vector2.zero;
            }
        }
        IEnumerator UnlockExits(ScenePlayer sPlayer){
            yield return new WaitForSeconds(8f);
            sPlayer.CanTravel = true;
        }
        public Vector2 GetNodeCoordinates(string nodeName)
        {
            float x = -36.5f;
            float y = -8.5f;

            switch (nodeName)
            {
                case "TOWNOFARUDINE":
                    x = -36.5f;
                    y = -8.5f;
                    break;
                case "Gates of Arudine":
                    x = -34.5f;
                    y = -8.5f;
                    break;
                case "Spider Caverns":
                    x = -1.82f;
                    y = 2.46f;
                    break;
                case "Lake Arudine":
                    x = 7.13f;
                    y = -6.88f;
                    break;
                default:
                    x = 5.99f;
                    y = -4.157f;
                    break;
            }

            return new Vector2(x, y);
        }
        IEnumerator ToggleLoadBarOffWait(ScenePlayer player){
            yield return new WaitForSeconds(4f);
            player.TargetToggleLoadBarOff();
            yield return new WaitForSeconds(5f);
            if(player.currentScene == "OVM"){
                player.CanUpdateOVM = true;
            } else {
                player.CanUpdateOVM = false;
            }
            //if (Mathf.Approximately(Mathf.Abs(player.gameObject.transform.rotation.eulerAngles.x), 90f))
            //{
            //    Vector3 currentRotation = player.gameObject.transform.rotation.eulerAngles;
            //    player.gameObject.transform.rotation = Quaternion.Euler(0f, player.gameObject.transform.rotation.y, player.gameObject.transform.rotation.z);
            //}
        }
        void ClearMatch(string matchID, int matchSerial, Match match){
            if(!MatchList.ContainsKey(match)){
                return;
            }
            EndtheGame(matchID, matchSerial, match);
        }
        void EndtheGame(string matchID, int matchIndex, Match match){
            if(!MatchList.ContainsKey(match)){
                return;
            }
            StartCoroutine(EndMatch(matchID, matchIndex, match));
        }

        IEnumerator EndMatch(string matchID, int matchSerial, Match match){
            if(!MatchList.ContainsKey(match)){
                yield break;
            }
            foreach(var key in MatchList){
                if(key.Key == match){
                    yield return SceneManager.UnloadSceneAsync(key.Value);
                }
            }
            ENDMATCHFULLY.Invoke(match); 
            MatchList.Remove(match);
        }
        private HashSet<Match> processingMatches = new HashSet<Match>();

        void WipeoutMatch(Match match, List<ScenePlayer> players){
            if(!MatchList.ContainsKey(match)){
                return;
            }
            if (processingMatches.Contains(match))
            {
                return;
            }
            #if UNITY_SERVER //|| UNITY_EDITOR

            //Wiped(match);
            StartCoroutine(WipedOutCompletelyWalkOfShame( match, players));
            #endif

        }
        #if UNITY_SERVER //|| UNITY_EDITOR
       
    IEnumerator WipedOutCompletelyWalkOfShame(Match match, List<ScenePlayer> players){
        if(!MatchList.ContainsKey(match)){
            yield break;
        }
        // Check if the match is already being processed
        if (processingMatches.Contains(match))
        {
            yield break;
        }
            
        // Add the match to the set of processing matches
        processingMatches.Add(match);
        //print("Got to finished match in playfab server");
        string saveNode = "TOWNOFARUDINE";
        foreach(var player in players){
            player.matchLeader = false;
            player.inMatch = false;   
            NetworkIdentity networkIdentity = player.GetComponent<NetworkIdentity>();
            NetworkConnectionToClient nconn = networkIdentity.connectionToClient;
            
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            bool leftMatch = false;
            PlayFabServerAPI.UpdateUserInternalData(new UpdateUserInternalDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                Data = new Dictionary<string, string>
                {
                    //{"savedNode", saveNode},
                    {"LastScene", saveNode}
                }
            }, result =>
            {
                    
                player.TargetCloseEndGameCanvas();
                if(nconn != null){
                    //print("We got the connection properly");
                }
                ClientRequestLoadScene dummy = new ClientRequestLoadScene {
                    oldScene = player.currentScene,
                    newScene = "TOWNOFARUDINE",
                    direction = "Death",
                    //node = player.currentNode,
                    login = false
                };
                player.currentScene = "TOWNOFARUDINE";
                GetCleanedSceneName(nconn, dummy);
                leftMatch = true;
            }, error =>{
                player.TargetCloseEndGameCanvas();
                if(nconn != null){
                    //print("We got the connection properly");
                }
                ClientRequestLoadScene dummy = new ClientRequestLoadScene {
                    oldScene = player.currentScene,
                    newScene = "TOWNOFARUDINE",
                    direction = "Death",
                    //node = player.currentNode,
                    login = false
                };
                player.currentScene = "TOWNOFARUDINE";
                GetCleanedSceneName(nconn, dummy);
                leftMatch = true;
                Debug.Log(error.ErrorMessage);
            });
            yield return new WaitUntil(() => leftMatch);
        }
        foreach(var key in MatchList){
            if(key.Key == match){
                yield return SceneManager.UnloadSceneAsync(key.Value);
            }
        }
        MatchList.Remove(match);
        processingMatches.Remove(match);
        ENDMATCHFULLY.Invoke(match); 
        MatchMaker.instance.FinishedMatch(match, players);
    }
        #endif
    void EvacuateMatch(Match match, string node, ScenePlayer castedPlayer, bool tacticianSpell){
        if(!MatchList.ContainsKey(match)){
            return;
        }
        if (processingMatches.Contains(match))
        {
            return;
        }
        EvacuateTheGame(match, node, castedPlayer, tacticianSpell);
    }
        void EvacuateTheGame(Match match, string node, ScenePlayer castedPlayer, bool tacticianSpell){
            if(!MatchList.ContainsKey(match)){
                return;
            }
            if (processingMatches.Contains(match))
            {
                return;
            }
            StartCoroutine(EvacuateMatchRoutine( match, node, castedPlayer, tacticianSpell));
        }
        IEnumerator EvacuateMatchRoutine(Match match, string node, ScenePlayer castedPlayer, bool tacticianSpell){
            //make method to split the string find its floats for x and y then apply to the chars new location
            Vector2 coords = new Vector2();
            bool random = false;
            if(node != "Random"){
                string[] parts = node.Split('_');
                if (parts.Length != 2)
                {
                    // Handle the error
                    yield break;
                }
                string nodeName = parts[0];
                string exitName = parts[1];
                coords = GetCoordinates(nodeName, exitName); // Assuming GetCoordinates returns a Vector2
            } else {
                if(node == "Random"){
                    random = true;
                }
            }
            ENDMATCHMAKER.Invoke(match);
            if(!MatchList.ContainsKey(match)){
                yield break;
            }
            // Check if the match is already being processed
            if (processingMatches.Contains(match))
            {
                yield break;
            }
            if(tacticianSpell){
                if(castedPlayer.SpellOne == "Evacuate"){
                    castedPlayer.ServerBuildTacticianSpellCooldown(1);
                }
                if(castedPlayer.SpellTwo == "Evacuate"){
                    castedPlayer.ServerBuildTacticianSpellCooldown(2);
                }
                castedPlayer.Energy -= 500f;
                castedPlayer.TargetUpdateEnergyDisplay(castedPlayer.Energy);
                CheckForLevelUpTactician(castedPlayer, 500f);
            }
            // Add the match to the set of processing matches
            processingMatches.Add(match);
            List<ScenePlayer> players = match.players;
            //print("Got to finished match in playfab server");
            foreach(var player in match.players){
                if(player == null){
                    continue;
                }
                NetworkIdentity networkIdentity = player.GetComponent<NetworkIdentity>();
                if(networkIdentity == null){
                    continue;
                }
                NetworkConnectionToClient conn = networkIdentity.connectionToClient;
                if(conn == null){
                    continue;
                }
                player.matchLeader = false;
                //if(random){
                //    coords.x = player.transform.position.x;
                //    coords.y = player.transform.position.y;
                //}
                player.inMatch = false;
                player.TargetCloseEndGameCanvas();
                string sceneTravelingTo = "TOWNOFARUDINE";
                if(!node.Contains("Sewers")){
                    sceneTravelingTo = "OVM";
                }
                if(node == "ArenaDuelArea"){
                    sceneTravelingTo = player.lastScene;
                }

                ClientRequestLoadScene dummy = new ClientRequestLoadScene {
                    oldScene = player.currentScene,
                    newScene = sceneTravelingTo,
                    direction = node,
                    login = false
                };
                GetCleanedSceneName(conn, dummy);
            }
            foreach(var key in MatchList){
                if(key.Key == match){
                    yield return SceneManager.UnloadSceneAsync(key.Value);
                }
            }
            ENDMATCHFULLY.Invoke(match); 
            MatchList.Remove(match);
            processingMatches.Remove(match);
            MatchMaker.instance.FinishedMatch(match, players);
        }
    void FinishingMatch(Match match, string nodePlusExit){
        if(!MatchList.ContainsKey(match)){
            return;
        }
        if (processingMatches.Contains(match))
        {
            return;
        }
        FinishedTheGame(match, nodePlusExit);
    }
        void FinishedTheGame(Match match, string nodePlusExit){
            if(!MatchList.ContainsKey(match)){
                return;
            }
            if (processingMatches.Contains(match))
            {
                return;
            }
            StartCoroutine(FinishedMatch( match, nodePlusExit));
        }
        IEnumerator FinishedMatch(Match match, string nodePlusExit){
            //make method to split the string find its floats for x and y then apply to the chars new location
            Vector2 coords = new Vector2();
            bool random = false;
            if(nodePlusExit != "Random"){
                string[] parts = nodePlusExit.Split('_');
                if (parts.Length != 2)
                {
                    // Handle the error
                    yield break;
                }
                string nodeName = parts[0];
                string exitName = parts[1];
                coords = GetCoordinates(nodeName, exitName); // Assuming GetCoordinates returns a Vector2
            } else {
                if(nodePlusExit == "Random"){
                    random = true;
                }
            }
            ENDMATCHMAKER.Invoke(match);
            if(!MatchList.ContainsKey(match)){
                yield break;
            }
            // Check if the match is already being processed
            if (processingMatches.Contains(match))
            {
                yield break;
            }
            // Add the match to the set of processing matches
            processingMatches.Add(match);
            List<ScenePlayer> players = match.players;
            //print("Got to finished match in playfab server");
            foreach(var player in match.players){
                if(player == null){
                    continue;
                }
                NetworkIdentity networkIdentity = player.GetComponent<NetworkIdentity>();
                if(networkIdentity == null){
                    continue;
                }
                NetworkConnectionToClient conn = networkIdentity.connectionToClient;
                if(conn == null){
                    continue;
                }
                player.matchLeader = false;
                //if(random){
                //    coords.x = player.transform.position.x;
                //    coords.y = player.transform.position.y;
                //}
                player.inMatch = false;
                player.TargetCloseEndGameCanvas();
                
                ClientRequestLoadScene dummy = new ClientRequestLoadScene {
                    oldScene = player.currentScene,
                    newScene = "OVM",
                    direction = nodePlusExit,
                    login = false
                };
                GetCleanedSceneName(conn, dummy);
            }
            foreach(var key in MatchList){
                if(key.Key == match){
                    yield return SceneManager.UnloadSceneAsync(key.Value);
                }
            }
            ENDMATCHFULLY.Invoke(match); 
            MatchList.Remove(match);
            processingMatches.Remove(match);
            MatchMaker.instance.FinishedMatch(match, players);
        }
        void FinishSewersMatch(Match match, string nodePlusExit){
            FinishedTheSewersGame(match, nodePlusExit);
        }
        void FinishedTheSewersGame(Match match, string nodePlusExit){
            if(!MatchList.ContainsKey(match)){
                return;
            }
            if (processingMatches.Contains(match))
            {
                return;
            }
            StartCoroutine(FinishedSewersMatch( match, nodePlusExit));
        }
        IEnumerator FinishedSewersMatch(Match match, string nodePlusExit){
            ScenePlayer sP = null;
            sP = match.matchLeader;
            float energyCost = 0;
            if(sP.currentScene == "Sewers level 1 story"){
                if(nodePlusExit == "Sewers level 2 story"){
                    energyCost = 50;
                }
                if(nodePlusExit == "Sewers level 3 story"){
                    energyCost = 100;
                }
                if(nodePlusExit == "Sewers level 4 story"){
                    energyCost = 150;
                }
            }
            if(sP.currentScene == "Sewers level 2 story"){
                if(nodePlusExit == "Sewers level 1 story"){
                    energyCost = 50;
                }
                if(nodePlusExit == "Sewers level 3 story"){
                    energyCost = 50;
                }
                if(nodePlusExit == "Sewers level 4 story"){
                    energyCost = 100;
                }
            }
            if(sP.currentScene == "Sewers level 3 story"){
                if(nodePlusExit == "Sewers level 1 story"){
                    energyCost = 100;
                }
                if(nodePlusExit == "Sewers level 2 story"){
                    energyCost = 50;
                }
                if(nodePlusExit == "Sewers level 4 story"){
                    energyCost = 50;
                }
            }
            if(sP.currentScene == "Sewers level 4 story"){
                if(nodePlusExit == "Sewers level 1 story"){
                    energyCost = 150;
                }
                if(nodePlusExit == "Sewers level 2 story"){
                    energyCost = 100;
                }
                if(nodePlusExit == "Sewers level 3 story"){
                    energyCost = 50;
                }
            }
            ENDMATCHMAKER.Invoke(match);
            if(!MatchList.ContainsKey(match)){
                yield break;
            }
            if (processingMatches.Contains(match))
            {
                yield break;
            }
            processingMatches.Add(match);
            List<ScenePlayer> players = match.players;
            sP.matchLeader = false;
            sP.inMatch = false;
            sP.TargetCloseEndGameCanvas();
            SceneManager.MoveGameObjectToScene(sP.gameObject, SceneManager.GetSceneByName("Container"));
            NetworkIdentity networkIdentity = sP.GetComponent<NetworkIdentity>();
            NetworkConnectionToClient conn = networkIdentity.connectionToClient;
            conn.Send(new SceneMessage { sceneName = sP.currentScene, sceneOperation = SceneOperation.UnloadAdditive});
            foreach(var key in MatchList){
                if(key.Key == match){
                    yield return SceneManager.UnloadSceneAsync(key.Value);
                }
            }
            ENDMATCHFULLY.Invoke(match); 
            MatchList.Remove(match);
            processingMatches.Remove(match);
            MatchMaker.instance.FinishedMatch(match, players);
            yield return new WaitForSeconds(1f);
            if(nodePlusExit == TOWNOFARUDINE){
                ClientRequestLoadScene dummmied = new ClientRequestLoadScene {
                    oldScene = sP.currentScene,
                    newScene = "TOWNOFARUDINE",
                    direction = "Sewers",
                    login = false
                };
                GetCleanedSceneName(conn, dummmied);
                yield break;
            }
            sP.ServerBuildMatchMakerSewerLogin(nodePlusExit, false);
            sP.Energy -= energyCost;
            sP.TargetUpdateEnergyDisplay(sP.Energy);
            CheckForLevelUpTactician(sP, energyCost);
        }
        Vector2 GetCoordinates(string nodeName, string exitName)
        {
            float x = 0;
            float y = 0;
            if(nodeName == "Sequoia Forest"){
                if(exitName == "West"){
                    x = -32.5f;
                    y = -8.5f;
                }
                if(exitName == "East"){
                    x = -29.5f;
                    y = -8.5f;
                }
            }
            if(nodeName == "Spider Caverns"){
                if(exitName == "South"){
                    x = -32.5f;
                    y = 2.5f;
                }
                if(exitName == "North"){
                    x = -31.5f;
                    y = 5.5f;
                }
            }
            if(nodeName == "Lake Arudine"){
                if(exitName == "East"){
                    x = -38.5f;
                    y = -13.5f;
                }
                if(exitName == "South"){
                    x = -39.5f;
                    y = -14.5f;
                }
            }
            // Your logic to find x and y based on nodeName and exitName
            // ...

            return new Vector2(x, y);
        }
        string AppendNumber(string str, int num)
        {
            return str + " " + num.ToString();
        }
        int CalculateAffordableSpellLevel(string type, int currentLevel, int maxLevel)
{
    int rankCost;
    int totalCost = 0;
    int affordableLevel = currentLevel;

    // Define costs based on the spell type
    switch (type)
    {
        case "Starter":
            return 25; // Multiply the fixed cost by the number of levels to advance
        case "A":
            rankCost = 15;
            totalCost = 30;
            break;
        case "B":
            rankCost = 55;
            totalCost = 110;
            break;
        case "C":
            rankCost = 200;
            totalCost = 500;
            break;
        case "D":
            rankCost = 600;
            totalCost = 1500;
            break;
        case "P":
            rankCost = 150;
            totalCost = 200;
            break;
        default:
            Debug.LogWarning("Unknown type: " + type);
            return currentLevel; // Return the current level if the type is unknown
    }
        print($"Starting our level calculate for spell and total cost is starting at {totalCost}");
    int ourCost = 0;
    // Calculate the maximum affordable level without exceeding class points
    for (int level = currentLevel ; level < maxLevel; level++)
    {
        int currentRankModifier = level; // Simplify modifier to just the level
        int costForNextLevel = rankCost * currentRankModifier + totalCost;
        ourCost += costForNextLevel;
        print($"{costForNextLevel} costForNextLevel for level {currentRankModifier} and total cost is now {ourCost}");
    }

    return ourCost;
}
        int CalculateSpellCost(string type, int currentLevel, int targetLevel){
            if (currentLevel >= targetLevel)
    {
        Debug.LogWarning("Target level must be greater than the current level.");
        return 0; // Return 0 if the target level is not greater than the current level
    }

    int rankCost;
    int rankUpCost;
    int totalCost = 0;

    switch (type)
    {
        case "Starter":
            return 25 * (targetLevel - currentLevel); // Multiply the fixed cost by the number of levels to advance
        case "A":
            rankCost = 15;
            rankUpCost = 30;
            break;
        case "B":
            rankCost = 55;
            rankUpCost = 110;
            break;
        case "C":
            rankCost = 200;
            rankUpCost = 500;
            break;
        case "D":
            rankCost = 600;
            rankUpCost = 1500;
            break;
        case "E":
            rankCost = 200;
            rankUpCost = 500;
            break;
        case "P":
            rankCost = 150;
            rankUpCost = 200;
            break;
        default:
            Debug.LogWarning("Unknown type: " + type);
            return 0; // Default value if the type does not match any known values
    }

    // Accumulate the cost of each level up from currentLevel + 1 to targetLevel
    for (int level = currentLevel + 1; level <= targetLevel; level++)
    {
        totalCost += (rankCost * (level - 1)) + rankUpCost;
    }

    return totalCost;
}
bool PassiveSpell(string spell){
    if(spell == "Treasure Finding"){
            return true;
        }
        if(spell == "Picklock"){
            return true;
        }
        if(spell == "Double Attack"){
            return true;
        }
        if(spell == "Riposte"){
            return true;
        }
        if(spell == "Critical Strike"){
            return true;
        }
        if(spell == "Undead Slayer"){
            return true;
        }
        if(spell == "Spell Critical"){
            return true;
        }
        if(spell == "Critical Heal"){
            return true;
        }
        if(spell == "Track"){
            return true;
        }
        if(spell == "Ambidexterity"){
            return true;
        }
        if(spell == "Bonus Harvest"){
            return true;
        }
        if(spell == "Bonus Agility"){
            return true;
        }
        if(spell == "Bonus Strength"){
            return true;
        }
        if(spell == "Bonus Resistances"){
            return true;
        }
        if(spell == "Bonus Fortitude"){
            return true;
        }
        if(spell == "Bonus Arcana"){
            return true;
        }
        if(spell == "Cooldown Reduction"){
            return true;
        }
        return false;
    }
        void PlayerRequestedLearnSpell(NetworkConnectionToClient nconn, LearnSpell requestedSpell, string CharID){
            #if UNITY_SERVER //|| UNITY_EDITOR
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED PlayerRequestedLearnSpell");
            //we need to make it so we can find what spell is coming in where it goes and charge the proper class points if they have enough
            string spell = requestedSpell.SpellName;
            string type = requestedSpell.SpellType;
            int currentSpellrank = requestedSpell.CurrentSpellRank;
            int requestedSpellrank = requestedSpell.RequestedSpellRank;

            float classPoints = -1;
            string upgradedSpellSlot = null;
            string upgradedSpell = null;
            //int upgradeCost = CalculateSpellCost(requestedSpell.SpellType, currentSpellrank, requestedSpell.RequestedSpellRank);
            int upgradeCost = CalculateAffordableSpellLevel(requestedSpell.SpellType, currentSpellrank, requestedSpell.RequestedSpellRank);
            print($"learning {spell} spell and its of type {type} and its requested rank is {requestedSpell.RequestedSpellRank} and current rank is {requestedSpell.CurrentSpellRank}, the cost is going to be {upgradeCost}");
            ScenePlayer player = nconn.identity.gameObject.GetComponent<ScenePlayer>();
            if(player == null){
                return;
            }
            string GetClass = string.Empty;
            print("Made it passed calculate spell");
            foreach(var sheet in player.GetInformationSheets()){
                if(sheet.CharacterID == CharID){
                    foreach(var charStat in sheet.CharStatData){
                        if(charStat.Key == "Class"){
                            GetClass = charStat.Value;
                            break;
                        }
                    }
                }
            }
            //Class Unlocks
            //(rankCost * spellRank) + spellDetails.RankUpCost
            if(spell == "Archer"){
                upgradedSpellSlot = "StartClassSkill";
            }
            if(spell == "Enchanter"){
                upgradedSpellSlot = "StartClassSkill";
            }
            if(spell == "Fighter"){
                upgradedSpellSlot = "StartClassSkill";
            }
            if(spell == "Rogue"){
                upgradedSpellSlot = "StartClassSkill";
            }
            if(spell == "Priest"){
                upgradedSpellSlot = "StartClassSkill";
            }
            if(spell == "Wizard"){
                upgradedSpellSlot = "StartClassSkill";
            }
            if(spell == "Paladin"){
                upgradedSpellSlot = "StartClassSkill";
            }
            if(spell == "Druid"){
                upgradedSpellSlot = "StartClassSkill";
            }
            if(spell == "Wyvern"){
                upgradedSpellSlot = "StartClassSkill";
            }
            //Archer
            if(spell == "Aimed Shot"){
                upgradedSpellSlot = "WestT1Skill";
            }
            if (spell == "Head Shot"){
                upgradedSpellSlot = "WestT2TopSkill";
            }
            if (spell == "Silence Shot"){
                upgradedSpellSlot = "WestT2MiddleSkill";
            }
            if (spell == "Crippling Shot"){
                upgradedSpellSlot = "WestT2BottomSkill";
            }
            if (spell == "Fire Arrow"){
                upgradedSpellSlot = "WestT3TopSkill";
            }
            if (spell == "Penetrating Shot"){
                upgradedSpellSlot = "WestT3BottomSkill";
            }
            if (spell == "Double Shot"){
                upgradedSpellSlot = "WestT3EndSkill";
            }
            //East
            if(spell == "Bandage Wound"){
                upgradedSpellSlot = "EastT1Skill";
            }
            if (spell == "Dash"){
                upgradedSpellSlot = "EastT2TopSkill";
            }
            if (spell == "Identify Enemy"){
                upgradedSpellSlot = "EastT2MiddleSkill";
            }
            if (spell == "Track"){
                upgradedSpellSlot = "EastT2BottomSkill";
            }
            if (spell == "Perception"){
                upgradedSpellSlot = "EastT3TopSkill";
            }
            if (spell == "Sleep"){
                upgradedSpellSlot = "EastT3BottomSkill";
            }
            if (spell == "Nature's Precision"){
                upgradedSpellSlot = "EastT3EndSkill";
            }
            //Enchanter
            if(spell == "Mesmerize"){
                upgradedSpellSlot = "WestT1Skill";
            }
            if (spell == "Slow"){
                upgradedSpellSlot = "WestT2TopSkill";
            }
            if (spell == "Magic Sieve"){
                upgradedSpellSlot = "WestT2MiddleSkill";
            }
            if (spell == "Aneurysm"){
                upgradedSpellSlot = "WestT2BottomSkill";
            }
            if (spell == "Gravity Stun"){
                upgradedSpellSlot = "WestT3TopSkill";
            }
            if (spell == "Weaken"){
                upgradedSpellSlot = "WestT3BottomSkill";
            }
            if (spell == "Charm"){
                upgradedSpellSlot = "WestT3EndSkill";
            }
            //East
            if(spell == "Haste"){
                upgradedSpellSlot = "EastT1Skill";
            }
            if (spell == "Root"){
                upgradedSpellSlot = "EastT2TopSkill";
            }
            if (spell == "Invisibility"){
                upgradedSpellSlot = "EastT2MiddleSkill";
            }
            if (spell == "Rune"){
                upgradedSpellSlot = "EastT2BottomSkill";
            }
            if (spell == "Purge"){
                upgradedSpellSlot = "EastT3TopSkill";
            }
            if (spell == "Resist Magic"){
                upgradedSpellSlot = "EastT3BottomSkill";
            }
            if (spell == "Mp Transfer"){
                upgradedSpellSlot = "EastT3EndSkill";
            }
            //Fighter
            if(spell == "Charge"){
                upgradedSpellSlot = "WestT1Skill";
            }
            if (spell == "Heavy Swing"){
                upgradedSpellSlot = "WestT2TopSkill";
            }
            if (spell == "Throw Stone"){
                upgradedSpellSlot = "WestT2MiddleSkill";
            }
            if (spell == "Knockback" && GetClass != "Wyvern"){
                upgradedSpellSlot = "WestT2BottomSkill";
            }
            if (spell == "Offensive Stance"){
                upgradedSpellSlot = "WestT3TopSkill";
            }
            if (spell == "Critical Strike"){
                upgradedSpellSlot = "WestT3BottomSkill";
            }
            if (spell == "Double Attack" && GetClass != "Wyvern"){
                upgradedSpellSlot = "WestT3EndSkill";
            }
            //East
            if(spell == "Bash"){
                upgradedSpellSlot = "EastT1Skill";
            }
            if (spell == "Taunt"){
                upgradedSpellSlot = "EastT2TopSkill";
            }
            if (spell == "Protect"){
                upgradedSpellSlot = "EastT2MiddleSkill";
            }
            if (spell == "Intimidating Roar"){
                upgradedSpellSlot = "EastT2BottomSkill";
            }
            if (spell == "Tank Stance"){
                upgradedSpellSlot = "EastT3TopSkill";
            }
            if (spell == "Block"){
                upgradedSpellSlot = "EastT3BottomSkill";
            }
            if (spell == "Riposte"){
                upgradedSpellSlot = "EastT3EndSkill";
            }
            //Priest
            if(spell == "Holy Bolt"){
                upgradedSpellSlot = "WestT1Skill";
            }
            if (spell == "Turn Undead"){
                upgradedSpellSlot = "WestT2TopSkill";
            }
            if (spell == "Critical Heal"){
                upgradedSpellSlot = "WestT2MiddleSkill";
            }
            if (spell == "Undead Protection"){
                upgradedSpellSlot = "WestT2BottomSkill";
            }
            if (spell == "Smite"){
                upgradedSpellSlot = "WestT3TopSkill";
            }
            if (spell == "Shield Bash"){
                upgradedSpellSlot = "WestT3BottomSkill";
            }
            if (spell == "Regeneration"){
                upgradedSpellSlot = "WestT3EndSkill";
            }
            //East
            if(spell == "Heal"){
                upgradedSpellSlot = "EastT1Skill";
            }
            if (spell == "Cure Poison"){
                upgradedSpellSlot = "EastT2TopSkill";
            }
            if (spell == "Dispel"){
                upgradedSpellSlot = "EastT2MiddleSkill";
            }
            if (spell == "Fortitude"){
                upgradedSpellSlot = "EastT2BottomSkill";
            }
            if (spell == "Greater Heal"){
                upgradedSpellSlot = "EastT3TopSkill";
            }
            if (spell == "Group Heal"){
                upgradedSpellSlot = "EastT3BottomSkill";
            }
            if (spell == "Resurrect"){
                upgradedSpellSlot = "EastT3EndSkill";
            }
            //Rogue
            if(spell == "Shuriken"){
                upgradedSpellSlot = "WestT1Skill";
            }
            if (spell == "Tendon Slice"){
                upgradedSpellSlot = "WestT2TopSkill";
            }
            if (spell == "Backstab"){
                upgradedSpellSlot = "WestT2MiddleSkill";
            }
            if (spell == "Rush"){
                upgradedSpellSlot = "WestT2BottomSkill";
            }
            if (spell == "Blind"){
                upgradedSpellSlot = "WestT3TopSkill";
            }
            if (spell == "Poison"){
                upgradedSpellSlot = "WestT3BottomSkill";
            }
            if (spell == "Double Attack" && GetClass != "Wyvern"){
                upgradedSpellSlot = "WestT3EndSkill";
            }
            //East
            if(spell == "Hide"){
                upgradedSpellSlot = "EastT1Skill";
            }
            if (spell == "Picklock"){
                upgradedSpellSlot = "EastT2TopSkill";
            }
            if (spell == "Steal"){
                upgradedSpellSlot = "EastT2MiddleSkill";
            }
            if (spell == "Detect Traps"){
                upgradedSpellSlot = "EastT2BottomSkill";
            }
            if (spell == "Treasure Finding"){
                upgradedSpellSlot = "EastT3TopSkill";
            }
            if (spell == "Ambidexterity"){
                upgradedSpellSlot = "EastT3BottomSkill";
            }
            if (spell == "Sneak"){
                upgradedSpellSlot = "EastT3EndSkill";
            }
            //Wizard
            //West
            if(spell == "Fire"){
                upgradedSpellSlot = "WestT1Skill";
            }
            if (spell == "Fireball"){
                upgradedSpellSlot = "WestT2TopSkill";
            }
            if (spell == "Light"){
                upgradedSpellSlot = "WestT2MiddleSkill";
            }
            if (spell == "Magic Missile"){
                upgradedSpellSlot = "WestT2BottomSkill";
            }
            if (spell == "Teleport"){
                upgradedSpellSlot = "WestT3TopSkill";
            }
            if (spell == "Meteor Shower"){
                upgradedSpellSlot = "WestT3BottomSkill";
            }
            if (spell == "Incinerate"){
                upgradedSpellSlot = "WestT3EndSkill";
            }
            //East
            if(spell == "Ice"){
                upgradedSpellSlot = "EastT1Skill";
            }
            if (spell == "Spell Critical"){
                upgradedSpellSlot = "EastT2TopSkill";
            }
            if (spell == "Ice Block"){
                upgradedSpellSlot = "EastT2MiddleSkill";
            }
            if (spell == "Ice Blast"){
                upgradedSpellSlot = "EastT2BottomSkill";
            }
            if (spell == "Blizzard"){
                upgradedSpellSlot = "EastT3TopSkill";
            }
            if (spell == "Magic Burst"){
                upgradedSpellSlot = "EastT3BottomSkill";
            }
            if (spell == "Brain Freeze"){
                upgradedSpellSlot = "EastT3EndSkill";
            }
            //Paladin
            //West
            if(spell == "Holy Swing"){
                upgradedSpellSlot = "WestT1Skill";
            }
            if (spell == "Undead Slayer"){
                upgradedSpellSlot = "WestT2TopSkill";
            }
            if (spell == "Stun"){
                upgradedSpellSlot = "WestT2MiddleSkill";
            }
            if (spell == "Celestial Wave"){
                upgradedSpellSlot = "WestT2BottomSkill";
            }
            if (spell == "Divine Wrath"){
                upgradedSpellSlot = "WestT3TopSkill";
            }
            if (spell == "Shackle"){
                upgradedSpellSlot = "WestT3BottomSkill";
            }
            if (spell == "Double Attack" && GetClass != "Wyvern"){
                upgradedSpellSlot = "WestT3EndSkill";
            }
            //East
            if(spell == "Divine Armor"){
                upgradedSpellSlot = "EastT1Skill";
            }
            if (spell == "Cleanse"){
                upgradedSpellSlot = "EastT2TopSkill";
            }
            if (spell == "Angelic Shield"){
                upgradedSpellSlot = "EastT2MiddleSkill";
            }
            if (spell == "Flash Of Light"){
                upgradedSpellSlot = "EastT2BottomSkill";
            }
            if (spell == "Cover"){
                upgradedSpellSlot = "EastT3TopSkill";
            }
            if (spell == "Consecrated Ground"){
                upgradedSpellSlot = "EastT3BottomSkill";
            }
            if (spell == "Lay On Hands"){
                upgradedSpellSlot = "EastT3EndSkill";
            }
            //Druid
            //West
            if(spell == "Swarm Of Insects"){
                upgradedSpellSlot = "WestT1Skill";
            }
            if (spell == "Snare"){
                upgradedSpellSlot = "WestT2TopSkill";
            }
            if (spell == "Shapeshift"){
                upgradedSpellSlot = "WestT2MiddleSkill";
            }
            if (spell == "Engulfing Roots"){
                upgradedSpellSlot = "WestT2BottomSkill";
            }
            if (spell == "Staff Specialization"){
                upgradedSpellSlot = "WestT3TopSkill";
            }
            if (spell == "Chain Lightning"){
                upgradedSpellSlot = "WestT3BottomSkill";
            }
            if (spell == "Solar Flare"){
                upgradedSpellSlot = "WestT3EndSkill";
            }
            //East
            if(spell == "Rejuvenation"){
                upgradedSpellSlot = "EastT1Skill";
            }
            if (spell == "Thorns"){
                upgradedSpellSlot = "EastT2TopSkill";
            }
            if (spell == "Nature's Protection"){
                upgradedSpellSlot = "EastT2MiddleSkill";
            }
            if (spell == "Strength"){
                upgradedSpellSlot = "EastT2BottomSkill";
            }
            if (spell == "Tornado"){
                upgradedSpellSlot = "EastT3TopSkill";
            }
            if (spell == "Greater Rejuvenation"){
                upgradedSpellSlot = "EastT3BottomSkill";
            }
            if (spell == "Evacuate"){
                upgradedSpellSlot = "EastT3EndSkill";
            }
            //Wyvern
            //West
            if(spell == "Bite"){
                upgradedSpellSlot = "WestT1Skill";
            }
            if (spell == "Fire Breath"){
                upgradedSpellSlot = "WestT2TopSkill";
            }
            if (spell == "Harden"){
                upgradedSpellSlot = "WestT2MiddleSkill";
            }
            if (spell == "Roar"){
                upgradedSpellSlot = "WestT2BottomSkill";
            }
            if (spell == "Double Attack" && GetClass == "Wyvern"){
                upgradedSpellSlot = "WestT3TopSkill";
            }
            if (spell == "Dash"){
                upgradedSpellSlot = "WestT3BottomSkill";
            }
            if (spell == "Knockback" && GetClass == "Wyvern"){
                upgradedSpellSlot = "WestT3EndSkill";
            }
            //East
            if(spell == "Tail Whip"){
                upgradedSpellSlot = "EastT1Skill";
            }
            if (spell == "Armor Bite"){
                upgradedSpellSlot = "EastT2TopSkill";
            }
            if (spell == "Focus"){
                upgradedSpellSlot = "EastT2MiddleSkill";
            }
            if (spell == "Dive"){
                upgradedSpellSlot = "EastT2BottomSkill";
            }
            if (spell == "Critical Strike" && GetClass == "Wyvern"){
                upgradedSpellSlot = "EastT3TopSkill";
            }
            if (spell == "Rest"){
                upgradedSpellSlot = "EastT3BottomSkill";
            }
            if (spell == "Devour"){
                upgradedSpellSlot = "EastT3EndSkill";
            }
            //All South
            if(spell == "Bonus Harvest"){
                upgradedSpellSlot = "SouthT1Skill";
            }
            if (spell == "Bonus Strength"){
                upgradedSpellSlot = "SouthT2LeftSkill";
            }
            if (spell == "Bonus Agility"){
                upgradedSpellSlot = "SouthT2MiddleSkill";
            }
            if (spell == "Bonus Resistances"){
                upgradedSpellSlot = "SouthT2RightSkill";
            }
            if (spell == "Bonus Fortitude"){
                upgradedSpellSlot = "SouthT3LeftSkill";
            }
            if (spell == "Bonus Arcana"){
                upgradedSpellSlot = "SouthT3RightSkill";
            }
            if (spell == "Cooldown Reduction"){
                upgradedSpellSlot = "SouthT3EndSkill";
            }
            upgradedSpell = AppendNumber(requestedSpell.SpellName, requestedSpell.RequestedSpellRank);
            print("Made it passed AppendNumber");

            CharacterSpellListItem NewSpellItem = (new CharacterSpellListItem{
                Key = upgradedSpellSlot,
                Value = upgradedSpell,
                Updated = true
            });
            bool purchased = false;
            string spellQ = "None";
            string spellE = "None";
            string spellR = "None";
            string spellF = "None";
            string slot = "None";
            bool trigger = false;
            bool EmptySlotAvailableNotAndNotEquippede = false;
            foreach(var sheet in player.GetInformationSheets()){
                if(sheet.CharacterID == CharID){
                    
                    foreach(var charStat in sheet.CharStatData){
                        if(charStat.Key == "ClassPoints"){
                            classPoints = float.Parse(charStat.Value);
                            break;
                        }
                    }
                    if(classPoints >= upgradeCost){
                        purchased = true;
                        print($"We had enough points to purchase, {classPoints} were class points avail on char and we needed {upgradeCost}");
                        classPoints -= upgradeCost;
                        print($"{classPoints} were class points avail on char after spending and we needed {upgradeCost}");
                    } else {
                        print($"NOT ENOUGH POINTS, {classPoints} were class points avail on char and we needed {upgradeCost}");
                        return;//not enough points
                    }
                    foreach(var charSpellSLot in sheet.CharSpellData){
                        if(charSpellSLot.Key == "SPELLQ"){
                           if(charSpellSLot.Value != "None"){
                                var nameMatch = System.Text.RegularExpressions.Regex.Match(charSpellSLot.Value, @"^\D*");
                                spellQ = nameMatch.Value.Trim();
                                if(spellQ == spell){
                                    slot = "Q";
                                    trigger = true;
                                    break;
                                }
                           }
                        }
                        if(charSpellSLot.Key == "SPELLE"){
                           if(charSpellSLot.Value != "None"){
                                var nameMatch = System.Text.RegularExpressions.Regex.Match(charSpellSLot.Value, @"^\D*");
                                spellE = nameMatch.Value.Trim();
                                if(spellE == spell){
                                    slot = "E";
                                    trigger = true;
                                    break;
                                }
                           }
                        }
                        if(charSpellSLot.Key == "SPELLR"){
                           if(charSpellSLot.Value != "None"){
                                var nameMatch = System.Text.RegularExpressions.Regex.Match(charSpellSLot.Value, @"^\D*");
                                spellR = nameMatch.Value.Trim();
                                if(spellR == spell){
                                    slot = "R";
                                    trigger = true;
                                    break;
                                }
                           }
                        }
                        if(charSpellSLot.Key == "SPELLF"){
                           if(charSpellSLot.Value != "None"){
                                var nameMatch = System.Text.RegularExpressions.Regex.Match(charSpellSLot.Value, @"^\D*");
                                spellF = nameMatch.Value.Trim();
                                if(spellF == spell){
                                    slot = "F";
                                    trigger = true;
                                    break;
                                }
                           }
                        }
                    }
                    break;
                }
            }
            if(!purchased){
                print("Not Enough mula for the spell");
                return;
            }
            print("Made it passed char spell list item");

            CharacterStatListItem ClassPoints = (new CharacterStatListItem {
                Key = "ClassPoints",
                Value = classPoints.ToString()
            });
            if(!trigger && upgradedSpellSlot != "StartClassSkill" && !PassiveSpell(spell)){
                if (spellQ == "None" && !EmptySlotAvailableNotAndNotEquippede)
                {
                    slot = "Q";
                    EmptySlotAvailableNotAndNotEquippede = true;
                }
                else if (spellE == "None" && !EmptySlotAvailableNotAndNotEquippede)
                {
                    slot = "E";
                    EmptySlotAvailableNotAndNotEquippede = true;
                }
                else if (spellR == "None" && !EmptySlotAvailableNotAndNotEquippede)
                {
                    slot = "R";
                    EmptySlotAvailableNotAndNotEquippede = true;
                }
                else if (spellF == "None" && !EmptySlotAvailableNotAndNotEquippede)
                {
                    slot = "F";
                    EmptySlotAvailableNotAndNotEquippede = true;
                }
            }
            player.GetCharacterSpellItemPurchase(CharID, NewSpellItem, ClassPoints);
            if(trigger || EmptySlotAvailableNotAndNotEquippede){
                StartCoroutine(TriggeredSpellChangeAfterLearn(nconn, upgradedSpell, CharID, slot));
            }
            ////Send spell and new classpoints
            //var request = new UpdateCharacterDataRequest
            //{
            //    PlayFabId = playerData.PlayFabId,
            //    CharacterId = CharID,
            //    Data = new Dictionary<string, string>
            //    {
            //        { upgradedSpellSlot, upgradedSpell }, { "ClassPoints", classPoints.ToString()  }
            //    },
            //    Permission = UserDataPermission.Private
            //};
            ////print("Made it passed UpdateCharacterDataRequest");
            //PlayFabServerAPI.UpdateCharacterInternalData( request, 
            //result =>
            //{
            //    //print($"We made it into the characterInternalData request so it was called np");
            //    player.GetCharacterSpellItemPurchase(CharID, NewSpellItem, ClassPoints);
            //    if(trigger){
            //        PlayerRequestedSpellChange(nconn, upgradedSpell, CharID, slot);
            //    }
            //}, error =>{
            //    Debug.Log(error.ErrorMessage);
            //});  
            #endif
        }
        IEnumerator TriggeredSpellChangeAfterLearn(NetworkConnectionToClient nconn, string upgradedSpell, string CharID, string slot){
            yield return new WaitForSeconds(.5f);
            PlayerRequestedSpellChange(nconn, upgradedSpell, CharID, slot);
        }
        void PlayerRequestedSpellChange(NetworkConnectionToClient nconn, string _spell, string charID, string slot){
            #if UNITY_SERVER //|| UNITY_EDITOR
             var nameMatch = System.Text.RegularExpressions.Regex.Match(_spell, @"^\D*");
            string spell = nameMatch.Value.Trim(); // Trim any trailing spaces
            int spellRank = 1;
            // Extract spell rank
            var rankMatch = System.Text.RegularExpressions.Regex.Match(_spell, @"\d+$");
            if (rankMatch.Success) {
                spellRank = int.Parse(rankMatch.Value); // Parse the rank number
            }
            
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED PlayerRequestedSpellChange");
            ScenePlayer player = nconn.identity.gameObject.GetComponent<ScenePlayer>();string spellToBeAdded = null;
            string Qspell = "None";
            string Espell = "None";
            string Rspell = "None";
            string Fspell = "None";
            if(slot == "Q"){
                spellToBeAdded = "SPELLQ";
                Qspell = _spell;
                print($"{Qspell} is the Qspell we are seting from the start of Spell Change");
            }
            if(slot == "E"){
                spellToBeAdded = "SPELLE";
                Espell = _spell;
                print($"{Espell} is the Espell we are seting from the start of Spell Change");
            }
            if(slot == "R"){
                spellToBeAdded = "SPELLR";
                Rspell = _spell;
                print($"{Rspell} is the Rspell we are seting from the start of Spell Change");
            }
            if(slot == "F"){
                spellToBeAdded = "SPELLF";
                Fspell = _spell;
                print($"{Fspell} is the Fspell we are seting from the start of Spell Change");
            }
            Dictionary<string,string> EquippedSpells = new Dictionary<string,string>();
            CharacterSpellListItem NewSpellItem = (new CharacterSpellListItem{
                Key = spellToBeAdded,
                Value = _spell,
                Updated = true
            });
            CharacterSpellListItem updatedItem = (new CharacterSpellListItem{
                Key = "Empty",
                Value = "None",
                Updated = true
            });
            bool emptySlot = false;
            if(Qspell == "None" && Espell == "None" && Rspell == "None" && Fspell == "None"){
                emptySlot = true;
                SendSpellList spellListEmpty = (new SendSpellList{
                SpellQ = Qspell,
                SpellE = Espell,
                SpellR = Rspell,
                SpellF = Fspell
            });
            player.GetCharacterSpellChange(charID, NewSpellItem, updatedItem, spellListEmpty);
            } 
            if(!emptySlot){

            foreach (var sheet in player.GetInformationSheets())
            {
                if (sheet.CharacterID == charID)
                {
                    foreach(var spellKey in sheet.CharSpellData){
                        if(spellKey.Key == "SPELLQ" && Qspell == "None"){
                            var matcHQ = System.Text.RegularExpressions.Regex.Match(spellKey.Value, @"^\D*");
                            string spellQ = matcHQ.Value.Trim(); // Trim any trailing spaces
                            if(spellQ == spell){
                                Qspell = "None";
                                updatedItem.Key = spellKey.Key;
                            } else {
                                Qspell = spellKey.Value;
                            }
                            print($"{Qspell} is the Qspell");
                        }
                        if(spellKey.Key == "SPELLE" && Espell == "None"){
                            var matcHE = System.Text.RegularExpressions.Regex.Match(spellKey.Value, @"^\D*");
                            string spellE = matcHE.Value.Trim(); // Trim any trailing spaces
                            if(spellE == spell){
                                Espell = "None";
                                updatedItem.Key = spellKey.Key;
                            } else {
                                Espell = spellKey.Value;
                            }
                            print($"{Espell} is the Espell");
                        }
                        if(spellKey.Key == "SPELLR" && Rspell == "None"){
                            var matcHR = System.Text.RegularExpressions.Regex.Match(spellKey.Value, @"^\D*");
                            string spellR = matcHR.Value.Trim(); // Trim any trailing spaces
                            if(spellR == spell){
                                Rspell = "None";
                                updatedItem.Key = spellKey.Key;
                            } else {
                                Rspell = spellKey.Value;
                            }
                            print($"{Rspell} is the Rspell");
                        }
                        if(spellKey.Key == "SPELLF" && Fspell == "None"){
                            var matcHF = System.Text.RegularExpressions.Regex.Match(spellKey.Value, @"^\D*");
                            string spellF = matcHF.Value.Trim(); // Trim any trailing spaces
                            if(spellF == spell){
                                Fspell = "None";
                                updatedItem.Key = spellKey.Key;
                            } else {
                                Fspell = spellKey.Value;
                            }
                            print($"{Fspell} is the Fspell");
                        }
                    }
                }
            }
            SendSpellList spellList = (new SendSpellList{
                SpellQ = Qspell,
                SpellE = Espell,
                SpellR = Rspell,
                SpellF = Fspell
            });
            player.GetCharacterSpellChange(charID, NewSpellItem, updatedItem, spellList);
            }

            //var request = new UpdateCharacterDataRequest
            //{
            //    PlayFabId = playerData.PlayFabId,
            //    CharacterId = charID,
            //    Data =  new Dictionary<string, string>
            //    {
            //        {"SPELLQ", Qspell}, {"SPELLE", Espell}, {"SPELLR", Rspell}, {"SPELLF", Fspell}
            //    },
            //    Permission = UserDataPermission.Private
            //};
            //PlayFabServerAPI.UpdateCharacterInternalData(request, result =>
            //{
            //    Debug.Log("Character spell updated successfully");
            //    // Handle successful response   
            //},
            //error =>
            //{
            //    Debug.LogError("Failed to update character spell: " + error.ErrorMessage);
            //    // Handle error response
            //});
            #endif
        }
        
       
        void GetDropTable(Mob mob, TurnManager curator, bool steal, ScenePlayer assignedPlayer)
        {
            #if UNITY_SERVER //|| UNITY_EDITOR
            string mobName = mob.NAME;
            int tier = mob.TIER;
            //using mobName for different droTableKeys if its not just a standard tier drop
            string reminder = $"79% common, 16% uncommon, 4% rare, or 1% ultra rare item when an item drops from an enemy. Reduce common by 0.25% per rank, increase uncommon by 0.15%, increase rare by 0.07%, increase ultra rare by 0.03% per rank.";
            float highestChanceIncrease = 0;
            int highestLevel = 0;
            
            List<PlayerCharacter> pcList = curator.GetPCList();
            List<ScenePlayer> playersList = curator.GetPlayers();
            for(int playerCount = 0; playerCount < playersList.Count; playerCount++){
                for(int sheet = 0; sheet < playersList[playerCount].GetInformationSheets().Count; sheet++){
                    for(int pcCheck = 0; pcCheck < pcList.Count; pcCheck ++){
                        if(pcList[pcCheck].CharID == playersList[playerCount].GetInformationSheets()[sheet].CharacterID){
                            for(int statCheck = 0; statCheck < playersList[playerCount].GetInformationSheets()[sheet].CharStatData.Count; statCheck++){
                                if(playersList[playerCount].GetInformationSheets()[sheet].CharStatData[statCheck].Key == "Class"){
                                    if(playersList[playerCount].GetInformationSheets()[sheet].CharStatData[statCheck].Value == "Rogue"){
                                        for(int abilityCheck = 0; abilityCheck < playersList[playerCount].GetInformationSheets()[sheet].CharSpellData.Count; abilityCheck++){
                                            if(playersList[playerCount].GetInformationSheets()[sheet].CharSpellData[abilityCheck].Key == "EastT3TopSkill"){
                                                var abilityRankString = System.Text.RegularExpressions.Regex.Match(playersList[playerCount].GetInformationSheets()[sheet].CharSpellData[abilityCheck].Value, @"\d+$");
                                                if (abilityRankString.Success) {
                                                    int abilityRank = int.Parse(abilityRankString.Value); // Parse the rank number
                                                    if(highestLevel < abilityRank){
                                                        highestLevel = abilityRank;
                                                    }
                                                }
                                                break;
                                            }
                                        }
                                    } else {
                                        break;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            string dropTableKey = GenerateRarity(mobName, highestLevel);
            //Check for rogue treasure finding


            //print($"Got to droptable! {dropTableKey} is the droptable name");
            var request = new GetRandomResultTablesRequest{
                TableIDs = new List<string> { dropTableKey }
            };
            PlayFabServerAPI.GetRandomResultTables(request, result => OnGetDropTableSuccess(result, dropTableKey, dropTableKey, tier, curator, steal, assignedPlayer), OnPlayFabError);
                #endif
        }
        public static bool CheckForDropTable(string input)
        {
            //print($"made it to CheckForDropTable, {input} is our input");

            return input.Contains("_Common") || input.Contains("_Uncommon") || input.Contains("_Rare") || input.Contains("_UltraRare") || input.Contains("MainChest");
        }
void GetMiniChestDropTable(int tier, TurnManager curator)
{
    
    #if UNITY_SERVER //|| UNITY_EDITOR
    string dropTableKey = "MiniChest_Tier" + tier.ToString();
    // Using mobName for different dropTableKeys if it's not just a standard tier drop
    var request = new GetRandomResultTablesRequest
    {
        TableIDs = new List<string> { dropTableKey }
    };
    PlayFabServerAPI.GetRandomResultTables(request, result => OnGetDropTableSuccess(result, dropTableKey, dropTableKey, tier, curator, false, null), OnPlayFabError);
    #endif
}
void GetArmorRackDropTable(int tier, TurnManager curator)
{
    
    #if UNITY_SERVER //|| UNITY_EDITOR
    string dropTableKey = "ArmorDrop_Tier" + tier.ToString();
    // Using mobName for different dropTableKeys if it's not just a standard tier drop
    var request = new GetRandomResultTablesRequest
    {
        TableIDs = new List<string> { dropTableKey }
    };
    PlayFabServerAPI.GetRandomResultTables(request, result => OnGetDropTableSuccess(result, dropTableKey, dropTableKey, tier, curator, false, null), OnPlayFabError);
    #endif
}
void GetWeaponRackDropTable(int tier, TurnManager curator)
{
    
    #if UNITY_SERVER //|| UNITY_EDITOR
    string dropTableKey = "WeaponDrop_Tier" + tier.ToString();
    // Using mobName for different dropTableKeys if it's not just a standard tier drop
    var request = new GetRandomResultTablesRequest
    {
        TableIDs = new List<string> { dropTableKey }
    };
    PlayFabServerAPI.GetRandomResultTables(request, result => OnGetDropTableSuccess(result, dropTableKey, dropTableKey, tier, curator, false, null), OnPlayFabError);
    #endif
}
void GetMainChestDropTable(int tier, TurnManager curator)
{
    #if UNITY_SERVER //|| UNITY_EDITOR
    StartCoroutine(FetchBalance(tier, curator));
    string dropTableKey = "MainChest_Tier" + tier.ToString();
    // Using mobName for different dropTableKeys if it's not just a standard tier drop
    for (int i = 0; i < curator.GetPlayers().Count; i++)
    {
        print("Getting result for main chest drops!!");
        var request = new GetRandomResultTablesRequest
        {
            TableIDs = new List<string> { dropTableKey }
        };
        PlayFabServerAPI.GetRandomResultTables(request, result => OnGetDropTableSuccess(result, dropTableKey, dropTableKey, tier, curator, false, null), OnPlayFabError);
    }
    #endif
}
public float GetDKPBalance(string jsonResponse)
    {
        float DKPAmount = 0f;
        Debug.Log("JSON Response: " + jsonResponse);
        
        // Parse the JSON response
        CurrencyBalance[] balances = JsonHelper.FromJson<CurrencyBalance>(jsonResponse);

        // Iterate through the array to find the DKP balance
        foreach (CurrencyBalance balance in balances)
        {
            if (balance.currency == "DKP")
            {
                Debug.Log("DKP Balance: " + balance.value);
                DKPAmount = float.Parse(balance.value);
                break;
            }
        }
        return DKPAmount;
    }
    //double rate = 0.0;
    //switch (tier)
    //{
    //    case 1: rate = 0.000004; break;//.0000023
    //    case 2: rate = 0.000007; break;//.000004025
    //    case 3: rate = 0.000011; break;//.000006325
    //    case 4: rate = 0.000019; break;//.000010925
    //    case 5: rate = 0.000032; break;//.0000184
    //}

private double CalculateReward(int tier, float dkpBalance)
{
    double rate = 0.0;
    switch (tier)
    {
        case 1: rate = 0.0000023; break;
        case 2: rate = 0.000004025; break;
        case 3: rate = 0.000006325; break;
        case 4: rate = 0.000010925; break;
        case 5: rate = 0.0000184; break;
    }

    double reward = rate * dkpBalance * (1.0 / 1000.0); // scaling down
    return reward;
}
    IEnumerator GetNFTMetadata(string metadataURI)
{
    metadataURI = "https://ipfs.io/ipfs/bafybeic2bf4nsmcczycgunv6foyhmxfqqzatawqhcwla7hqital65coqzq/metadata.json";
    UnityWebRequest www = UnityWebRequest.Get(metadataURI);
    yield return www.SendWebRequest();

    if (www.result != UnityWebRequest.Result.Success)
    {
        Debug.Log(www.error);
    }
    else
    {
        string metadataJson = www.downloadHandler.text;
        
        NFTMetadata metadata = JsonUtility.FromJson<NFTMetadata>(metadataJson);

        // Now, you can access properties like this:
        string md5hash = metadata.md5hash;
        string issuer = metadata.external_url; // or whatever field represents the issuer in your case

        Debug.Log("MD5 Hash: " + md5hash);
        Debug.Log("Issuer: " + issuer);
        // Perform your checks or operations here
    }
}
    #if UNITY_SERVER //|| UNITY_EDITOR

IEnumerator FetchBalance(int tier, TurnManager curator)
    {

        UnityWebRequest www = UnityWebRequest.Get(xrpscanAPI + _GAME_WALLET_ADDRESS + "/balances");
        yield return www.SendWebRequest();

        if (www.result != UnityWebRequest.Result.Success)
        {
            Debug.Log(www.error);
        }
        else
        {
            float DKP_Amount = GetDKPBalance(www.downloadHandler.text);
            double reward = CalculateReward(tier, DKP_Amount);
            float roll = UnityEngine.Random.Range(1f, 101f);
            if (roll < 4f)
            {
                reward *= 14;
            }
            else if (roll < 10f)
            {
                reward *= 8;
            }            
            Debug.Log($"Reward for Tier {tier}: {reward} DKP");
            reward /= curator.GetPlayers().Count;
            Debug.Log($"Reward for each player is {reward} DKP");
            foreach(var player in curator.GetPlayers()){
                NetworkIdentity networkIdentity = player.GetComponent<NetworkIdentity>();
                if (networkIdentity != null)
                {
                    NetworkConnectionToClient conn = networkIdentity.connectionToClient as NetworkConnectionToClient;
                    if (conn != null)
                    {
                        if (!(conn.authenticationData is PlayerInfo playerData))
                        {
                            Debug.LogWarning("Authentication data is missing or not of type PlayerInfo.");
                            continue;
                        }

                        PlayFabServerAPI.AddUserVirtualCurrency(new AddUserVirtualCurrencyRequest
                        {
                            PlayFabId = playerData.PlayFabId,
                            Amount = (int)reward,
                            VirtualCurrency = "DK"
                        }, result =>
                        {
                            int quant = (int)reward;
                            int newGoldAmount = quant + (int)player.Gold;
                            //print($"Quant amount is now {quant}");
                            //print($"We added gold to our account, gold amount is now {newGoldAmount}");
                            player.Gold = (long)newGoldAmount;
                            player.SetGold(player.Gold);
                        }, error =>{
                            Debug.Log(error.ErrorMessage);
                        });

                    }
                    else
                    {
                        Debug.LogWarning("Connection is not of type NetworkConnectionToClient.");
                    }
                }
                else
                {
                    Debug.LogWarning("NetworkIdentity component is missing.");
                    continue;
                }
            }
            SendingGoldAmount.Invoke(curator.GetMatch(), curator, (float)reward);
            print("Sending Gold Amount");
        }
    }
        #endif
    
private int CalculateMainChestItemsToGenerate()
{
    return new System.Random().Next(1, 6); // Returns a random integer between 1 and 5 (inclusive)
}
#if UNITY_SERVER //|| UNITY_EDITOR
private void OnGetDropTableSuccess(GetRandomResultTablesResult result, string dropTableKey, string mobName, int tier, TurnManager curator, bool steal, ScenePlayer assignedPlayer){
    //print($"made it to TableSuccess, {dropTableKey} is our drop table key");
    Dictionary<string, RandomResultTableListing> possiblePicks = result.Tables;
    List<string> keys = possiblePicks.Keys.ToList();
    int randomIndex = new System.Random().Next(0, keys.Count);
    //print($"possible picks in this droptablekey were {keys.Count}");
    KeyValuePair<string, RandomResultTableListing> randomPick = possiblePicks.ElementAt(randomIndex);
    string tableChecker = randomPick.Value.TableId;
    //print($"tableChecker name is {tableChecker}");
    int randomNodeIndex = new System.Random().Next(0, randomPick.Value.Nodes.Count);
    ResultTableNode randomItem = randomPick.Value.Nodes.ElementAt(randomNodeIndex);
    if (CheckForDropTable(randomItem.ResultItem)){
        var request = new GetRandomResultTablesRequest{
            TableIDs = new List<string> { randomItem.ResultItem }
        };
        PlayFabServerAPI.GetRandomResultTables(request, result => OnGetDropTableSuccess(result, randomItem.ResultItem, mobName, tier, curator, steal, assignedPlayer), OnPlayFabError);
    } else {
        FetchItemDetailsAndProcess(randomItem.ResultItem, mobName, tier, curator, steal, assignedPlayer);
    }
}
#endif
private void FetchItemDetailsAndProcess(string itemId, string mobName, int tier, TurnManager curator, bool steal, ScenePlayer assignedPlayer)
{
#if UNITY_SERVER //|| UNITY_EDITOR
var request = new GetCatalogItemsRequest();
request.CatalogVersion = "DragonKill_Characters_Bundles_Items";
PlayFabServerAPI.GetCatalogItems(request, result =>
{
if (result.Catalog != null && result.Catalog.Count > 0)
{
    // Search through the catalog for the item you are interested in
    foreach (var item in result.Catalog)
    {
        if (item.ItemId == itemId)
        {
            // Found the item, now use its display name
            var displayName = item.DisplayName;
            ProcessDropTable(displayName, item.ItemId, mobName, tier, curator, steal, assignedPlayer);
            break; // exit the loop once we found the item
        }
    }
}
}, OnPlayFabError);
#endif
}

private void ProcessDropTable(string itemName, string itemID, string mobName, int tier, TurnManager curator, bool steal, ScenePlayer assignedPlayer)
{
    print($"ProcessingDropTable for {itemName} and its itemID is {itemID} and mob name is {mobName}");
        //string extractedRarity = ExtractRarity(mobName);
    int quant = 1;

    if(mobName.Contains("StoneGolem_")){
        if(mobName.Contains("Common")){
            quant = 6;
        }
        if(mobName.Contains("Uncommon")){
            quant = 13;
        }
        if(mobName.Contains("Rare")){
            quant = 30;
        }
        if(mobName.Contains("UltraRare")){
            quant = 70;
        }
    }
    if(mobName.Contains("OreGolem_")){
        if(mobName.Contains("Common")){
            quant = 6;
        }
        if(mobName.Contains("Uncommon")){
            quant = 13;
        }
        if(mobName.Contains("Rare")){
            quant = 30;
        }
        if(mobName.Contains("UltraRare")){
            quant = 70;
        }
    }
    if(mobName.Contains("Deer_")){
        if(mobName.Contains("Common")){
            quant = 6;
        }
        if(mobName.Contains("Uncommon")){
            quant = 13;
        }
        if(mobName.Contains("Rare")){
            quant = 30;
        }
        if(mobName.Contains("UltraRare")){
            quant = 70;
        }
    }
    if(mobName.Contains("PossessedTree_")){
        if(mobName.Contains("Common")){
            quant = 6;
        }
        if(mobName.Contains("Uncommon")){
            quant = 13;
        }
        if(mobName.Contains("Rare")){
            quant = 30;
        }
        if(mobName.Contains("UltraRare")){
            quant = 70;
        }
    }
    if(mobName.Contains("PossessedPlant_")){
        if(mobName.Contains("Common")){
            quant = 6;
        }
        if(mobName.Contains("Uncommon")){
            quant = 13;
        }
        if(mobName.Contains("Rare")){
            quant = 30;
        }
        if(mobName.Contains("UltraRare")){
            quant = 70;
        }
    }
    print($"Spawning {itemName} with a quant: {quant}");
    //print("About to item roll!!");
    StartCoroutine(SendItemsToRollAfterDelay(itemName, itemID, mobName, tier, curator, steal, assignedPlayer, quant));
}
IEnumerator SendItemsToRollAfterDelay(string itemName, string itemID, string mobName, int tier, TurnManager curator, bool steal, ScenePlayer assignedPlayer, int quant){
    Guid uniqueId = Guid.NewGuid();
    curator.ItemAvailableToRoll(itemName, quant, uniqueId.ToString(), tier, itemID, mobName, steal, assignedPlayer);
    float randomCheckAmount = UnityEngine.Random.Range(.1f, 2f);
	yield return new WaitForSeconds(randomCheckAmount);
}
            #if UNITY_SERVER //|| UNITY_EDITOR

private void OnPlayFabError(PlayFabError error)
{
    Debug.LogError($"PlayFab Error: {error.GenerateErrorReport()}");
}
        public string ExtractRarity(string DropFull)
        {
            float roll = UnityEngine.Random.Range(0f, 1f);
            string rarity = string.Empty;

            if(DropFull.Contains("_Common")){
                rarity = "_Common";
            }
            if(DropFull.Contains("_Uncommon")){
                rarity = "_Uncommon";
            }
            if(DropFull.Contains("_Rare")){
                rarity = "_Rare";
            }
            if(DropFull.Contains("_UltraRare")){
                rarity = "_UltraRare";
            }
            return rarity;
        }
        public string GenerateRarity(string mobName, int enhancedChance)
        {
            float commonChance = 79f - (0.25f * enhancedChance);
            float uncommonChance = 16f + (0.15f * enhancedChance);
            float rareChance = 4f + (0.07f * enhancedChance);
            float ultraRareChance = 1f + (0.03f * enhancedChance);

            // Normalize the chances to ensure they sum to 100%
            float totalChance = commonChance + uncommonChance + rareChance + ultraRareChance;

            commonChance = (commonChance / totalChance) * 100f;
            uncommonChance = (uncommonChance / totalChance) * 100f;
            rareChance = (rareChance / totalChance) * 100f;
            ultraRareChance = (ultraRareChance / totalChance) * 100f;

            float roll = UnityEngine.Random.Range(1f, 101f);
            string rarity = string.Empty;

            if (roll <= commonChance)
            {
                rarity = "_Common";
            }
            else if (roll <= commonChance + uncommonChance)
            {
                rarity = "_Uncommon";
            }
            else if (roll <= commonChance + uncommonChance + rareChance)
            {
                rarity = "_Rare";
            }
            else
            {
                rarity = "_UltraRare";
            }

            return mobName + rarity;
        }
/*
        public string GenerateRarity(string mobName, int enhancedChance)
        {
            float rollChance = 101f;
            float roll = UnityEngine.Random.Range(1f, rollChance);
            string rarity = string.Empty;
            if (roll < 80f)
            {
                rarity = "_Common";
            }
            else if (roll < 95f)
            {
                rarity = "_Uncommon";
            }
            else if (roll < 99f)
            {
                rarity = "_Rare";
            }
            else
            {
                rarity = "_UltraRare";
            }
            return mobName + rarity;
        }
        */
        #endif
        void BuildItemDropped(ItemBuildMessage message){
            #if UNITY_SERVER //|| UNITY_EDITOR

            NetworkConnectionToClient nconn = message.owner.connectionToClient;
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            if(message.ItemName.Count > 0)
            print($"{playerData.PlayFabId} REQUESTED BuildItemDropped item: {message.ItemName[0]}");
            int quant = 1;
            if(message.mobName.Contains("StoneGolem_")){
                if(message.mobName.Contains("Common")){
                    quant = 6;
                }
                if(message.mobName.Contains("Uncommon")){
                    quant = 13;
                }
                if(message.mobName.Contains("Rare")){
                    quant = 30;
                }
                if(message.mobName.Contains("UltraRare")){
                    quant = 70;
                }
            }
            if(message.mobName.Contains("OreGolem_")){
                if(message.mobName.Contains("Common")){
                    quant = 6;
                }
                if(message.mobName.Contains("Uncommon")){
                    quant = 13;
                }
                if(message.mobName.Contains("Rare")){
                    quant = 30;
                }
                if(message.mobName.Contains("UltraRare")){
                    quant = 70;
                }
            }
            if(message.mobName.Contains("Deer_")){
                if(message.mobName.Contains("Common")){
                    quant = 6;
                }
                if(message.mobName.Contains("Uncommon")){
                    quant = 13;
                }
                if(message.mobName.Contains("Rare")){
                    quant = 30;
                }
                if(message.mobName.Contains("UltraRare")){
                    quant = 70;
                }
            }
            if(message.mobName.Contains("PossessedTree_")){
                if(message.mobName.Contains("Common")){
                    quant = 6;
                }
                if(message.mobName.Contains("Uncommon")){
                    quant = 13;
                }
                if(message.mobName.Contains("Rare")){
                    quant = 30;
                }
                if(message.mobName.Contains("UltraRare")){
                    quant = 70;
                }
            }
            if(message.mobName.Contains("PossessedPlant_")){
                if(message.mobName.Contains("Common")){
                    quant = 6;
                }
                if(message.mobName.Contains("Uncommon")){
                    quant = 13;
                }
                if(message.mobName.Contains("Rare")){
                    quant = 30;
                }
                if(message.mobName.Contains("UltraRare")){
                    quant = 70;
                }
            }
            foreach(var itemID in message.ItemID){
                (string DisplayName, string ItemClass, string ConsumableStatus) = GetItemDetails(itemID);
                string Quality = "Plain";
                    if(ItemClass == "TwoHandedWeapon" || ItemClass == "SingleHandedWeapon" || ItemClass == "Head" || 
                    ItemClass == "Chest"  || ItemClass == "Waist" || ItemClass == "Wrists" || ItemClass == "Earring" ||
                    ItemClass == "Arms" || ItemClass == "Feet" || ItemClass == "Hands" || ItemClass == "Ring"
                    || ItemClass == "Leggings" || ItemClass == "Necklace" || ItemClass == "OffHand"
                    || ItemClass == "Shield" || ItemClass == "Shoulders" || ItemClass == "Arms"){
                        Quality = GetQualityDropFormula();
                    }
                    string choice = string.Empty;
                    if(!string.IsNullOrEmpty(message.needWinnerSerial)){
                        choice = message.needWinnerSerial;
                    } else {
                        choice = message.greedWinnerSerial;
                    }
                    //print($"{choice} is choice {Quality} is quality");
                    TransformItemIntoDragonKill(nconn, playerData, itemID, choice, Quality, quant, false, false, null, true, message.owner.playerName, false);
                    message.owner.TargetLootedItem();
                
            }
        #endif
        }
         void BuildNewStack(NewStackCreated message){
            #if UNITY_SERVER //|| UNITY_EDITOR
            print("BuildNewStack 1");
            print($"Starting BuildNewStack {message.firstStackAmount} was first amount for test {message.assignedItem.itemID} is itemID");
            NetworkConnectionToClient nconn = message.owner.connectionToClient;
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED BuildNewStack on item:{message.assignedItem.GetItemName()}");
            List<string> ids = new List<string>
            {
                message.assignedItem.itemID
            };
            //var request = new GetCatalogItemsRequest();
            CharacterInventoryListItem modItem = new CharacterInventoryListItem();
            //request.CatalogVersion = "DragonKill_Characters_Bundles_Items";
            print("BuildNewStack Checking char sheets");

            if(message.selectedDestination != "Stash" && message.selectedDestination != "Tactician"){
                for (int E = 0; E < message.owner.GetInformationSheets().Count; E++)
                {
                //foreach(var sheet in message.owner.GetInformationSheets()){
                    if(message.owner.GetInformationSheets()[E].CharacterID == message.selectedDestination){
                        for (int Q = 0; Q < message.owner.GetInformationSheets()[E].CharInventoryData.Count; Q++)
                        {
                        //foreach(var charItem in message.owner.GetInformationSheets()[E].CharInventoryData){
                            if(message.owner.GetInformationSheets()[E].CharInventoryData[Q].Value.customID == message.assignedItem.customID){
                                //found our item to modify
                                modItem = message.owner.GetInformationSheets()[E].CharInventoryData[Q];
                                modItem.Value.amount = message.firstStackAmount;
                                modItem.Value.Changed = true;
                                modItem.Value.TacticianBelt = false;
                                modItem.Value.TacticianInventory = false;
                                modItem.Value.TacticianStash = false;
                                modItem.Value.TacticianEquip = false;
                                //message.owner.GetCharacterNewItem(message.selectedDestination, modItem);
                                print("BuildNewStack Checking char sheets Found mod!!");
                                break;
                            }
                        }
                        break;
                    }
                }
                if(modItem.Value != null){
                    message.owner.GetCharacterNewItem(message.selectedDestination, modItem);
                }
            }
            print("BuildNewStack Checking stash");

            if(message.selectedDestination == "Stash"){
                for (int S = 0; S < message.owner.GetTacticianSheet().StashInventoryData.Count; S++)
                {
                //foreach(var stashItem in message.owner.GetTacticianSheet().StashInventoryData){
                    if(message.owner.GetTacticianSheet().StashInventoryData[S].Value.customID == message.assignedItem.customID){
                        //found our item to modify
                        modItem = message.owner.GetTacticianSheet().StashInventoryData[S];
                        modItem.Value.amount = message.firstStackAmount;
                        modItem.Value.Changed = true;
                        
                        modItem.Value.TacticianStash = true;
                        modItem.Value.TacticianBelt = false;
                        modItem.Value.TacticianInventory = false;
                        modItem.Value.TacticianEquip = false;
                        print("BuildNewStack Checking stash Found mod!!");
                        break;
                    }
                }
                if(modItem.Value != null){
                    message.owner.GetStashNewItem(modItem);
                }

            }
            print("BuildNewStack Checking tact");

            if(message.selectedDestination == "Tactician"){
                for (int T = 0; T < message.owner.GetTacticianSheet().TacticianInventoryData.Count; T++)
                {
                //foreach(var tactItem in message.owner.GetTacticianSheet().TacticianInventoryData){
                    if(message.owner.GetTacticianSheet().TacticianInventoryData[T].Value.customID == message.assignedItem.customID){
                        //found our item to modify
                        modItem = message.owner.GetTacticianSheet().TacticianInventoryData[T];
                        modItem.Value.amount = message.firstStackAmount;
                        modItem.Value.Changed = true;
                        modItem.Value.TacticianInventory = true;
                        modItem.Value.TacticianBelt = false;
                        modItem.Value.TacticianEquip = false;
                        modItem.Value.TacticianStash = false;
                        //message.owner.GetTacticianNewItem(modItem);
                        print("BuildNewStack Checking tact Found mod!!");
                        break;
                    }
                }
                if(modItem.Value != null){
                    message.owner.GetTacticianNewItem(modItem);
                }
            }
            print("BuildNewStack 2");
            // here we are going to not get the catalog we are going to just simply build a copy of this item, but build it a new customID and also set its instanceID to be ItemGenerated or whatever it was
            /*
            ItemSelectable createdItem = new ItemSelectable{
                itemType = modItem.Value.itemType, amount = message.secondStackAmount, Weight = modItem.Value.Weight, Item_Name = modItem.Value.Item_Name, Durability = modItem.Value.Durability, DurabilityMax = modItem.Value.DurabilityMax,
                ItemSpecificClass = modItem.Value.ItemSpecificClass, itemSlot = modItem.Value.itemSlot, InstanceID = "NewItemGenerated", customID = Guid.NewGuid().ToString(), OwnerID = message.selectedDestination, TacticianInventory = modItem.Value.TacticianInventory,
                OGTacticianStash = false, OGTacticianBelt = false, OGTacticianInventory = false, TacticianStash = modItem.Value.TacticianStash, INVENTORY = modItem.Value.INVENTORY, Quality_item = modItem.Value.Quality_item, itemID = modItem.Value.itemID, NFT = false, EQUIPPED = false, EQUIPPEDSLOT = "0",
                STRENGTH_item = "0", AGILITY_item = "0", FORTITUDE_item = "0", ARCANA_item = "0", Armor_item = "0", MagicResist_item = "0", FireResist_item = "0", ColdResist_item = "0", DiseaseResist_item = "0", PoisonResist_item = "0", Rarity_item = modItem.Value.Rarity_item, Changed = true
            };
            */
            bool charItembool = false;
            if(modItem.Value.GetOwnerID() != "Tactician" || modItem.Value.GetOwnerID() != "Stash"){
                charItembool = true;
            }
            (string DisplayName, string ItemClass, string ConsumableStatus) = GetItemDetails(modItem.Value.itemID);

            ItemSelectable createdItem = ItemDataStorage.Instance.BuildItemSelectable(message.selectedDestination, "Plain", message.secondStackAmount, null, false, message.owner.playerName, DisplayName, "NewItemGenerated", modItem.Value.itemID, null, modItem.Value.GetTacticianBelt(), 
            false, modItem.Value.GetTacticianInventory(),charItembool, false, "100", false, false);

            CharacterInventoryListItem DATA = new CharacterInventoryListItem();
            DATA.Key = createdItem.InstanceID;
            DATA.Value = createdItem;
            if(message.selectedDestination == "Tactician"){
                message.owner.ServerTacticianItemResult(DATA);
            }
            if(message.selectedDestination == "Stash"){
                message.owner.ServerPurchasedItemResult(DATA);
            }
            if(message.selectedDestination != "Tactician" && message.selectedDestination != "Stash"){
                message.owner.GetCharacterPickedUpItem(message.selectedDestination, DATA);
            }
            

            //PlayFabServerAPI.GetCatalogItems(request, result =>
            //{
            //print("BuildNewStack 3");
            //if (result.Catalog != null && result.Catalog.Count > 0)
            //{
            //    // Search through the catalog for the item you are interested in
            //    foreach (var item in result.Catalog)
            //    {
            //       if(item.ItemId == message.assignedItem.itemID){
            //        PlayFabServerAPI.GrantItemsToUser(new GrantItemsToUserRequest
            //        {
            //            PlayFabId = playerData.PlayFabId,
            //            ItemIds = ids
            //        }, result =>
            //        {
            //            print("BuildNewStack 4");
            //            print($"Starting BuildNewStack TransformItemIntoDragonKill {message.secondStackAmount} going to {message.selectedDestination}");
            //            string Quality = "Plain";
            //            foreach(var granteditem in result.ItemGrantResults){
            //                TransformItemIntoDragonKill(nconn, playerData, granteditem, message.selectedDestination, Quality, message.secondStackAmount, false, true);
            //            }
            //        }, error =>{
            //            Debug.Log(error.ErrorMessage);
            //        });
            //        break;
            //       }
            //    }
            //}
            //}, OnPlayFabError);
            //
            #endif
        }
        string GetQualityCraftFormula(int skill, string Quality)
        {
            System.Random randomRoll = new System.Random();
            double randomNumberCrafted;
            // Define the thresholds
            int[] thresholds = new int[] { skill / 4, skill / 7, skill / 15, skill / 25, skill / 50 };
            // Define the qualities
            string[] qualities = new string[] { "Fine", "Superb", "Magnificent", "Kingly", "Divine" };
            // Find the index of the incoming Quality
            int startIndex = Array.IndexOf(qualities, Quality);
            if (startIndex == -1)
            {
                // If the incoming quality is not found, default to the lowest quality
                startIndex = 0;
            }
            string bestAchievedQuality = Quality; // Start with the incoming quality
            for (int i = startIndex; i < thresholds.Length; i++)
            {
                randomNumberCrafted = randomRoll.NextDouble() * 100;
                if (randomNumberCrafted <= thresholds[i])
                {
                    bestAchievedQuality = qualities[i]; // Update the best achieved quality
                }
                else
                {
                    break; // If the roll fails to meet the threshold, exit the loop
                }
            }

            return bestAchievedQuality;
        }
/*
        string GetQualityCraftFormula(int skill, string Quality)
        {
            System.Random randomRoll = new System.Random();
            double randomNumberCrafted = randomRoll.NextDouble() * 100;
            // Define the thresholds
            int[] thresholds = new int[] { skill/4, skill/7, skill/15, skill/25, skill/50 };
            // Define the qualities
            string[] qualities = new string[] { "Fine", "Superb", "Magnificent", "Kingly", "Divine" };
            for (int i = 0; i < thresholds.Length; i++) {
                randomNumberCrafted = randomRoll.NextDouble() * 100;
                if(randomNumberCrafted <= thresholds[i]) {
                    Quality = qualities[i];
                } else {
                    break; // if the roll fails to meet the threshold, exit the loop
                }
            }
            return Quality;
        }
*/
        string GetQualityDropFormula()
        {
            string Quality = "Plain";
            System.Random random = new System.Random();
            double randomNumber = random.NextDouble() * 100;
            if (randomNumber <= 96)
            {
                Quality = "Plain";
            }
            else if (randomNumber <= 98.89)
            {
                Quality = "Fine";
            }
            else if (randomNumber <= 99.59)
            {
                Quality = "Superb";
            }
            else if (randomNumber <= 99.89)
            {
                Quality = "Magnificent";
            }
            else if (randomNumber <= 99.98)
            {
                Quality = "Kingly";
            }
            else if (randomNumber <= 100)
            {
                Quality = "Divine";
            }
            return Quality;
        }
        
        void GiveExpClassPoints(EXPCPMessage message){
            int playerCount = 0;
            for (int Q = 0; Q < message.tM.GetPCList().Count; Q++)
            {
                if(!message.tM.GetPCList()[Q].Dying){
                    playerCount++;
                }
            }
            float expPerPlayer = message.Experience / playerCount;
            float cpPerPlayer = message.ClassPoints / playerCount;
            print($"Sending chars their exp:{expPerPlayer} and cp:{cpPerPlayer}");
            SendEXPCP.Invoke(message.Match, cpPerPlayer, expPerPlayer);
            bool sewerNode = false;
            bool soloNode = false;
            Dictionary<ScenePlayer, List<string>> GiveCharToPlayer = new Dictionary<ScenePlayer, List<string>>();
            for (int W = 0; W < message.tM.GetPCList().Count; W++)
            {
                if(message.tM.GetPCList()[W].Dying){
                    continue;
                }
                ScenePlayer assignedPlayer = message.tM.GetPCList()[W].assignedPlayer;
                string charID = message.tM.GetPCList()[W].CharID;
            
                if (!GiveCharToPlayer.ContainsKey(assignedPlayer))
                {
                    // If the assignedPlayer does not exist in the dictionary, add it with a new list
                    GiveCharToPlayer[assignedPlayer] = new List<string> { charID };
                }
                else
                {
                    // If the assignedPlayer already exists in the dictionary, add the CharID to the existing list
                    GiveCharToPlayer[assignedPlayer].Add(charID);
                }
                //if(message.tM.GetPCList()[W].assignedPlayer.currentScene.Contains("Sewer")){
                //    sewerNode = true;
                //}
                //if(!message.tM.GetPCList()[W].assignedPlayer.currentScene.Contains("Sewer") && message.Match.players.Count == 1){
                //    soloNode = true;
                //}
                //string attacker = string.Empty;
            	//string defender = string.Empty;
            	//string content = "attacked";
            	//string amount = $"EXP: {expPerPlayer.ToString("F0")} and CP: {cpPerPlayer.ToString("F0")}";
            	//if(message.tM.GetPCList()[W] != null){
            	//    attacker = message.tM.GetPCList()[W].CharacterName;
            	//}
				//int type = 667; 
				//int element = 5;
            	//CombatLogNet cNet = new CombatLogNet(attacker, defender, content, amount, type, element, false);
                //if(!sewerNode && !soloNode){
                //    AwardEXPCPChat.Invoke(cNet, message.Match);
                //} else {
                //    message.tM.GetPCList()[W].RpcGainEXPCP(attacker, defender, content, amount, type, element);
                //}
            }
            foreach(var player in GiveCharToPlayer){
                PlayFabSaveEXPandClassPoints(player.Key, player.Value, expPerPlayer, cpPerPlayer, message.MobName);
            }

        }
        void PlayFabSaveEXPandClassPoints(ScenePlayer sPlayer, List<string> charSlots, float experienceValue, float classPointsValue, string mobName){
            #if UNITY_SERVER //|| UNITY_EDITOR
            //get player netconnection, 
            NetworkConnectionToClient nconn = sPlayer.connectionToClient;
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED PlayFabSaveEXPandClassPoints");
            List<string> charIDs = new List<string>(); 
            List<string> classpoints = new List<string>(); 
            List<string> exp = new List<string>();
            List<string> classpointsValues = new List<string>(); 
            List<string> expValues = new List<string>();
            for (int M = 0; M < charSlots.Count; M++){
                for (int W = 0; W < sPlayer.GetInformationSheets().Count; W++){
                    float EXP = 0f;
                    float CP = 0f;
                    bool foundCP = false;
                    bool foundEXP = false;
                    List<string> SetBonusItems = new List<string>();
                    if(sPlayer.GetInformationSheets()[W].CharacterID == charSlots[M]){
                        charIDs.Add(charSlots[M]);
                        for (int V = 0; V < sPlayer.GetInformationSheets()[W].CharStatData.Count; V++){
                            if(sPlayer.GetInformationSheets()[W].CharStatData[V].Key == "ClassPoints"){
                                CP = float.Parse(sPlayer.GetInformationSheets()[W].CharStatData[V].Value);
                                foundCP = true;
                                //classpoints.Add(Math.Round(CP + classPointsValue, 2).ToString("F2"));
                            }
                            if(sPlayer.GetInformationSheets()[W].CharStatData[V].Key == "EXP"){
                                EXP = float.Parse(sPlayer.GetInformationSheets()[W].CharStatData[V].Value);
                                foundEXP = true;
                                //exp.Add(Math.Round(EXP + experienceValue, 2).ToString("F2"));
                            }
                            if(foundCP && foundEXP){
                                break;
                            }
                        }
                        for(int Q = 0; Q < sPlayer.GetInformationSheets()[W].CharInventoryData.Count; Q++){
                            if(sPlayer.GetInformationSheets()[W].CharInventoryData[Q].Value.GetEQUIPPED()){
                                if(sPlayer.GetInformationSheets()[W].CharInventoryData[Q].Value.GetAmount() == 0 || sPlayer.GetInformationSheets()[W].CharInventoryData[Q].Value.Deleted){
                                    continue;
                                }
                                if(sPlayer.GetInformationSheets()[W].CharInventoryData[Q].Value.GetNFT()){
                                    if(StatAsset.Instance.IsItemInSet(sPlayer.GetInformationSheets()[W].CharInventoryData[Q].Value.GetItemName())){
                                        SetBonusItems.Add(sPlayer.GetInformationSheets()[W].CharInventoryData[Q].Value.GetItemName());
                                    }
                                }
                            }
                        }
                        float bonusMultiplier = 1f;
                        bonusMultiplier += StatAsset.Instance.CalculateExpBonus(SetBonusItems);
                        float expCopy = experienceValue;
                        expCopy *= bonusMultiplier;
                        classpoints.Add(Math.Round(CP + classPointsValue, 2).ToString("F2"));
                        exp.Add(Math.Round(EXP + expCopy, 2).ToString("F2"));
                        classpointsValues.Add(classPointsValue.ToString("F0"));
                        expValues.Add(expCopy.ToString("F0"));
                    }
                }
            }
            sPlayer.GetCharacterUpdateEXPCP(charIDs, classpoints, exp, expValues, classpointsValues, mobName);
            #endif
        }
        
        void RequestingPromotion(ScenePlayer sPlayer, string charSlot){
            #if UNITY_SERVER //|| UNITY_EDITOR
            // Create a dictionary to store the experience required for each level
            NetworkConnectionToClient nconn = sPlayer.connectionToClient;
            if(!CheckNullConnection(nconn)){
                return;
            }
            PlayerInfo playerData = (PlayerInfo)nconn.authenticationData;
            print($"{playerData.PlayFabId} REQUESTED RequestingPromotion");
            Dictionary<int, float> expPerLevel = new Dictionary<int, float> {
                {1, 4000f}, {2, 8000f}, {3, 12000f}, {4, 20000f}, {5, 30000f},
                {6, 55000f}, {7, 75000f}, {8, 100000f}, {9, 145000f}, {10, 180000f},
                {11, 220000f}, {12, 265000f}, {13, 300000f}, {14, 350000f}, {15, 425000f},
                {16, 500000f}, {17, 600000f}, {18, 700000f}, {19, 800000f}, {20, 1000000f}
            };
            Dictionary<int, int> energyCostPerLevel = new Dictionary<int, int> {
                {1, 100}, {2, 200}, {3, 300}, {4, 400}, {5, 500},
                {6, 600}, {7, 700}, {8, 800}, {9, 900}, {10, 1000},
                {11, 1200}, {12, 1400}, {13, 1600}, {14, 1800}, {15, 2000},
                {16, 2200}, {17, 2400}, {18, 2600}, {19, 2800}, {20, 3000}
            };

            Dictionary<int, float> timeCostPerLevel = new Dictionary<int, float> {
                {1, 1f}, {2, 5f}, {3, 15f}, {4, 60f}, {5, 180f},
                {6, 300f}, {7, 360f}, {8, 420f}, {9, 480f}, {10, 540f},
                {11, 660f}, {12, 780f}, {13, 900f}, {14, 1020f}, {15, 1140f},
                {16, 1260f}, {17, 1380f}, {18, 1500f}, {19, 1620f}, {20, 1740f}
            };
            float EXP = 0f;
            int LVL = 0;
            bool expFound = false;
            bool lvlFound = false;
            if(sPlayer.Energy >= energyCostPerLevel[LVL]){
                // If so, increase the level and decrease EXP by the required amount
                sPlayer.Energy -= energyCostPerLevel[LVL];
                CheckForLevelUpTactician(sPlayer, (float)energyCostPerLevel[LVL]);
            } else {
                return;
            }
            foreach(var sheet in sPlayer.GetInformationSheets()){
                if(sheet.CharacterID == charSlot){
                    foreach(var charStat in sheet.CharStatData){
                        if(charStat.Key == "LVL"){
                            LVL = int.Parse(charStat.Value);
                            lvlFound = true;
                        }
                        if(charStat.Key == "EXP"){
                            EXP = float.Parse(charStat.Value);
                            expFound = true;
                        }
                        if(expFound && lvlFound){
                            break;
                        }
                    }
                }
            }

            // Check if EXP is greater than or equal to the required experience for the next level
            if(EXP >= expPerLevel[LVL]){
                // If so, increase the level and decrease EXP by the required amount
                LVL += 1;
                EXP -= expPerLevel[LVL];
            }
            DateTime endTime = DateTime.UtcNow.AddMinutes(timeCostPerLevel[LVL]);

            // Convert the end time to a string
            string endTimeString = endTime.ToString("o"); // "o" is the round-trip format specifier

            CharacterStatListItem TimeStamp = (new CharacterStatListItem{
                Key = "TimeStampLVL",
                Value = endTimeString
            });
            CharacterStatListItem EXPItem = (new CharacterStatListItem{
                Key = "EXP",
                Value = Math.Round(EXP, 2).ToString("F2")
            });
            

            sPlayer.GetCharacterUpdateEXPLVL(charSlot, TimeStamp, EXPItem);
            PlayFabServerAPI.UpdateCharacterInternalData(new UpdateCharacterDataRequest
            {
                PlayFabId = playerData.PlayFabId,
                CharacterId = charSlot,
                Data = new Dictionary<string, string>
                {
                    {"EXP", Math.Round(EXP, 2).ToString("F2")},
                    {"TimeStampLVL", endTimeString}
                }
            }, result =>
            {
            }, error =>{
                Debug.Log(error.ErrorMessage); 
                Debug.Log(error.ErrorDetails);
                Debug.Log(error.Error);
            });
            #endif
        }
            #if UNITY_SERVER //|| UNITY_EDITOR

        private WebSocket ws;
            #endif

    void WebSocketBuild()
    {
            #if UNITY_SERVER //|| UNITY_EDITOR

        // Replace "your-heroku-app.herokuapp.com" with your actual Heroku app URL
        ws = new WebSocket("ws://dkpgamingapp-d9f21223f33f.herokuapp.com");

        ws.OnOpen += (sender, e) =>
        {
            Debug.Log("WebSocket Open");
            HandleRegisterServer();
        };

        ws.OnMessage += (sender, e) =>
        {
            //Debug.Log("WebSocket Message: " + e.Data);
            HandleWebsocketMessage(e.Data);
        };

        ws.OnError += (sender, e) =>
        {
            Debug.LogError("WebSocket Error: " + e.Message);
            
        };

        ws.OnClose += (sender, e) =>
        {
            Debug.Log("WebSocket Closed with reason: " + e.Reason + ", code: " + e.Code + ", wasClean: " + e.WasClean);
            StartCoroutine(ReconnectWebSocket());

        };

        try
        {
            Debug.Log("Attempting to connect to WebSocket...");
            ws.Connect();
            Debug.Log("WebSocket connection attempt finished.");
        }
        catch (System.Exception ex)
        {
            Debug.LogError("WebSocket Connection Exception: " + ex.Message);
        }
        //ws.Connect();
            #endif

    }
    void HandleRegisterServer(){
            #if UNITY_SERVER //|| UNITY_EDITOR

        if (ws != null && ws.IsAlive)
            {
                Debug.Log("Register server...");
                var message = new
                {
                    registerBuild = "Yes",
                    buildID = BuildID,
                    sessionID = SessionID,
                    serverPlayers = "0",
                    version = Version,
                    tactician = CONVO_KEY
                };

                //string json = JsonUtility.ToJson(message);
                string json = JsonConvert.SerializeObject(message); // Use JsonConvert instead of JsonUtility
            Debug.Log("Sending JSON: " + json); // Log the JSON string

                ws.Send(json);
                StartCoroutine(SendPeriodicMessages());
            }
            #endif

    }
    void HandleWebsocketMessage(string data){
            #if UNITY_SERVER //|| UNITY_EDITOR

        try
        {
            var response = JsonConvert.DeserializeObject<WebsocketResponse>(data);
            Debug.Log("Handling WebSocket message: " + data);

            // Process the response data
            if (!string.IsNullOrEmpty(response.meta.portString) && response.meta.portString != "Empty")
            {
                playfabPort = response.meta.portString;
            }
            if (!string.IsNullOrEmpty(response.meta.mirroredIPAddress) && response.meta.mirroredIPAddress != "Empty")
            {
                IPaddress = response.meta.mirroredIPAddress;
            }
            

            // Additional processing if needed
        }
        catch (System.Exception ex)
        {
            Debug.LogError("Error handling WebSocket message: " + ex.Message);
        }
            #endif

    }
            #if UNITY_SERVER //|| UNITY_EDITOR

    IEnumerator ReconnectWebSocket()
    {
        yield return new WaitForSeconds(5);
        Debug.Log("Reconnecting to WebSocket...");
        WebSocketBuild();
    }
    IEnumerator SendPeriodicMessages()
    {
        while (true)
        {
            yield return new WaitForSeconds(5);
            if (ws != null && ws.IsAlive)
            {
                Debug.Log("Sending periodic message to WebSocket...");
                var data = new
                {
                    buildID = BuildID,
                    sessionID = SessionID,
                    serverPlayers = playerConnections.Count.ToString(),
                    ipAddress = string.IsNullOrEmpty(IPaddress) ? "BlankIPAddress" : IPaddress,
                    port = string.IsNullOrEmpty(playfabPort) ? "BlankPort" : playfabPort,
                    version = Version,
                    tactician = CONVO_KEY // Add API key for authentication
                };

                //string json = JsonUtility.ToJson(data);
                string json = JsonConvert.SerializeObject(data); // Use JsonConvert instead of JsonUtility
                            Debug.Log("Sending JSON: " + json); // Log the JSON string


                ws.Send(json);
            }
        }
    }
            #endif

    /// Playfab Calls

    }
    [System.Serializable]
    public class DropTable
    {
        public List<DropTableItem> items;
    }

    [System.Serializable]
    public class DropTableItem
    {
        public string id;
        public float probability;
        public Guid uniqueId;
    }
    public class PlayerConnection
    {
        #if UNITY_SERVER //|| UNITY_EDITOR
        
                public ConnectedPlayer ConnectedPlayer;
        #endif
                public int ConnectionId;
        public NetworkConnectionToClient conn;

    }
    public class SpawnInfo
    {
        public bool MainChestLinked { get; set; }
        public string GroupName { get; set; }
        public string PointName { get; set; }
        public Transform SpawnTransform { get; set; }
    }
}